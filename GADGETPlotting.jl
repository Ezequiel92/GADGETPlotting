########################################################################################
# Julia script for creating plots and animations from the data generated by GADGET2/3/4. 
########################################################################################

using GadgetIO, GadgetUnits, SPHtoGrid, SPHKernels
using Unitful, UnitfulAstro
using Plots, StatsPlots.PlotMeasures, AverageShiftedHistograms
using Glob, FileIO, VideoIO, DelimitedFiles, LaTeXStrings

"Hₒ = 100 km s^(-1) Mpc^(-1) in Gyr^(-1)"
const HUBBLE_CONST = 0.102201

"""
Solar metallicity.

    M. Asplund et al. (2009). The Chemical Composition of the Sun. Annual Review of Astronomy 
    and Astrophysics, 47(1), 481–522. https://doi.org/10.1146/annurev.astro.46.060407.145222
"""
const SOLAR_METALLICITY = 0.0134

########################################################################################
# AUXILIARY FUNCTIONS.
########################################################################################

"""
	uglyUnitDeserialization(unit::Unitful.FreeUnits)::String
ast `unit` to a String. If given a plain String it will return it unchanged.

# Arguments 
- `unit::Unitful.FreeUnits`: Unit to be deserialize.

# Returns
- A String with the unit of `unit`, e.g. unit = UnitfulAstro.kpc -> "kpc".
"""
function uglyUnitDeserialization(unit::Unitful.FreeUnits)::String
	
    original_stdout = stdout
    read_pipe = redirect_stdout()[1] 
    println(unit)  
    string = filter(x -> !isspace(x), readline(read_pipe))
    redirect_stdout(original_stdout)

    return string
end

"""
    relative(   p::Plots.Plot, 
                rx::Float64, 
                ry::Float64, 
                rz::Union{Float64,Nothing}=nothing)::Union{ Tuple{Float64,Float64},
                                                            Tuple{Float64,Float64,Float64}}
    
Give the absolute coordinates for a Plot given relative ones.

# Arguments 
- `p::Plots.Plot`: Plot for which the absolute coordinates will be calculated.
- `rx::Float64`: x relative coordinate, rx ∈ [0, 1].
- `ry::Float64`: y relative coordinate, ry ∈ [0, 1].
- `rz::Union{Float64,Nothing}=nothing`: z relative coordinate, rz ∈ [0, 1].

# Returns
- A Tuple with the absolute coordinates: (x, y) or (x, y, z).
"""
function relative(  p::Plots.Plot, 
                    rx::Float64, 
                    ry::Float64, 
                    rz::Union{Float64,Nothing}=nothing)::Union{Tuple{Float64,Float64},Tuple{Float64,Float64,Float64}}
    
    xlims = Plots.xlims(p) 
    ylims = Plots.ylims(p)
    
    if rz === nothing
        return  xlims[1] + rx * (xlims[2] - xlims[1]), 
                ylims[1] + ry * (ylims[2] - ylims[1])
    else
        zlims = Plots.zlims(p)

        return  xlims[1] + rx * (xlims[2] - xlims[1]), 
                ylims[1] + ry * (ylims[2] - ylims[1]), 
                zlims[1] + rz * (zlims[2] - zlims[1])
    end
end

"""
    makeVideo(  source_path::String, 
                source_format::String, 
                video_path::String, 
                video_name::String, 
                frame_rate::Int64)::Nothing
	
Make a MP4 video from a stack of images. 

The H.264 codec is used with no compression and the source images can be in
any format available in ImageIO.jl, e.g. ".png", ".svg", ".jpeg", etc.

# Arguments
- `source_path::String`: Path of the directory containing the images.	
- `source_format::String`: File format of the source images. 
- `video_path::String`: Path of the directory where the resulting video will be stored.
- `video_name::String`: Name of the video to be generated, without extension, e.g. "video".	
- `frame_rate::Int64`: Frame rate of the output video.
"""
function makeVideo(	source_path::String, 
					source_format::String, 
					video_path::String, 
					video_name::String, 
					frame_rate::Int64)::Nothing

    # Loads the target images.
    imgstack = []
    for image in glob("*" * source_format, source_path)
        push!(imgstack, load(image))
    end

    # Creates the video with the specified frame rate and name.
    props = [:priv_data => ("crf" => "0", "preset" => "ultrafast")]
    encodevideo(video_path * video_name * ".mp4", 
                imgstack, 
                framerate=frame_rate, 
                AVCodecContextProperties=props)
	
	return nothing
end

"""
    smoothWindow(   x_data::Array{T,1} where T <: Real, 
                    y_data::Array{T,1} where T <: Real, 
                    bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}

Separate the range of values of `x_data` in `bins` contiguous windows, and replaces 
every value within the window with the mean in order to smooth out the data. 

It assumes that the length of `y_data` and `x_data` is the same.

# Arguments
- `x_data::Array{T,1} where T <: Real`: Data used to create the windows.
- `y_data::Array{T,1} where T <: Real`: Data to be smoothed out.
- `bins::Int64`: Number of windows to be used in the smoothing.

# Returns
- The smooth data.
"""
function smoothWindow(  x_data::Array{T,1} where T <: Real,
                        y_data::Array{T,1} where T <: Real, 
                        bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}    
						
	# Initialize output arrays.
    smooth_x_data = Array{Float64}(undef, bins)
    smooth_y_data = Array{Float64}(undef, bins)

    # First value of the x axis.
    start = minimum(x_data)
    # Widths of the smoothing windows.
    width = (maximum(x_data) - start) / bins
    
    for i in 1:bins
        # Find the indices of the `x_data` and `y_data` which fall within window i.
        idx = findall(x -> start + width * (i - 1) <= x < start + width * i, x_data)
		
        # Store mean values in output arrays.
        smooth_x_data[i] = sum(x_data[idx]) / length(idx)
        smooth_y_data[i] = sum(y_data[idx]) / length(idx)
    end
    
    return smooth_x_data, smooth_y_data
end

"""
    densityProfile( mass_data::Array{Float64,1}, 
                    distance_data::Array{Float64,1}, 
                    r_max::Float64, 
                    bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}
	
Compute a density profile, up to a radius `r_max`. 

`r_max` and `distance_data` must be in the same units.

# Arguments
- `mass_data::Array{Float64,1}`: Masses of the particles.
- `distance_data::Array{Float64,1}`: Radial distances of the particles. 
- `r_max::Float64`: Maximum distance up to which the profile will be computed.
- `bins::Int64`: Number of subdivisions of [0, `r_max`] to be used for the profile.

# Returns
- A Tuple of two Arrays with the densities and their radial distances.
"""
function densityProfile(mass_data::Array{Float64,1},
                        distance_data::Array{Float64,1}, 
                        r_max::Float64,
                        bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}

    # Initialize output arrays.
    x_data = Array{Float64}(undef, bins)
    y_data = Array{Float64}(undef, bins)

    # Width of each spherical shell used to calculate the density within.
    width = r_max / bins
    
    for i in 1:bins
        # Indices of `mass_data` and `distance_data` within window i.
        idx = findall(x -> width * (i - 1) <= x < width * i, distance_data)

        if isempty(idx)
            x_data[i] = width * (i - 0.5)
            y_data[i] = 0
        else
            total_mass = sum(mass_data[idx])
            volume = 4 / 3 * π * width^3 * (3 * i * i - 3 * i + 1)
            
            # Mean distance for window i.
            x_data[i] = sum(distance_data[idx]) / length(idx)
			
            # Density for window i.
            y_data[i] = total_mass / volume
        end
    end
    
    return x_data, y_data
end

"""
    metallicityProfile( mass_data::Array{Float64,1}, 
                        distance_data::Array{Float64,1}, 
                        z_data::Array{Float64,1}, 
                        r_max::Float64, 
                        bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}
	
Compute a metallicity profile, up to a radius `r_max` and normalize to the solar metallicity.

`r_max` and `distance_data` must be in the same units, and the resulting metallicity 
will be normalized to the solar metallicity given by the constant `SOLAR_METALLICITY`.

# Arguments
- `mass_data::Array{Float64,1}`: Masses of the particles.
- `distance_data::Array{Float64,1}`: Radial distances of the particles. 
- `z_data::Array{Float64,1}`: Metal content of the particles in mass units.
- `r_max::Float64`: Maximum distance up to which the profile will be computed.
- `bins::Int64`: Number of subdivisions of [0, `r_max`] to be used for the profile.

# Returns
- A Tuple of two Arrays with the metallicities and their radial distances.
"""
function metallicityProfile(mass_data::Array{Float64,1},
                            distance_data::Array{Float64,1}, 
                            z_data::Array{Float64,1}, 
                            r_max::Float64,
                            bins::Int64)::Tuple{Array{Float64,1},Array{Float64,1}}

    # Initialize output arrays.
    x_data = Array{Float64}(undef, bins)
    y_data = Array{Float64}(undef, bins)

    # Width of each spherical shell used to calculate the metallicity within.
    width = r_max / bins
    
    for i in 1:bins
        # Indices of `mass_data`, `distance_data` and `z_data` within window i.
        idx = findall(x -> width * (i - 1) <= x < width * i, distance_data)

        if isempty(idx)
            x_data[i] = width * (i - 0.5)
            y_data[i] = 0
        else
            total_mass = sum(mass_data[idx])
            total_z = sum(z_data[idx])
            
            # Mean distance for window i.
            x_data[i] = sum(distance_data[idx]) / length(idx)
			
            # Metallicity for window i.
            y_data[i] = (total_z / total_mass) / SOLAR_METALLICITY
        end
    end
    
    return x_data, y_data
end

########################################################################################
# DATA ACQUISITION FUNCTIONS.
########################################################################################

"""
	getSnapshots(base_name::String, source_path::String)::Dict{String,Tuple{Vararg{String}}}

Organize the GADGET output files, grouping them by snapshot in an iterator.

# Arguments
- `base_name::String`: Base name of the snapshot files, 
  set in the GADGET variable SnapshotFileBase.
- `source_path::String`: Path of the directory containing the snapshot files, 
  set in the GADGET variable OutputDir.

# Returns
- A dictionary with two entries. 
	- Key "numbers" => A tuple of Strings representing the numbers 
    that characterize each snapshots.
    - Key "snap_files" => A tuple of Strings with the paths to files, one file per 
    snapshot, as follows: 
    (`source_path` `base_name`_001 ... `source_path` `base_name`_NNN) 
    where NNN is the total number of snapshots.
"""
function getSnapshots(  base_name::String, 
                        source_path::String)::Dict{String,Tuple{Vararg{String}}}

	# Get the full list of paths to every GADGET file in `source_path`.
    file_list = glob(base_name * "_*",  source_path)
    
	# Get the number of files per snapshot.
    num_files = read_header(first(file_list)).num_files
    
    if num_files > 1
        # If there are multiple files per snapshot, delete the trailing .n.
        map!(x -> rsplit(x, "."; limit=2)[1], file_list, file_list)
		# And delete duplicates.
		unique!(file_list)
    end
	
	# Get the numbers that characterize each snapshot.
    numbers = map(x -> rsplit(x, base_name * '_'; limit=2)[2], file_list)
    
    return Dict("numbers" => tuple(numbers...), "snap_files" => tuple(file_list...))
end

"""
	timeSeriesData(sim_files::Tuple{Vararg{String}}; <keyword arguments>)::Dict{String,Any}
					
Get several parameters defined at every snapshot, as a series of values for the whole simulation. 

# Arguments
- `sim_files::Tuple{Vararg{String}}`: Output of the function getSnapshots corresponding 
  to the key "snap_files", containing an Array with the file paths for the snapshots.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.

# Returns
- A dictionary.
	- All but one are: Key "property" => One dimensional array with the numeric values 
    of the property in the key (one value per snapshot) for the whole simulation. 
	- Key "units" => A dictionary with the units used, for easy piping with other functions.
	- Key "labels" => A dictionary with the labels to be used when plotting the quantities.
"""
function timeSeriesData(sim_files::Tuple{Vararg{String}}; 
                        sim_cosmo::Int64=0, 
                        mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun, 
                        time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                        sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr)::Dict{String,Any}
    
    time_series = Dict( "scale_factor" => [],       # Dimensionless.
                        "redshift" => [],           # Dimensionless.
                        "clock_time" => [],         # `time_unit`.
                        "sfr" => [],                # `sfr_unit`.
                        "sfr_prob" => [],           # `sfr_unit`.
                        "gas_number" => [],         # Dimensionless.
                        "dm_number" => [],          # Dimensionless.
                        "star_number" => [],        # Dimensionless.
                        "gas_mass" => [],           # `mass_unit`.
                        "dm_mass" => [],            # `mass_unit`.
                        "star_mass" => [],          # `mass_unit`.
                        "gas_frac" => [],           # Dimensionless.
                        "dm_frac" => [],            # Dimensionless.
                        "star_frac" => [],          # Dimensionless.
                        "gas_bar_frac" => [],       # Dimensionless.
                        "star_bar_frac" => [],      # Dimensionless.
                        # Unit pass-through.
                        "units" => Dict("mass" => mass_unit,    
                                        "time" => time_unit,
                                        "sfr" => sfr_unit),
                        # Labels for printing.
                        "labels" => Dict("scale_factor" => "a",                  
                                        "redshift" => "z",                     
                                        "clock_time" => "t", 	              
                                        "sfr" => "SFR", 			              
                                        "sfr_prob" => "SFR probability", 			           
                                        "gas_number" => "Gas particle number", 	            
                                        "dm_number" => "Dark matter particle number", 		               
                                        "star_number" => "Star number", 	            
                                        "gas_mass" => "Total gas mass", 		               
                                        "dm_mass" => "Total dark matter mass", 		            
                                        "star_mass" => "Total star mass", 		               
                                        "gas_frac" => "Gas fraction", 		                
                                        "dm_frac" => "Dark matter fraction", 		                
                                        "star_frac" => "Stars fraction", 	                   
                                        "gas_bar_frac" => "Baryonic gas fraction)",                  
                                        "star_bar_frac" => "Baryonic star fraction"))
    
    for (index, snapshot) in enumerate(sim_files)
        header = read_header(snapshot)

        # Object for unit conversion.
        if sim_cosmo == 1
            GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
        else
            # For Newtonian simulations uses the default scale factor, a = 1.
            GU = GadgetPhysicalUnits(hpar=header.h0)
        end

        # Number of particles of each type.
        gas_number = header.nall[1]
        dm_number = header.nall[2]
        star_number = header.nall[5]
		
        if block_present(snapshot, "MASS")
            
			# Total mass of gas in `mass_unit`.
			if gas_number != 0
				if header.massarr[1] != 0
					# If all gas particles have the same mass.
					gas_mass = header.massarr[1] * gas_number
				else
					gas_mass = sum(read_snap(snapshot, "MASS", 0))   
				end
				gas_mass = ustrip(Float64, mass_unit, gas_mass * GU.m_cgs)
			else
				# In the case that there are no gas particles.
				gas_mass = 0.0
			end

			# Total mass of dark matter in `mass_unit`.
			if dm_number != 0
				if header.massarr[2] != 0
					# If all dark matter particles have the same mass.
					dm_mass = header.massarr[2] * dm_number
				else
					dm_mass = sum(read_snap(snapshot, "MASS", 1))
				end
				dm_mass = ustrip(Float64, mass_unit, dm_mass * GU.m_cgs)
			else
				# In the case that there are no dark matter particles.
dm_mass = 0.0
			end
		   
			# Total mass of stars in `mass_unit`.
			if star_number != 0
                if header.massarr[5] != 0
					# If all star particles have the same mass.
					star_mass = header.massarr[5] * star_number
                else
					star_mass = sum(read_snap(snapshot, "MASS", 4))
				end
				star_mass = ustrip(Float64, mass_unit, star_mass * GU.m_cgs)
			else
				# In the case that there are no star particles.
				star_mass = 0.0
            end
            
            # Total baryonic mass in `mass_unit`.
			baryonic_mass = gas_mass + star_mass
			# Total mass of the system in `mass_unit`.
			total_mass = baryonic_mass + star_mass	
        
        else
			error("There is no block 'MASS' in snapshot located at $snapshot")
		end
		
		if block_present(snapshot, "SFR")
		
			# SFR given by the subresolution routine inside GADGET in `sfr_unit`.
			if header.nall[1] != 0
				sfr_prob = sum(read_snap(snapshot, "SFR", 0))
				sfr_prob = ustrip(Float64, sfr_unit, sfr_prob * (GU.m_cgs / GU.t_Myr)) 
			else
				# In the case that there are no gas particles.
				sfr_prob = 0.0
			end
		
		else
			error("There is no block 'SFR' in snapshot located at $snapshot")
		end

        if sim_cosmo == 1

            a = header.time     # Scale factor.
            z = (1 / a) - 1     # Redshift.

            if index == 1
                # In the first step, clock time and SFR are set to 0.
                t = 0.0
                sfr = 0.0
            else
                # In every other step, clock time and SFR are calculated.
                H0 = header.h0 * HUBBLE_CONST 									# Hubble constant in 1 / Gyr.
                E = sqrt(header.omega_l + (header.omega_0 / a^3))   			# Energy.
                t_int = 1 / (H0 * (1 + z) * sqrt(E)) 							# Integrand of the time integral in Gyr.
                t_int = ustrip(Float64, time_unit, t_int * UnitfulAstro.Gyr)  	# Integrand of the time integral in `time_unit`.
				
                Δz = time_series["redshift"][index - 1] - z 
                Δt = Δz * t_int
				Δstar_mass = star_mass - time_series["star_mass"][index - 1]
				
				sfr = ustrip(Float64, sfr_unit, (Δstar_mass / Δt) * (mass_unit / time_unit))
                t = time_series["clock_time"][index - 1] + Δt
            end
        else
            # For Newtonian simulations, set the redshift to 0 and the scale factor to 1.
            a = 1.0
            z = 0.0
            if index == 1
                # In the first step, clock time and SFR are set to 0.
                t = 0.0
                sfr = 0.0
            else 
                # In every other step, clock time and SFR are calculated.
                t = ustrip(Float64, time_unit, header.time * GU.t_Myr)
				
                Δt = t - time_series["clock_time"][index - 1]
                Δstar_mass = star_mass - time_series["star_mass"][index - 1]
				
                sfr = ustrip(Float64, sfr_unit, (Δstar_mass / Δt) * (mass_unit / time_unit))
            end    
        end

        # Time-like parameters.
        push!(time_series["scale_factor"], a)
        push!(time_series["redshift"], z)
        push!(time_series["clock_time"], t)

        # Real SFR.
        push!(time_series["sfr"], sfr)
        # SFR given by the subresolution routine (∝ probability of star formation).
        push!(time_series["sfr_prob"], sfr_prob)

        # Number of particles of each kind.
        push!(time_series["gas_number"], gas_number)
        push!(time_series["dm_number"], dm_number)
        push!(time_series["star_number"], star_number)

        # Total mass of each kind.
        push!(time_series["gas_mass"], gas_mass)
        push!(time_series["dm_mass"], dm_mass)
        push!(time_series["star_mass"], star_mass)

        # Mass fraction relative to total mass of the system.
        push!(time_series["gas_frac"], gas_mass / total_mass)
        push!(time_series["dm_frac"], dm_mass / total_mass)
        push!(time_series["star_frac"], star_mass / total_mass)

        # Mass fraction relative to total baryonic mass.
        push!(time_series["gas_bar_frac"], gas_mass / baryonic_mass)
        push!(time_series["star_bar_frac"], star_mass / baryonic_mass)
    end
    
    return time_series
end

"""
	positionData(snapshot::String; <keyword arguments>)::Dict{String,Any}

Gets the coordinates of the different particles at a specific time step.

# Arguments
- `snapshot::String`: Path to a given snapshot.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `box_size::Unitful.Quantity=1000 * UnitfulAstro.kpc`: Size of the plotting region if 
  vacuum boundary conditions were used. It has to have units, e.g. 1000 * UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.

# Returns
- A dictionary with six entries.
	- Keys "gas", "dark_matter", "stars" => 2 dimensional arrays, which contains 
    the positions of the particles of the type given by the key. Each row is a 
    particle and each column corresponds to coordinates x, y and z respectively.
	- Key "box_size" => The range of values for the plotting of the positions, 
    i.e. a range of ± `box_size` if vacuum boundary conditions were used, 
    or (0, `header.boxsize`) if periodic boundary conditions were used.
	Notice how the side length of the region is 2 * `box_size` for vacuum boundary 
	conditions and `header.boxsize` for periodic boundary conditions.
	- Key "periodic" => A boolean indicating the type of boundary condition.
	false -> vacuum boundary condition.
	true -> periodic boundary condition.
	- Key "unit" => The length unit used, i.e. is a pass-through of `length_unit`. 
"""
function positionData(  snapshot::String; 
                        sim_cosmo::Int64=0, 
                        length_unit::Unitful.FreeUnits=UnitfulAstro.kpc, 
                        box_size::Unitful.Quantity=1000 * UnitfulAstro.kpc)::Dict{String,Any}

    header = read_header(snapshot)

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

    # Get the correct region size in `length_unit`, given the type of boundary condition used.
    if header.boxsize == 0
		# Vacuum boundary condition.
        size = round(ustrip(Float64, length_unit, box_size), digits=1)
    else
		# Periodic boundary conditions.
        size = round(ustrip(Float64, length_unit, header.boxsize * GU.x_cgs), digits=1)
    end

	if block_present(snapshot, "POS")
	
		if header.nall[1] != 0
            gas_pos = read_snap(snapshot, "POS", 0)
            # Transformation from internal units to `length_unit`.
			gas_pos = @. ustrip(Float64, length_unit, gas_pos * GU.x_cgs)
		else 
			# In the case that there are no gas particles.
			gas_pos = Array{Float64}(undef, 0, 2)
		end

		if header.nall[2] != 0
            dm_pos = read_snap(snapshot, "POS", 1)
            # Transformation from internal units to `length_unit`.
			dm_pos =  @. ustrip(Float64, length_unit, dm_pos * GU.x_cgs)
		else 
			# In the case that there are no dark matter particles.
			dm_pos = Array{Float64}(undef, 0, 2)
		end
			
		if header.nall[5] != 0
            star_pos = read_snap(snapshot, "POS", 4)
            # Transformation from internal units to `length_unit`.
			star_pos = @. ustrip(Float64, length_unit, star_pos * GU.x_cgs)
		else 
			# In the case that there are no star particles.
			star_pos = Array{Float64}(undef, 0, 2)
		end
		
	else
		error("There is no block 'POS' in snapshot located at $snapshot")
	end

    return Dict("gas" => gas_pos, 
                "dark_matter" => dm_pos, 
                "stars" => star_pos,
                "box_size" => size,
				"periodic" => (header.boxsize != 0),
                "unit" => length_unit)
end

"""
    densityData(snapshot::String; <keyword arguments>)::Dict{String,Any}

Get the densities of the gas particles at a specific time step.

# Arguments
- `snapshot::String`: Path to a given snapshot.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3`: Unit of density 
  to be used in the output, all available density units in Unitful and UnitfulAstro can 
  be used, e.g. UnitfulAstro.Msun / UnitfulAstro.kpc^3, which is the default.

# Returns
- A dictionary with two entries.
    - Key "gas_density" => One dimensional array, which contains the densities
    of the particles of gas. 
    - Key "unit" => The unit used, i.e. is a pass-through of `density_unit`. 
"""
function densityData(   snapshot::String; 
                        sim_cosmo::Int64=0, 
                        density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3)::Dict{String,Any}
	
    header = read_header(snapshot)

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

	if block_present(snapshot, "RHO")
	
		if header.nall[1] != 0
            ρ = read_snap(snapshot, "RHO", 0)
            # Transformation from internal units to `density_unit`.
			ρ = @. ustrip(Float64, density_unit, ρ * GU.rho_cgs)
		else 
			# In the case that there are no gas particles.
			ρ  = []
		end
	
	else
		error("There is no block 'RHO' in snapshot located at $snapshot")
	end

    return Dict("gas_density" => ρ, "unit" => density_unit)
end

"""
    hsmlData(snapshot::String; <keyword arguments>)::Dict{String,Any}

Get the smoothing lengths of the gas particles at a specific time step.

# Arguments
- `snapshot::String`: Path to a given snapshot.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.

# Returns
- A dictionary with two entries.
    - Key "gas_hsml" => A one dimensional array, which contains the smoothing lengths
    of the particles of gas. 
    - Key "unit" => The unit used, i.e. is a pass-through of `length_unit`. 
"""
function hsmlData(  snapshot::String; 
                    sim_cosmo::Int64=0, 
                    length_unit::Unitful.FreeUnits=UnitfulAstro.kpc)::Dict{String,Any}

    header = read_header(snapshot)

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

	if block_present(snapshot, "HSML")
	
		if header.nall[1] != 0
            hsml = read_snap(snapshot, "HSML", 0)
            # Transformation from internal units to `length_unit`.
			hsml = @. ustrip(Float64, length_unit, hsml * GU.x_cgs)
		else 
			# In the case that there are no gas particles.
			hsml  = []
		end
	
	else
		error("There is no block 'HSML' in snapshot located at $snapshot")
	end

    return Dict("gas_hsml" => hsml, "unit" => length_unit)
end

"""
    massData(snapshot::String, type::String; <keyword arguments>)::Dict{String,Any}

Get the mass of the particles at a specific time step.

# Arguments
- `snapshot::String`: Path to a given snapshot.
- `type::String`: Particle type.
  "gas" -> Gas particle. 
  "dark_matter" -> Dark matter particle.
  "stars" -> Star particle.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.

# Returns
- A dictionary with three entries.
    - Key "mass" => A one dimensional array, which contains the masses of the particles. 
    - Key "unit" => The unit used, i.e. is a pass-through of `mass_unit`. 
    - Key "type" => A String with the particle type, 
"""
function massData(  snapshot::String, 
                    type::String;
                    sim_cosmo::Int64=0,
                    mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun)::Dict{String,Any}
	
    header = read_header(snapshot)

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

    # Select type of particle.
    if type == "gas"
        type_num = 0
        elseif type == "dark_matter"
        type_num = 1
        elseif type == "stars"
        type_num = 4
    else
        error("Particle type '$type ' not supported. The supported types are 'gas', 'dark_matter' and 'stars'")
    end

	if block_present(snapshot, "MASS")
	
		if header.nall[type_num + 1] != 0
            m = read_snap(snapshot, "MASS", type_num)
            # Transformation from internal units to `mass_unit`.
			m = @. ustrip(Float64, mass_unit, m * GU.m_cgs)
		else 
			# In the case that there are no particles.
			m  = [Inf]
		end
		
	else
		error("There is no block 'MASS' in snapshot located at $snapshot")
	end

    return Dict("mass" => m, "unit" => mass_unit, "type" => type)
end

"""
    zData(snapshot::String, type::String; <keyword arguments>)::Dict{String,Any}

Get the metallicity of the particles at a specific time step.

# Arguments
- `snapshot::String`: Path to a given snapshot.
- `type::String`: Particle type.
  "gas" -> Gas particle. 
  "stars" -> Star particle.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.

# Returns
- A dictionary with two entries.
    - Key "Z" => A one dimensional array, which contains the metallicities of the particles.  
    - Key "unit" => The unit used, i.e. is a pass-through of `mass_unit`. 
    - Key "type" => A String with the particle type. 
"""
function zData( snapshot::String, 
                type::String;
                sim_cosmo::Int64=0,
                mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun)::Dict{String,Any}
	
    header = read_header(snapshot)

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

    # Select type of particle.
    if type == "gas"
        type_num = 0
        elseif type == "stars"
        type_num = 4
    else
        error("Particle type '$type ' not supported. The supported types are 'gas' and 'stars'")
    end

    if block_present(snapshot, "Z")
	
		if header.nall[type_num + 1] != 0
            z = read_snap(snapshot, "Z", type_num)

            # Initialize output array.
            Z = Array{Float64}(undef, size(z, 1))
            for i in 1:size(z, 1)
                # Considers all elements but the ones at position 1 and 7, i.e. H and He.
                z_tot = sum(z[i, [2,3,4,5,6,8,9,10,11,12]])
                # Transformation from internal units to `mass_unit`.
                z_tot = @. ustrip(Float64, mass_unit, z_tot * GU.m_cgs)

                Z[i] = z_tot
        end
		else 
			# In the case that there are no particles.
			Z = [Inf]
		end
		
	else
		error("There is no block 'Z' in snapshot located at $snapshot")
    end

    return Dict("Z" => Z, "unit" => mass_unit, "type" => type)
end

"""
    sfrTxtData(source_path::String, base_name::String; <keyword arguments>)::Dict{String,Any}

Get the column data from the file sfr.txt.

Transform from internal units to the ones indicated by `mass_unit`, `time_unit` and `sfr_unit`.

# Arguments
- `source_path::String`: Path of the directory containing the sfr.txt file.
- `base_name::String`: Base name of the snapshot files, 
  set in the GADGET variable SnapshotFileBase.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.

# Returns
- A dictionary with six entries.
    - Key "1" => A one dimensional array, with the first column (time).  
    - Key "2" => A one dimensional array, with the second column (total mass - probability).  
    - Key "3" => A one dimensional array, with the third column (SFR - original GADGET).  
    - Key "4" => A one dimensional array, with the fourth column (SFR- probability).  
    - Key "5" => A one dimensional array, with the fifth column (total mass).  
    - Key "6" => A one dimensional array, with the sixth column (SFR).  
"""
function sfrTxtData(source_path::String, 
                    base_name::String;
                    sim_cosmo::Int64=0,                    
                    mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun, 
                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                    sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr)::Dict{Int64,Array{Float64,1}}

    header = read_header(source_path * base_name * "_000")

    # Object for unit conversion.
    if sim_cosmo == 1
        GU = GadgetPhysicalUnits(a_scale=header.time, hpar=header.h0)
    else
        # For Newtonian simulation uses the default scale factor, a = 1.
        GU = GadgetPhysicalUnits(hpar=header.h0)
    end

    # Get data from file.
    sfr_txt = readdlm(source_path * "sfr.txt", Float64)

    # Column extraction and unit conversion.
    column_1 = @. ustrip(Float64, time_unit, sfr_txt[:,1] * GU.t_Myr) 
    column_2 = @. ustrip(Float64, mass_unit, sfr_txt[:,2] * GU.m_cgs) 
    column_3 = @. ustrip(Float64, sfr_unit, sfr_txt[:,3] * (GU.m_cgs / GU.t_Myr)) 
    column_4 = @. ustrip(Float64, sfr_unit, sfr_txt[:,4] * (UnitfulAstro.Msun / UnitfulAstro.yr)) 
    column_5 = @. ustrip(Float64, mass_unit, sfr_txt[:,5] * GU.m_cgs) 
    column_6 = @. ustrip(Float64, sfr_unit, sfr_txt[:,6] * (GU.m_cgs / GU.t_Myr)) 

    return Dict(1 => column_1, 
                2 => column_2,
                3 => column_3,
                4 => column_4,
                5 => column_5,
                6 => column_6)
end

########################################################################################
# PLOTTING FUNCTIONS.
########################################################################################

"""
    scatterGridPlot(position_data::Dict{String,Any})::Plots.Plot

Make 9 scatter plots, as a single figure in a 3x3 layout, of the positions of the 
particles in the XY, XZ and YZ planes for the gas, dark matter and stars.

The axes are in the unit `position_data["unit"]`, with a range of ± `position_data["box_size"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.

# Returns
- The figure outputted by Plots.jl.
"""
function scatterGridPlot(position_data::Dict{String,Any})::Plots.Plot
    
    gas_pos = position_data["gas"]
    dm_pos = position_data["dark_matter"]
    stars_pos = position_data["stars"]

    if isempty(gas_pos)
        # In the case that there are no gas particles.
        gas_x = []
        gas_y = []
        gas_z = []
    else
        gas_x = gas_pos[:,1]
        gas_y = gas_pos[:,2]
        gas_z = gas_pos[:,3]
    end

    if isempty(dm_pos)
        # In the case that there are no dark matter particles.
        dm_x = []
        dm_y = []
        dm_z = []
    else
        dm_x = dm_pos[:,1]
        dm_y = dm_pos[:,2]
        dm_z = dm_pos[:,3]
    end

    if isempty(stars_pos)
        # In the case that there are no star particles.
        stars_x = []
        stars_y = []
        stars_z = []
    else
        stars_x = stars_pos[:,1]
        stars_y = stars_pos[:,2]
        stars_z = stars_pos[:,3]
    end
	
	if position_data["periodic"]
		# For periodic boundary conditions.
		stars_size = gas_size = dm_size = (position_data["box_size"] / 2) * 0.95
	else
		# For vacuum boundary conditions.
		stars_size = position_data["box_size"] * 1.1	# Plotting region for visible galaxy, i.e. stars.
		gas_size = stars_size * 7.0						# The plotting region for gas and dark matter is bigger.
		dm_size = stars_size * 3.0
	end
	
	# Unit as a String for the axes labels.
    unit = uglyUnitDeserialization(position_data["unit"])

    # Plots of the XY plane.
    pl_gas_x_y = scatter(   gas_x, gas_y, 
                            title="Gas - XY plane", 
                            xlabel="x / $unit",
                            ylabel="y / $unit",
                            markercolor=:blueviolet,
                            background_color_inside=:black,
                            xlims=(-gas_size, gas_size),
                            ylims=(-gas_size, gas_size),
                        )
    pl_dm_x_y = scatter(dm_x, dm_y, 
                        title="Dark matter - XY plane", 
                        xlabel="x / $unit",
                        ylabel="y / $unit",
                        markercolor=:darkgrey,
                        background_color_inside=:black,
                        xlims=(-dm_size, dm_size),
                        ylims=(-dm_size, dm_size),
                    )
    pl_stars_x_y = scatter( stars_x, stars_y, 
                            title="Stars - XY plane", 
                            xlabel="x / $unit",
                            ylabel="y / $unit",
                            markercolor=:darkorange2,
                            background_color_inside=:black,
                            xlims=(-stars_size, stars_size),
                            ylims=(-stars_size, stars_size),
                        )

    # Plots of the XZ plane.
    pl_gas_x_z = scatter(   gas_x, gas_z, 
                            title="Gas - XZ plane", 
                            xlabel="x / $unit",
                            ylabel="z / $unit",
                            markercolor=:blueviolet,
                            background_color_inside=:black,
                            xlims=(-gas_size, gas_size),
                            ylims=(-gas_size, gas_size),
                        )
    pl_dm_x_z = scatter(dm_x, dm_z, 
                        title="Dark matter - XZ plane", 
                        xlabel="x / $unit",
                        ylabel="z / $unit",
                        markercolor=:darkgrey,
                        background_color_inside=:black,
                        xlims=(-dm_size, dm_size),
                        ylims=(-dm_size, dm_size),
                    )
    pl_stars_x_z = scatter( stars_x, stars_z, 
                            title="Stars - XZ plane", 
                            xlabel="x / $unit",
                            ylabel="z / $unit",
                            markercolor=:darkorange2,
                            background_color_inside=:black,
                            xlims=(-stars_size, stars_size),
                            ylims=(-stars_size, stars_size),
                        )

    # Plots of the YZ plane.
    pl_gas_y_z = scatter(   gas_y, gas_z, 
                            title="Gas - YZ plane", 
                            xlabel="y / $unit",
                            ylabel="z / $unit",
                            markercolor=:blueviolet,
                            background_color_inside=:black,
                            xlims=(-gas_size, gas_size),
                            ylims=(-gas_size, gas_size),
                        )
    pl_dm_y_z = scatter(dm_y, dm_z, 
                        title="Dark matter - YZ plane", 
                        xlabel="y / $unit",
                        ylabel="z / $unit",
                        markercolor=:darkgrey,
                        background_color_inside=:black,
                        xlims=(-dm_size, dm_size),
                        ylims=(-dm_size, dm_size),
                    )
    pl_stars_y_z = scatter( stars_y, stars_z, 
                            title="Stars - YZ plane", 
                            xlabel="y / $unit",
                            ylabel="z / $unit",
                            markercolor=:darkorange2,
                            background_color_inside=:black,
                            xlims=(-stars_size, stars_size),
                            ylims=(-stars_size, stars_size),
                        )

    # Final figure containing the nine plots.
    return scatter( pl_gas_x_y, pl_gas_x_z, pl_gas_y_z,
                    pl_dm_x_y, pl_dm_x_z, pl_dm_y_z, 
                    pl_stars_x_y, pl_stars_x_z, pl_stars_y_z,
                    layout=(3, 3),
                    framestyle=:box,
                    legend=false,
                    fontfamily="Computer Modern",
                    size=(2020, 2020),
                    aspect_ratio=1,
                    markersize=2,
                    markerstrokewidth=0, 
                    titlefontsize=24,
                    xtickfontsize=20,
                    ytickfontsize=20,
                    xguidefontsize=22,
                    yguidefontsize=22
                )
end

"""
    densityMapPlot( position_data::Dict{String,Any}, 
                    mass_data::Dict{String,Any}, 
                    hsml_data::Dict{String,Any}, 
                    density_data::Dict{String,Any}; 
                    <keyword arguments>)::Plots.Plot

Make a plot of the gas density in the XY, XZ and/or YZ planes. 

The axes are in the units `position_data["unit"]`, 
with a range of ± `position_data["box_size"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `mass_data::Dict{String,Any}`: Return value of the massData function.
- `hsml_data::Dict{String,Any}`: Return value of the hsmlData function.
- `density_data::Dict{String,Any}`: Return value of the densityData function.
- `plane::String="All"`: String indicating which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `color::Symbol=:inferno`: Color scheme for the figure. 
  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap, 
  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.

# Returns
The figure outputted by Plots.jl.
"""
function densityMapPlot(position_data::Dict{String,Any}, 
                        mass_data::Dict{String,Any}, 
                        hsml_data::Dict{String,Any}, 
                        density_data::Dict{String,Any}; 
                        plane::String="All", 
                        color::Symbol=:inferno)::Plots.Plot

    # Resolution in pixels for the binning of the grid.
    resolution = 1000 
    
	if position_data["periodic"]
		# For periodic boundary conditions.
		box_limits = (position_data["box_size"] / 2) * 0.95
		map_par = mappingParameters(x_lim=[-box_limits, box_limits],
									y_lim=[-box_limits, box_limits],
									z_lim=[-box_limits, box_limits],
									boxsize=position_data["box_size"],
									Npixels=resolution)
	else
		# For vacuum boundary conditions.
		box_limits = position_data["box_size"] * 1.05
		map_par = mappingParameters(x_lim=[-box_limits, box_limits],
									y_lim=[-box_limits, box_limits],
									z_lim=[-box_limits, box_limits],
									Npixels=resolution)
    end
    
	xy_binning = range(-box_limits, stop=box_limits, length=resolution)
    color_scheme = cgrad(color)
	last_color = color_scheme[1]
	
    # Spline kernel used inside GADGET3.
    # 
    #   Monaghan, J. J., & Lattanzio, J. C. (1985). A refined particle method for 
    #   astrophysical problems. Astronomy and Astrophysics, 149(1), 135–143. 
    #   https://ui.adsabs.harvard.edu/abs/1985A&A...149..135M
    # 
    #   Springel, V. (2005). The cosmological simulation code gadget-2. Monthly Notices 
    #   of the Royal Astronomical Society, 364(4), 1105–1134. 
    #   https://doi.org/10.1111/j.1365-2966.2005.09655.x
    kernel = Cubic()

    # Makes sure that all the units are consistent.
    length_unit = position_data["unit"]
    mass_unit = mass_data["unit"]
    pos = position_data["gas"] 
    mass = mass_data["mass"]
    hsml = @. ustrip(Float64, length_unit, hsml_data["gas_hsml"] * hsml_data["unit"]) 
    ρ = @. ustrip(Float64, mass_unit / length_unit^3, density_data["gas_density"] * density_data["unit"])
	
	# Unit as a String for the axes labels.
    l_unit = uglyUnitDeserialization(length_unit)

    if plane == "XY" || plane == "All"
        sph_density = log10.(sphMapping(pos, 
                                        hsml, 
                                        mass, 
                                        ρ, ρ, 
                                        param=map_par, 
                                        kernel=kernel))

        xy_plot = plane_plot = heatmap( xy_binning, xy_binning, sph_density, 
                                        aspect_ratio=1, 
                                        ylim=(-box_limits, box_limits), 
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="x / $l_unit",
                                        ylabel="y / $l_unit",
                                        title="XY plane",
                                        fontfamily="Computer Modern", 
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme
                                    )
    end

    if plane == "XZ" || plane == "All"
        # Active rotation (alibi) of the galaxy using Euler angles.
        # Rx(-90°) Ry(0°) Rz(0°)
        pos_xz = rotate_3D(pos, -90.0, 0.0, 0.0)
        sph_density = log10.(sphMapping(pos_xz, 
                                        hsml, 
                                        mass, 
                                        ρ, ρ, 
                                        param=map_par, 
                                        kernel=kernel))

        xz_plot = plane_plot = heatmap( xy_binning, xy_binning, sph_density, 
                                        aspect_ratio=1, 
                                        ylim=(-box_limits, box_limits), 
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="x / $l_unit",
                                        ylabel="z / $l_unit",
                                        title="XZ plane",
                                        fontfamily="Computer Modern",
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme
                                    )
    end

    if plane == "YZ" || plane == "All"
        # Active rotation (alibi) of the galaxy using Euler angles.
        # Rx(-90°) Ry(0°) Rz(-90°)
        pos_yz = rotate_3D(pos, -90.0, 0.0, -90.0)
        sph_density = log10.(sphMapping(pos_yz, 
                                        hsml, 
                                        mass, 
                                        ρ, ρ, 
                                        param=map_par, 
                                        kernel=kernel))

        yz_plot = plane_plot = heatmap( xy_binning, xy_binning, sph_density, 
                                        aspect_ratio=1, 
                                        ylim=(-box_limits, box_limits), 
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="y / $l_unit",
                                        ylabel="z / $l_unit",
                                        title="YZ plane", 
                                        fontfamily="Computer Modern",
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme 
                                    )
    end
    
    if plane != "All"
        # Plot a single plane.
        return plane_plot
    else
        # Plot the three planes together.
        return heatmap( xy_plot, xz_plot, yz_plot, 
                        layout=(1, 3), 
                        size=(3000, 1000),
                        left_margin=55px,
                        top_margin=-20px,
                        bottom_margin=20px
                    )
    end  
end

"""
    starMapPlot(position_data::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make a plot of the star density in the XY, XZ and/or YZ planes. 

The axes are in the units `position_data["unit"]`, 
with a range of ± `position_data["box_size"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `plane::String="All"`: String indicating which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `color::Symbol=:inferno`: Color scheme for the figure. 
  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap, 
  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.

# Returns
The figure outputted by Plots.jl.
"""
function starMapPlot(   position_data::Dict{String,Any}; 
                        plane::String="All", 
                        region_factor::Float64=1.0,
                        color::Symbol=:inferno)::Plots.Plot

    # Get the position data.
    pos = position_data["stars"] 
    if position_data["periodic"]
		# For periodic boundary conditions.
		box_limits = (position_data["box_size"] / 2) * 0.95
	else
		# For vacuum boundary conditions.
		box_limits = position_data["box_size"] * 1.05
    end
    box_limits *= region_factor

    # Resolution in pixels for the binning of the grid.
    resolution = 1000 
    # Discretization of the plotting region.
    xy_binnig = range(-box_limits, stop=box_limits, length=resolution)

    # If there are stars.
    dataQ = !isempty(pos)
    if dataQ
        # If stars already formed.
        x, y, z = pos[:,1], pos[:,2], pos[:,3]
    else
        # If they didn't.
        x, y, z =   xy_binnig, xy_binnig, zero(rand(resolution, resolution))        
    end

    # Unit as a String for the axes labels.
    l_unit = uglyUnitDeserialization(position_data["unit"])

    color_scheme = cgrad(color)
	last_color = color_scheme[1]
	
    if plane == "XY" || plane == "All"
        if dataQ
            density_xy = xyz(ash(   x, y, 
                                    rngx=xy_binnig, 
                                    rngy=xy_binnig))
            heatmap(density_xy[1], density_xy[2], log10.(density_xy[3]))
        else
            heatmap(x, y, z)
        end
            
        xy_plot = plane_plot = heatmap!(aspect_ratio=1, 
                                        xlim=(-box_limits, box_limits), 
                                        ylim=(-box_limits, box_limits), 
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="x / $l_unit",
                                        ylabel="y / $l_unit",
                                        title="XY plane",
                                        fontfamily="Computer Modern", 
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme
                                    )
    end

    if plane == "XZ" || plane == "All"
        if dataQ
            density_xz = xyz(ash(   x, z, 
                                    rngx=xy_binnig, 
                                    rngy=xy_binnig))
            heatmap(density_xz[1], density_xz[2], log10.(density_xz[3]))
        else
            heatmap(x, y, z)
        end
            
        xz_plot = plane_plot = heatmap!(aspect_ratio=1, 
                                        xlim=(-box_limits, box_limits), 
                                        ylim=(-box_limits, box_limits), 
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="x / $l_unit",
                                        ylabel="z / $l_unit",
                                        title="XZ plane",
                                        fontfamily="Computer Modern",
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme
                                    )
    end

    if plane == "YZ" || plane == "All"
        if dataQ
            density_yz = xyz(ash(   y, z, 
                                    rngx=xy_binnig, 
                                    rngy=xy_binnig))
            heatmap(density_yz[1], density_yz[2], log10.(density_yz[3]))
        else
            heatmap(x, y, z)
        end
            
        yz_plot = plane_plot = heatmap!(aspect_ratio=1, 
                                        xlim=(-box_limits, box_limits), 
                                        ylim=(-box_limits, box_limits),  
                                        size=(1040, 1040),
                                        right_margin=25px,
                                        framestyle=:box,
                                        xlabel="y / $l_unit",
                                        ylabel="z / $l_unit",
                                        title="YZ plane", 
                                        fontfamily="Computer Modern",
                                        xtickfontsize=30,
                                        ytickfontsize=30,
                                        xguidefontsize=35,
                                        yguidefontsize=35,
                                        titlefont=35,
                                        colorbar=false,
                                        background_color_inside=last_color,
                                        c=color_scheme 
                                    )
    end
    
    if plane != "All"
        # Plot a single plane.
        return plane_plot
    else
        # Plot the three planes together.
        return heatmap( xy_plot, xz_plot, yz_plot, 
                        layout=(1, 3), 
                        size=(3000, 1000),
                        left_margin=55px,
                        top_margin=-20px,
                        bottom_margin=20px
                    )
    end  
end

"""
    gasStarEvolutionPlot(   time_series::Dict{String,Any}, 
                            position_data::Dict{String,Any}, 
                            index::Int64)::Plots.Plot

Makes 3 plots (in a single figure with a 1x2 layout) of the position of the particles 
in the XY plane, the baryonic fractional mass and the SFR. The first two for stars and gas.

The figure is created with the time running from 0 to `time_series["clock_time"][index]`.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.	
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `index::Int64`: Index of the final time step up to which the figure will show the 
  evolution of the variables.
	
# Returns
- The figure outputted by Plots.jl.
"""
function gasStarEvolutionPlot(  time_series::Dict{String,Any}, 
                                position_data::Dict{String,Any}, 
                                index::Int64)::Plots.Plot

    # Unit formatting for the axes labels.
    time_unit = uglyUnitDeserialization(time_series["units"]["time"])
    sfr_unit = uglyUnitDeserialization(time_series["units"]["sfr"])

    sfr_unit = replace(replace(sfr_unit, "M⊙" => "\\left(\\textrm{M}_{\\odot} \\, \\textrm{"), "^-1" => "}^{-1}\\right)")
    length_unit = uglyUnitDeserialization(position_data["unit"])
    
	if position_data["periodic"]
		# For periodic boundary conditions.
		size = (position_data["box_size"] / 2) * 0.95
	else
		# For vacuum boundary conditions.
		size = position_data["box_size"] * 5.5
	end

    # Raw data.
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    gas_bar_frac = time_series["gas_bar_frac"]
    star_bar_frac = time_series["star_bar_frac"]

    gas_pos = position_data["gas"]
    stars_pos = position_data["stars"] 

    # Trimmed data for the animation.
    reduced_time = t[1:index]
    reduced_sfr = sfr[1:index]
    reduced_gas = gas_bar_frac[1:index]
    reduced_stars = star_bar_frac[1:index]

    baryonic_frac = [reduced_gas reduced_stars]
    
	clock = round(reduced_time[end], digits=2)  # Data for the time stamp.
    t_end = ceil(t[end]) * 1.025                # Upper limit for time axis labes.
    sfr_end = ceil(maximum(sfr)) * 1.05         # Upper limit for SFR axis labels.
    
    # Separation in x and y components to manage the case of no particles.
    if isempty(gas_pos)
        # In the case that there are no gas particles.
        gas_x = []
        gas_y = []
    else
        gas_x = gas_pos[:,1]
        gas_y = gas_pos[:,2]
    end

    if isempty(stars_pos)
        # In the case that there are no star particles.
        stars_x = []
        stars_y = []
    else
        stars_x = stars_pos[:,1]
        stars_y = stars_pos[:,2]
    end
    
    # Fractional baryonic mass plot.
    pl_frac = plot( reduced_time, baryonic_frac,
                    xlabel="t / $time_unit",
                    ylabel="Fractional baryonic mass",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    lw=4,
                    xlims=(-t_end * 0.025, t_end),
                    ylims=(-0.05, 1.05),
                    left_margin=100px,
                    bottom_margin=15px,
                    background_color_legend=nothing,
                    foreground_color_legend=nothing
                )
    
    # Star formation rate plot.
    pl_sfr = plot(  reduced_time, reduced_sfr,
                    xlabel="t / $time_unit",
                    ylabel=L"\textrm{SFR} \ / \, %$sfr_unit",
                    legend=false,
                    lw=4,
                    c=:darkorange2,
                    xlims=(-t_end * 0.025, t_end),
                    ylims=(-sfr_end * 0.05, sfr_end),
                    left_margin=100px,
                    top_margin=15px
                )

    # Scatter plot of gas and stars in the XY plane.
    scatter(gas_x, gas_y, 
            xlabel="x / $length_unit",
            ylabel="y / $length_unit",
            background_color_inside=:black,
            markercolor=:blueviolet,
            background_color_legend=:black,
            label="Gas", 
            legend=:bottomright,
            markersize=2,
            markerstrokewidth=0,
            xlims=(-size, size),
            ylims=(-size, size),
            aspect_ratio=1   
        )

    pl_galaxy_pos = scatter!(   stars_x, stars_y, 
                                markercolor=:darkorange2,
                                legendfontcolor=:white,
                                background_color_legend=:black,
                                foreground_color_legend=nothing,      
                                label="Stars", 
                                legend=:bottomright,
                                markersize=2,
                                markerstrokewidth=0
                            )

    annotate!(  pl_galaxy_pos, 
                relative(pl_galaxy_pos, 0.5, 0.95)..., 
                Plots.text("$clock $time_unit", "Courier", 25, :white, :center))

    l = @layout [a{0.5w} grid(2, 1)]

    # Final figure containing the three plots.
    return plot(pl_galaxy_pos, pl_frac, pl_sfr,
				layout=l,
                framestyle=:box,
                size=(2200, 1100),
                left_margin=30px,
                right_margin=30px,
                bottom_margin=40px,
                fontfamily="Computer Modern",
				xtickfontsize=22,
				ytickfontsize=22,
				xguidefontsize=25,
				yguidefontsize=25,
                legendfontsize=25                    
    )
end

"""
    timeSeriesPlot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. 

All the plots show the evolution of the corresponding parameter versus time.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, e.g. if mass_factor = 10 => the 
  corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 => the corresponding axis will be scaled by 10^4.

# Returns
- The figure outputted by Plots.jl.
"""
function timeSeriesPlot(time_series::Dict{String,Any}; 
                        mass_factor::Int64=0, 
                        number_factor::Int64=0)::Plots.Plot
    
    pgfplotsx()

    # Unit formatting for the axes labels.
    mass_unit = uglyUnitDeserialization(time_series["units"]["mass"])
    time_unit = uglyUnitDeserialization(time_series["units"]["time"])
    sfr_unit = uglyUnitDeserialization(time_series["units"]["sfr"])

    if mass_factor != 0
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)")
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    sfr_unit = replace(replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles "
    if number_factor != 0
        ylabel_num *= L"\, / \ 10^{%$number_factor}"
    end

    # Data to be plotted.
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]

    pl_number = plot(   t, number,
                        xlabel="t / $(time_unit)",
                        ylabel=ylabel_num,
                        label=["Gas" "Stars"],
                        c=[:blueviolet :darkorange2],
                        linestyle=[:solid  :dash],
                        legend=:bottomright,
                        foreground_color_legend=nothing,
                        background_color_legend=nothing,
                        ticklabel_shift=".1cm",
                        extra_kwargs=:subplot
                    )

    pl_mass = plot( t, mass,
                    xlabel="t / $(time_unit)",
                    ylabel=L"Total mass %$mass_unit",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_frac = plot( t, baryonic_frac, 
                    xlabel="t / $(time_unit)",
                    ylabel="Fractional baryonic mass",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_sfr = plot(  t, sfr,
                    xlabel="t / $(time_unit)",
                    ylabel=L"SFR %$sfr_unit",
                    legend=false,
                    linecolor=:darkorange2,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    # Final figure containing the four plots.
    return plot(pl_number,pl_mass,
                pl_frac,pl_sfr,
                layout=(2, 2),
                left_margin=130px,
                top_margin=35px,
                framestyle=:box,
                size=(2000, 1200),
                lw=4,
                xtickfontsize=22,
                ytickfontsize=22,
                xguidefontsize=25,
                yguidefontsize=25,
                legendfontsize=30
    )
end

"""
    scaleFactorSeriesPlot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars.

All the plots show the evolution of the corresponding parameter versus the scale factor.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, e.g. if mass_factor = 10 => the 
  corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 => the corresponding axis will be scaled by 10^4.

# Returns
- The figure outputted by Plots.jl.
"""
function scaleFactorSeriesPlot( time_series::Dict{String,Any}; 
                                mass_factor::Int64=0, 
                                number_factor::Int64=0)::Plots.Plot

    pgfplotsx()

    # Unit formatting for the axes labels.
    mass_unit = uglyUnitDeserialization(time_series["units"]["mass"])
    sfr_unit = uglyUnitDeserialization(time_series["units"]["sfr"])

    if mass_factor != 0
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)")
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    sfr_unit = replace(replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles "
    if number_factor != 0
        ylabel_num *= L"\, / \ 10^{%$number_factor}"
    end
  
    # Data to be plotted.
    a = time_series["scale_factor"]  
    sfr = time_series["sfr"]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]

    pl_number = plot(   a, number,
                        xlabel="Scale factor",
                        ylabel=ylabel_num,
                        label=["Gas" "Stars"],
                        c=[:blueviolet :darkorange2],
                        linestyle=[:solid  :dash],
                        legend=:bottomright,
                        foreground_color_legend=nothing,
                        background_color_legend=nothing,
                        ticklabel_shift=".1cm",
                        extra_kwargs=:subplot
                    )

    pl_mass = plot( a, mass,
                    xlabel="Scale factor",
                    ylabel=L"Total mass %$mass_unit",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_frac = plot( a, baryonic_frac, 
                    xlabel="Scale factor",
                    ylabel="Fractional baryonic mass",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_sfr = plot(  a, sfr,
                    xlabel="Scale factor",
                    ylabel=L"SFR %$sfr_unit",
                    legend=false,
                    linecolor=:darkorange2,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    # Final figure containing the four plots.
    return plot(pl_number,pl_mass,
                pl_frac,pl_sfr,
                layout=(2, 2),
                left_margin=130px,
                top_margin=35px,
                framestyle=:box,
                size=(2000, 1200),
                lw=4,
                xtickfontsize=22,
                ytickfontsize=22,
                xguidefontsize=25,
                yguidefontsize=25,
                legendfontsize=30
    )
end

"""
    redshiftSeriesPlot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. 

All the plots show the evolution of the corresponding parameter versus the redshift.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, e.g. if mass_factor = 10 the 
corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 the corresponding axis will be scaled by 10^4.

# Returns
- The figure outputted by Plots.jl.
"""
function redshiftSeriesPlot(time_series::Dict{String,Any}; 
                            mass_factor::Int64=0, 
                            number_factor::Int64=0)::Plots.Plot

    pgfplotsx()

    # Unit formatting for the axes labels.
    mass_unit = uglyUnitDeserialization(time_series["units"]["mass"])
    sfr_unit = uglyUnitDeserialization(time_series["units"]["sfr"])

    if mass_factor != 0
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)")
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    sfr_unit = replace(replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles "
    if number_factor != 0
        ylabel_num *= L"\, / \ 10^{%$number_factor}"
    end
  
    # Data to be plotted.
    z = time_series["redshift"]  
    sfr = time_series["sfr"]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]

    pl_number = plot(   z, number,
                        xlabel="Redshift",
                        ylabel=ylabel_num,
                        label=["Gas" "Stars"],
                        c=[:blueviolet :darkorange2],
                        linestyle=[:solid  :dash],
                        legend=:bottomright,
                        foreground_color_legend=nothing,
                        background_color_legend=nothing,
                        ticklabel_shift=".1cm",
                        extra_kwargs=:subplot
                    )

    pl_mass = plot( z, mass,
                    xlabel="Redshift",
                    ylabel=L"Total mass %$mass_unit",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_frac = plot( z, baryonic_frac, 
                    xlabel="Redshift",
                    ylabel="Fractional baryonic mass",
                    label=["Gas" "Stars"],
                    c=[:blueviolet :darkorange2],
                    linestyle=[:solid  :dash],
                    legend=:bottomright,
                    foreground_color_legend=nothing,
                    background_color_legend=nothing,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    pl_sfr = plot(  z, sfr,
                    xlabel="Redshift",
                    ylabel=L"SFR %$sfr_unit",
                    legend=false,
                    linecolor=:darkorange2,
                    ticklabel_shift=".1cm",
                    extra_kwargs=:subplot
                )

    # Final figure containing the four plots.
    return plot(pl_number,pl_mass,
                pl_frac,pl_sfr,
                layout=(2, 2),
                left_margin=130px,
                top_margin=35px,
                framestyle=:box,
                size=(2000, 1200),
                lw=4,
                xtickfontsize=22,
                ytickfontsize=22,
                xguidefontsize=25,
                yguidefontsize=25,
                legendfontsize=30
    )
end

"""
    compareSimulationsPlot( x_quantity::String, 
                            y_quantity::String, 
                            labels::Array{String,2}, 
                            data::Tuple{Vararg{Dict{String,Any}}}; 
                            <keyword arguments>)::Plots.Plot

Make a plot comparing `y_quantity` vs. `x_quantity` for several simulations.

The data of each simulation must be in the same units and `x_quantity` and `y_quantity` 
can be any magnitude used in the timeSeriesData function, namely:
- "scale_factor"                  
- "redshift"                  
- "clock_time" (Real time)
- "sfr" (SFR) 			              
- "sfr_prob" (SFR probability - Not normalized) 			           
- "gas_number" (Gas particle number) 	            
- "dm_number" (Dark matter particle number)		               
- "star_number" (Star number)         
- "gas_mass" (Total gas mass)               
- "dm_mass" (Total dark matter mass)	            
- "star_mass" (Total star mass)		               
- "gas_frac" (Gas fraction)		                
- "dm_frac" (Dark matter fraction)		                
- "star_frac" (Stars fraction)	                   
- "gas_bar_frac" (Baryonic gas fraction)                  
- "star_bar_frac" (Baryonic star fraction)

# Arguments
- `x_quantity::String`: String indicating the physical magnitude for the x axis. 
- `y_quantity::String`: String indicating the physical magnitude for the y axis.
- `labels::Array{String,2}`: Labels for the different simulations, e.g. [label1 label2 ...].
- `data::Tuple{Vararg{Dict{String,Any}}}`: Return value of the timeSeriesData function for 
  every simulation, as a Tuple, e.g. (data_sim1, data_sim2).
- `title::String=""`: Title for the figure. If an empty string is given
  no title is printed, which is the default.
- `x_factor::Int64=0`: Numerical exponent to scale the `x_quantity`, e.g. if x_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `y_factor::Int64=0`: Numerical exponent to scale the `y_quantity`, e.g. if y_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `log_scale::Bool=false`: If true, the y axis will be logarithmic, and every value <= 0 
  in the y data dropped. If false (the default) a linear scale is used and all data is plotted.
- `smooth_data::Bool=false`: If true a smoothing window with no weighs is applied to the y data. 
  If false (the default) no transformation occurs.

# Returns
- The figure outputted by Plots.jl.
"""
function compareSimulationsPlot(x_quantity::String, 
                                y_quantity::String, 
                                labels::Array{String,2},
                                data::Tuple{Vararg{Dict{String,Any}}};
                                title::String="", 
                                x_factor::Int64=0, 
                                y_factor::Int64=0, 
                                log_scale::Bool=false, 
                                smooth_data::Bool=false)::Plots.Plot

    pgfplotsx()

    # Extract data and scale it by 10^factor.
    x_data = collect(get.(data, x_quantity, 0)) ./ 10^x_factor
    y_data = collect(get.(data, y_quantity, 0)) ./ 10^y_factor

    # Is required, smooth the y data with a moving window.
    if smooth_data
        for (i, (x, y)) in enumerate(zip(x_data, y_data))
            x_data[i], y_data[i] = smoothWindow(x, y, 50)
        end
    end

    # If require set a logarithmic scale to the y axis.
    yscale = :identity
    if log_scale
        y_data = replace.(x -> x <= 0 ? NaN64 : x, y_data)
        yscale = :log10
    end

    # Labels for the axes.
    ylabel = data[1]["labels"][y_quantity]
    xlabel = data[1]["labels"][x_quantity]

    # Unit formatting for the x axis.
    if x_quantity == "clock_time"
        unit = uglyUnitDeserialization(data[1]["units"]["time"])
		
		if x_factor != 0   		
			xlabel *= L"\ / \, \left(10^{%$x_factor} \, \mathrm{%$unit}\right)"
        else
            xlabel *= " / $unit"
        end
    elseif x_quantity == "sfr"
        unit = uglyUnitDeserialization(data[1]["units"]["sfr"])
            
        if x_factor != 0
            xlabel *= replace(replace(unit, "M⊙" => L"$\ / \, \left(10^{%$x_factor} \, \mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")
        else
            xlabel *= replace(replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")
        end
    elseif x_quantity == "gas_mass" || x_quantity == "dm_mass" || x_quantity == "star_mass"
        unit = uglyUnitDeserialization(data[1]["units"]["mass"])
            
        if x_factor != 0
            xlabel *= replace(unit, "M⊙" => L"\ / \, \left(10^{%$x_factor} \, \mathrm{M}_{\odot}\right)")
        else
            xlabel *= replace(unit, "M⊙" => L"\ / \, \left(\mathrm{M}_{\odot}\right)")
        end
    elseif x_factor != 0
        xlabel *= L"\ / \, 10^{%$x_factor}"
    end
	
	# Unit formatting for the y axis.
    if y_quantity == "clock_time"
        unit = uglyUnitDeserialization(data[1]["units"]["time"])
		
		if y_factor != 0   		
			ylabel *= L"\ / \, \left(10^{%$y_factor} \, \mathrm{%$unit}\right)"
        else
            ylabel *= " / $unit"
        end
    elseif y_quantity == "sfr"
        unit = uglyUnitDeserialization(data[1]["units"]["sfr"])
            
        if y_factor != 0
            ylabel *= replace(replace(unit, "M⊙" => L"$\ / \, \left(10^{%$y_factor} \, \mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")
        else
            ylabel *= replace(replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")
        end
    elseif y_quantity == "gas_mass" || y_quantity == "dm_mass" || y_quantity == "star_mass"
        unit = uglyUnitDeserialization(data[1]["units"]["mass"])
            
        if y_factor != 0
            ylabel *= replace(unit, "M⊙" => L"\ / \, \left(10^{%$y_factor} \, \mathrm{M}_{\odot}\right)")
        else
            ylabel *= replace(unit, "M⊙" => L"\ / \, \left(\mathrm{M}_{\odot}\right)")
        end
    elseif y_factor != 0
        ylabel *= L"\ / \, 10^{%$y_factor}"
    end

    # Final figure.
    return plot(hcat(x_data...), hcat(y_data...),
                xlabel=xlabel,
                ylabel=ylabel,
                yscale=yscale,
				title=title,
                label=labels,
                legend=:bottomright,
                palette=:Set1_9,
                framestyle=:box,
                size=(1200, 700),
                lw=4,
                linestyle=:auto,
				titlefontsize=28,
                xtickfontsize=22,
                ytickfontsize=22,
                xguidefontsize=24,
                yguidefontsize=24,
                legendfontsize=25,
                foreground_color_legend=nothing,
                background_color_legend=nothing,
                ticklabel_shift=".1cm",
                extra_kwargs=:subplot
    )
end

"""
    densityHistogramPlot(   density_data::Dict{String,Any}, 
                            time::Unitful.Quantity; 
                            <keyword arguments>)::Plots.Plot

Make an histogram of the densities of the gas particles.

# Arguments
- `density_data::Dict{String,Any}`: Return value of the densityData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `factor::Int64=0`: Numerical exponent to scale `density_data`, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3`: Unit of density 
  to be used in the output, all available density units in Unitful and UnitfulAstro can 
  be used, e.g. UnitfulAstro.Msun / UnitfulAstro.kpc^3, which is the default.
	
# Returns
- The figure outputted by Plots.jl.
"""
function densityHistogramPlot(  density_data::Dict{String,Any},
                                time::Unitful.Quantity;
                                factor::Int64=0,
                                density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3)::Plots.Plot
    
    pgfplotsx()

    # Set correct units.
    ρ = @. ustrip(Float64, density_unit, density_data["gas_density"] * density_data["unit"])
    # Scale data by 10^{factor}.
    ρ ./= 10^factor

    # Unit formatting for the x axis label.
    str_unit = uglyUnitDeserialization(density_unit)
    xlabel = L"\rho \ / \,"
    if factor != 0
        xlabel *= replace(replace(str_unit, "M⊙" => L"$\left(10^{%$factor} \, \mathrm{M_{\odot} \,"), "^-3" => L"^{-3}}\right)$")
    else
        xlabel *= replace(replace(str_unit, "M⊙" => L"$\left(\mathrm{M_{\odot} \,"), "^-3" => L"^{-3}}\right)$")
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), digits=2)
    time_unit = uglyUnitDeserialization(unit(time))

    # Final figure.
    return histogram(   ρ, 
                        nbins=range(0, stop=maximum(ρ), length=20),
                        framestyle=:box,
                        xlabel=xlabel,
                        size=(1000, 800),
                        normalize=:probability,
                        legend=false,
                        xtickfontsize=28,
                        ytickfontsize=28,
                        xguidefontsize=30,
                        yguidefontsize=30,
                        ticklabel_shift=".1cm",
                        add="\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
                        extra_kwargs=:subplot
    )
end

"""
    densityProfilePlot( position_data::Dict{String,Any}, 
                        mass_data::Dict{String,Any}, 
                        time::Unitful.Quantity; 
                        <keyword arguments>)::Plots.Plot

Make a density profile plot for a given time step.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `mass_data::Dict{String,Any}`: Return value of the massData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64=100`: Number of subdivisions of the region to be used for the profile. 
  The default is 100.
- `factor::Int64=0`: Numerical exponent to scale the `density_data`, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.
- `density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3`: Unit of density 
  to be used in the output, all available density units in Unitful and UnitfulAstro can 
  be used, e.g. UnitfulAstro.Msun / UnitfulAstro.kpc^3, which is the default.

# Returns
- The figure outputted by Plots.jl.
"""
function densityProfilePlot(position_data::Dict{String,Any},
                            mass_data::Dict{String,Any}, 
                            time::Unitful.Quantity;
                            bins::Int64=100,
                            factor::Int64=0,
                            region_factor::Float64=1.0,
                            density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3)::Plots.Plot

    pgfplotsx()

    type = mass_data["type"]
    masses = mass_data["mass"]
    mass_unit = uglyUnitDeserialization(mass_data["unit"])

    positions = position_data[type]
    length_unit = position_data["unit"]

    if isempty(positions)
        # In the case that there are no particles.
        distances = [Inf]
    else
        distances = sqrt.(positions[:,1].^2 .+ positions[:,2].^2 .+  positions[:,3].^2)
    end
    
	if position_data["periodic"]
		# For periodic boundary conditions.
		r_max = (position_data["box_size"] / 2) * region_factor
	else
        # Plotting region for vacuum boundary conditions.
        r_max = position_data["box_size"] * region_factor
	end

    r, ρ = densityProfile(masses, distances, r_max, bins)
    ρ ./= 10^factor

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), digits=2)
    time_unit = uglyUnitDeserialization(unit(time))

    # Unit formatting for the y axis label.
    ylabel = L"\rho \ / \,"
    if factor != 0
        ylabel *= replace(mass_unit, "M⊙" => L"$\left(10^{%$factor} \, \mathrm{M_{\odot} \, %$length_unit^{-3}}\right)$")
    else
        ylabel *= replace(mass_unit, "M⊙" => L"$\left(\mathrm{M_{\odot} \, %$length_unit^{-3}}\right)$")
    end

    # Unit as a String for the x axis label.
    x_unit = uglyUnitDeserialization(length_unit)

    # Final figure.
    return plot(r, ρ, 
                xlabel="r / $x_unit",
                ylabel=ylabel,
                framestyle=:box,
                size=(1200, 800),
                legend=false,
                lw=3,
                color=:red,
                xtickfontsize=28,
                ytickfontsize=28,
                xguidefontsize=30,
                yguidefontsize=30,
                ticklabel_shift=".1cm",
                add="\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
                extra_kwargs=:subplot
    )
end

"""
    metallicityProfilePlot( position_data::Dict{String,Any}, 
                            mass_data::Dict{String,Any}, 
                            z_data::Dict{String,Any}, 
                            time::Unitful.Quantity; 
                            <keyword arguments>)::Plots.Plot

Make a metallicity profile plot for a given time step.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `mass_data::Dict{String,Any}`: Return value of the massData function.
- `z_data::Dict{String,Any}`: Return value of the zData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64=100`: Number of subdivisions of the region to be used for the profile. 
  The default is 100.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The figure outputted by Plots.jl.
"""
function metallicityProfilePlot(position_data::Dict{String,Any},
                                mass_data::Dict{String,Any}, 
                                z_data::Dict{String,Any},
                                time::Unitful.Quantity;
                                bins::Union{Int64,Nothing}=100,
                                region_factor::Float64=1.0)::Plots.Plot

    pgfplotsx()

    type = mass_data["type"]
    masses = mass_data["mass"]
    metallicity = z_data["Z"]

    mass_unit = uglyUnitDeserialization(mass_data["unit"])
    z_unit = uglyUnitDeserialization(z_data["unit"])
    if mass_unit != z_unit
        error("The mass units '$mass_unit' should be the same as the metallicity units '$z_unit'")
    end

    positions = position_data[type]
    length_unit = position_data["unit"]

    if isempty(positions)
        # In the case that there are no particles.
        distances = [Inf]
    else
        distances = sqrt.(positions[:,1].^2 .+ positions[:,2].^2 .+  positions[:,3].^2)
    end
	  
    if position_data["periodic"]
		# For periodic boundary conditions.
		r_max = (position_data["box_size"] / 2) * region_factor
	else
        # Plotting region for vacuum boundary conditions.
        r_max = position_data["box_size"] * region_factor
	end
	
    r, z = metallicityProfile(masses, distances, metallicity, r_max, bins)

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), digits=2)
    time_unit = uglyUnitDeserialization(unit(time))

    # Unit formatting for the y axis label.
    ylabel = L"\mathrm{Z} \ / \ \mathrm{Z_{\odot}}"


    # Unit as a String for the x axis label.
    x_unit = uglyUnitDeserialization(length_unit)

    # Final figure.
    return plot(r, z, 
                xlabel="r / $x_unit",
                ylabel=ylabel,
                framestyle=:box,
                size=(1200, 800),
                legend=false,
                lw=3,
                color=:red,
                xtickfontsize=28,
                ytickfontsize=28,
                xguidefontsize=32,
                yguidefontsize=32,
                ticklabel_shift=".1cm",
                add="\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
                extra_kwargs=:subplot
            )
end


"""
    sfrTxtPlot( source_path::String, 
                snap_name::String, 
                x_axis::Int64, 
                y_axis::Array{Int64,1}; 
                <keyword arguments>)::Plots.Plot

Make a plot of column `y_axis` vs. column `x_axis` from the sfr.txt present in `source_path`, 
with consistent units.

# Arguments
- `source_path::String`: Path of the directory containing the sfr.txt file.
- `snap_name::String`: Base name of the target snapshots.
- `x_axis::Int64`: Column for the x axis.
- `y_axis::Array{Int64,1}`: Array of columns for the y axis.
- `title::String=""`: Title for the figure. If an empty string is given
  no title is printed, which is the default.
- `bins::Int64=Inf`: Number of subdivisions for the smoothing of the data. 
  The default is Inf, i.e. no smoothing.
- `scale::Array{Symbol,1}=[:identity, :identity]`: Scaling to be used for the x and y axes.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `min_filter::Array{Float64,1}=[-Inf, -Inf]`: Value filter for the x and y axes.
  If a value of the x data is lower than min_filter[1], then it is filtered away.
  Equivalently with the y axis and min_filter[2]. 
  The default is -Inf for both, i.e. no filtering.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.

# Returns
- The figure outputted by Plots.jl.
"""
function sfrTxtPlot(source_path::String, 
                    snap_name::String,
                    x_axis::Int64,
                    y_axis::Array{Int64,1};
                    title::String="",
                    bins::Int64=Inf,
                    scale::Array{Symbol,1}=[:identity, :identity],
                    min_filter::Array{Float64,1}=[-Inf, -Inf],
                    sim_cosmo::Int64=0,
                    mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun, 
                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                    sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr)::Plots.Plot

    pgfplotsx()

    # Unit formatting for the axes labels.
    str_time_unit = uglyUnitDeserialization(time_unit)
    str_mass_unit = replace(uglyUnitDeserialization(mass_unit), "M⊙" => L"\, / \mathrm{M}_{\odot}")
    str_sfr_unit = replace(replace(uglyUnitDeserialization(sfr_unit), "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"), "^-1" => L"^{-1}}\right)$")

    # Strings fot the legends.
    labels = [  "t / $str_time_unit",
                "Mass $str_mass_unit",
                "SFR $str_sfr_unit",
                "SFR $str_sfr_unit",
                "Mass $str_mass_unit",
                "SFR $str_sfr_unit"
            ]

    data = sfrTxtData(source_path, snap_name; sim_cosmo, mass_unit, time_unit, sfr_unit)
    
    # Parameter configuration of the figure.
    figure = plot(  xscale=scale[1],
                    yscale=scale[2],
                    xlabel=labels[x_axis],
                    ylabel=labels[y_axis[1]],
                    title=title,
                    legend=:bottomright,
                    palette=:Set1_9,
                    framestyle=:box,
                    size=(1200, 700),
                    titlefontsize=28,
                    xtickfontsize=22,
                    ytickfontsize=22,
                    xguidefontsize=24,
                    yguidefontsize=24,
                    legendfontsize=25
                )

    for y_type in y_axis
        x_data = data[x_axis[1]]
        y_data = data[y_type]
        
        # Data smoothing.
        if bins != Inf
            x_data, y_data = smoothWindow(x_data, y_data, bins)
        end

        # Filter data points <= 0, for logarithmic plotting.
        if scale[1] == :log10 
            deleteat!(y_data, x_data .<= 0)
            filter!(x -> x >  0, x_data)
        end
            
        if scale[2] == :log10
            deleteat!(x_data, y_data .<= 0)
            filter!(x -> x >  0, y_data)
        end

        # Filter data points < `min_filter`.
        deleteat!(y_data, x_data .< min_filter[1])
        filter!(x -> x > min_filter[1], x_data)
            
        deleteat!(x_data, y_data .< min_filter[2])
        filter!(x -> x > min_filter[2], y_data)
            
        plot!(  figure, x_data, y_data, 
                label="Column $y_type", 
                lw=3, 
                foreground_color_legend=nothing,
                background_color_legend=nothing,
                ticklabel_shift=".1cm",
                extra_kwargs=:subplot
            )
    end

    return figure
end

########################################################################################
# PIPELINE FUNCTIONS.
########################################################################################

"""
    scatterGridPipeline(snap_name::String, 
                        source_path::String, 
                        base_output_path::String, 
                        anim_name::String, 
                        frame_rate::Int64; 
                        <keyword arguments>)::Nothing

Save the results of the scatterGridPlot function as one image per snapshot, 
and then generate a GIF and video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`scatter_grid/image/ and will be named
  `snap_name`_XXX`format` where XXX is the number of the snapshot. The GIF and the 
  video will be stored in `base_output_path`scatter_grid/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by GR 
  can be used, namely ".pdf", ".ps", ".svg" and ".png", which is the default. 
"""
function scatterGridPipeline(   snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                anim_name::String, 
                                frame_rate::Int64;
                                step::Int64=1,
                                sim_cosmo::Int64=0,
                                length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                                region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                                format::String=".png")::Nothing
    
    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "scatter_grid/images/")
    
    # Generate and store the plots.
    animation = @animate for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        positions = positionData(   snapshot, 
                                    sim_cosmo=sim_cosmo, 
                                    length_unit=length_unit, 
                                    box_size=region_size
                                )
            
        figure = scatterGridPlot(positions)
        savefig(figure, base_output_path * "scatter_grid/images/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    gif(animation, 
        base_output_path * "scatter_grid/" * anim_name * ".gif", 
        fps=frame_rate
    )

    # Make de video.
    makeVideo(  base_output_path * "scatter_grid/images/", 
                format, 
                base_output_path * "scatter_grid/", 
                anim_name, 
                frame_rate
            )

    return nothing
end

"""
    densityMapPipeline( snap_name::String, 
                        source_path::String, 
                        base_output_path::String, 
                        anim_name::String, 
                        frame_rate::Int64; 
                        <keyword arguments>)::Nothing

Save the results of the densityMapPlot function as one image per snapshot, 
and then generate a GIF and a video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`density_map/images/ and will be named
  `snap_name`_XXX`format` where XXX is the number of the snapshot. The GIF and the 
  video will be stored in `base_output_path`density_map/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `plane::String="All"`: Indicates which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by GR 
  can be used, namely ".pdf", ".ps", ".svg" and ".png", which is the default. 
"""
function densityMapPipeline(snap_name::String, 
                            source_path::String, 
                            base_output_path::String, 
                            anim_name::String, 
                            frame_rate::Int64;
                            plane::String="All",
                            step::Int64=1,
                            sim_cosmo::Int64=0,
                            length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                            region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                            format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "density_map/images/")

    # Generate and store the plots.
    animation = @animate for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        pos = positionData( snapshot, 
                            sim_cosmo=sim_cosmo, 
                            length_unit=length_unit, 
                            box_size=region_size
                        )
        mass = massData(snapshot, "gas", sim_cosmo=sim_cosmo)
        density = densityData(snapshot; sim_cosmo=sim_cosmo)
        hsml = hsmlData(snapshot; sim_cosmo=sim_cosmo)
            
        figure = densityMapPlot(pos, mass, hsml, density, plane=plane)
        savefig(figure, base_output_path * "density_map/images/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    gif(animation, 
        base_output_path * "density_map/" * anim_name * ".gif", 
        fps=frame_rate
    )

    # Make de video.
    makeVideo(  base_output_path * "density_map/images/", 
                format, 
                base_output_path * "density_map/", 
                anim_name, 
                frame_rate
            )

    return nothing
end

"""
    starMapPipeline(snap_name::String, 
                    source_path::String, 
                    base_output_path::String, 
                    anim_name::String, 
                    frame_rate::Int64; 
                    <keyword arguments>)::Nothing

Save the results of the starMapPlot function as one image per snapshot, 
and then generate a GIF and a video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`star_map/images/ and will be named
  `snap_name`_XXX`format` where XXX is the number of the snapshot. The GIF and the 
  video will be stored in `base_output_path`star_map/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `plane::String="All"`: Indicates which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by GR 
  can be used, namely ".pdf", ".ps", ".svg" and ".png", which is the default. 
"""
function starMapPipeline(   snap_name::String, 
                            source_path::String, 
                            base_output_path::String, 
                            anim_name::String, 
                            frame_rate::Int64;
                            plane::String="All",
                            step::Int64=1,
                            region_factor::Float64=1.0,
                            sim_cosmo::Int64=0,
                            length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                            region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                            format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "star_map/images/")

    # Generate and store the plots.
    animation = @animate for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        pos = positionData( snapshot, 
                            sim_cosmo=sim_cosmo, 
                            length_unit=length_unit, 
                            box_size=region_size
                        )
            
        figure = starMapPlot(pos; plane, region_factor)
        savefig(figure, base_output_path * "star_map/images/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    gif(animation, 
        base_output_path * "star_map/" * anim_name * ".gif", 
        fps=frame_rate
    )

    # Make de video.
    makeVideo(  base_output_path * "star_map/images/", 
                format, 
                base_output_path * "star_map/", 
                anim_name, 
                frame_rate
            )

    return nothing
end

"""
    gasStarEvolutionPipeline(   snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                anim_name::String, 
                                frame_rate::Int64; 
                                <keyword arguments>)::Nothing

Save the results of the gasStarEvolutionPlot for the last snapshot as one image and 
generate a GIF and a video animating the whole evolution from all snapshots. 
                                
# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figure and animations.
  The image will be stored in `base_output_path`gas_star_evolution/ and will be named
  `snap_name`_XXX`format` where XXX is the number of the last snapshot. The GIF and the 
  video will be stored in `base_output_path`gas_star_evolution/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by GR 
  can be used, namely ".pdf", ".ps", ".svg" and ".png", which is the default. 
"""
function gasStarEvolutionPipeline(  snap_name::String, 
                                    source_path::String, 
                                    base_output_path::String, 
                                    anim_name::String, 
                                    frame_rate::Int64;
                                    step::Int64=1,
                                    sim_cosmo::Int64=0,
                                    length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                                    sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr,
                                    region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                                    format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "gas_star_evolution/TEMP/")

    time_series = timeSeriesData(   sim_files, 
                                    sim_cosmo=sim_cosmo,
                                    mass_unit=UnitfulAstro.Msun, 
                                    time_unit=time_unit, 
                                    sfr_unit=sfr_unit
                                )

    # Generate and store the plots.                        
    animation = @animate for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        positions = positionData(   snapshot, 
                                    sim_cosmo=sim_cosmo, 
                                    length_unit=length_unit, 
                                    box_size=region_size
                                )
        figure = gasStarEvolutionPlot(time_series, positions, i)
        savefig(figure, base_output_path * "gas_star_evolution/TEMP/" * snap_name * "_" * snap_numbers[i] * format)
    end  

    # Make the GIF.
    gif(animation, 
        base_output_path * "gas_star_evolution/" * anim_name * ".gif", 
        fps=frame_rate
    )

    # Make de video.
    makeVideo(  base_output_path * "gas_star_evolution/TEMP/", 
                format,
                base_output_path * "gas_star_evolution/", 
                anim_name, 
                frame_rate
            )

    # Move the last figure out of the temporary directory, for safekeeping.
    mv( base_output_path * "gas_star_evolution/TEMP/" * snap_name * "_" * snap_numbers[end] * format, 
        base_output_path * "gas_star_evolution/" * anim_name * format, 
        force=true
    )

    # Delete the temporary directory and all its contents.
    rm(base_output_path * "gas_star_evolution/TEMP/", recursive=true)

    return nothing
end

"""
    evolutionSummaryPipeline(   snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                fig_name::String; 
                                <keyword arguments>)::Nothing

Produce up to three figures summarizing the time evolution of the simulation.

The plotted parameters are the number of particles, the total mass, the baryonic 
fractional mass and the star formation rate (SFR), the first three for gas and stars.
If the simulation is Newtonian, only one figure is produced (parameters vs. time),
but if the simulation is cosmological three figures are produced (parameters vs. time,
parameters vs. scale factor and parameters vs. redshift).

Args:
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`evolution_summary/.
- `fig_name::String`: Base name for the figures. The images will be named
  `fig_name`_vs_XXX`format` where XXX is time, redshift or scale_factor.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, e.g. if mass_factor = 10 the 
  corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 the corresponding axis will be scaled by 10^4.
- `format::String=".png"`: File format of the output figure. All formats supported by pgfplotsx 
  can be used, namely ".pdf", ".tex", ".svg" and ".png", which is the default. 
"""
function evolutionSummaryPipeline(  snap_name::String, 
                                    source_path::String, 
                                    base_output_path::String, 
                                    fig_name::String;
                                    sim_cosmo::Int64=0,
                                    mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun,
                                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                                    sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr,
                                    mass_factor::Int64=0, 
                                    number_factor::Int64=0,
                                    format::String=".png")::Nothing

    sim_files = getSnapshots(snap_name, source_path)
    time_series = timeSeriesData(   sim_files["snap_files"], 
                                    sim_cosmo=sim_cosmo,
                                    mass_unit=mass_unit, 
                                    time_unit=time_unit, 
                                    sfr_unit=sfr_unit
                                )

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "evolution_summary/")

    # Parameters vs. time. 
    figure = timeSeriesPlot(time_series, mass_factor=mass_factor, number_factor=number_factor)
    savefig(figure, base_output_path * "evolution_summary/" * fig_name * "_vs_time" * format)

    if sim_cosmo == 1
        # Parameters vs. scale factor. 
        figure = scaleFactorSeriesPlot(time_series, mass_factor=mass_factor, number_factor=number_factor)
        savefig(figure, base_output_path * "evolution_summary/" * fig_name * "_vs_scale_factor" * format)

        # Parameters vs. redshift. 
        figure = redshiftSeriesPlot(time_series, mass_factor=mass_factor, number_factor=number_factor)
        savefig(figure, base_output_path * "evolution_summary/" * fig_name * "_vs_redshift" * format)
    end

    return nothing
end

"""
    compareSimulationsPipeline( source_path::Array{String,1}, 
                                base_output_path::String, 
                                snap_name::Array{String,1}, 
                                labels::Array{String,2}, 
                                fig_name::String, 
                                x_quantity::String, 
                                y_quantity::String; 
                                <keyword arguments>)::Nothing

Make a figure comparing `y_quantity` vs. `x_quantity` for several simulations.

`x_quantity` and `y_quantity` can be any magnitude used in the timeSeriesData 
function, namely:
- "scale_factor"                  
- "redshift"                  
- "clock_time" (Real time)
- "sfr" (SFR) 			              
- "sfr_prob" (SFR probability - Not normalized) 			           
- "gas_number" (Gas particle number) 	            
- "dm_number" (Dark matter particle number)		               
- "star_number" (Star number)         
- "gas_mass" (Total gas mass)               
- "dm_mass" (Total dark matter mass)	            
- "star_mass" (Total star mass)		               
- "gas_frac" (Gas fraction)		                
- "dm_frac" (Dark matter fraction)		                
- "star_frac" (Stars fraction)	                   
- "gas_bar_frac" (Baryonic gas fraction)                  
- "star_bar_frac" (Baryonic star fraction)

# Arguments
- `source_path::Array{String,1}`: Paths where the target snapshots are located, 
  one for each simulation, e.g. [path1, path2, ...].
- `base_output_path::String`: Path of parent directory for storing the figure.
  The image will be stored in `base_output_path`compare_simulations/.
- `snap_name::Array{String,1}`: Base names of the target snapshots, e.g. [snap1, snap2, ...].
- `labels::Array{String,2}`: Labels for the different simulations, e.g. [label1 label2 ...].
- `fig_name::String`: Base name for the figure. The file will be named
  `fig_name`_`y_quantity`_vs_`x_quantity` `format`.
- `x_quantity::String`: Indicates the physical magnitude for the x axis. 
- `y_quantity::String`: Indicates the physical magnitude for the y axis.
- `log_scale::Bool=false`: If true, the y axis will be logarithmic, and every y value <= 0 
  will be dropped. If false (the default) a linear scale is used and all data is plotted.
- `smooth_data::Bool=false`: If true a smoothing window with no weighs is applied to the y data. 
  If false (the default) no transformation occurs.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun`: Unit of mass to be used in the output, 
  all available mass units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Msun, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr`: Unit of mass/time to 
  be used in the output, all available time and mass units in Unitful and UnitfulAstro 
  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr, which is the default.
- `x_factor::Int64=0`: Numerical exponent to scale the `x_quantity`, e.g. if x_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `y_factor::Int64=0`: Numerical exponent to scale the `y_quantity`, e.g. if y_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `title::String=""`: Title for the figure. If an empty string is given
  no title is printed, which is the default.
- `format::String=".png"`: File format of the output figure. All formats supported by pgfplotsx 
  can be used, namely ".pdf", ".tex", ".svg" and ".png", which is the default. 
"""
function compareSimulationsPipeline(source_path::Array{String,1},
                                    base_output_path::String,
                                    snap_name::Array{String,1}, 
                                    labels::Array{String,2},
                                    fig_name::String,
                                    x_quantity::String,
                                    y_quantity::String;
                                    log_scale::Bool=false,
                                    smooth_data::Bool=false,
                                    sim_cosmo::Int64=0,
                                    mass_unit::Unitful.FreeUnits=UnitfulAstro.Msun,
                                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr, 
                                    sfr_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.yr,
                                    x_factor::Int64=0, 
                                    y_factor::Int64=0,
                                    title::String="",
                                    format::String=".png")::Nothing

    time_series = []
    for (snap, path) in zip(snap_name, source_path)
        sim_files = getSnapshots(snap, path)
        push!(time_series, timeSeriesData(  sim_files["snap_files"], 
                                            sim_cosmo=sim_cosmo,
                                            mass_unit=mass_unit, 
                                            time_unit=time_unit, 
                                            sfr_unit=sfr_unit
                                        ))
    end

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "compare_simulations/")

    file_name = fig_name * "_" * y_quantity * "_vs_" * x_quantity * format
	
	# {y_quantity} vs. {x_quantity} plot. 
    figure = compareSimulationsPlot(x_quantity, 
                                    y_quantity, 
                                    labels,
                                    (time_series...,);
                                    x_factor, 
                                    y_factor, 
                                    title, 
                                    log_scale,
                                    smooth_data)
    savefig(figure, base_output_path * "compare_simulations/" * file_name)

    return nothing
end

"""
    densityHistogramPipeline(   snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                anim_name::String, 
                                frame_rate::Int64; 
                                <keyword arguments>)::Nothing

Save the results of the densityHistogramPlot function as one image per snapshot, 
and then generate a GIF and a video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`density_histogram/images/ and will be 
  named `snap_name`_XXX`format` where XXX is the number of the snapshot. 
  The GIF and the video will be stored in `base_output_path`density_histogram/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `factor::Int64=0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3`: Unit of density 
  to be used in the output, all available density units in Unitful and UnitfulAstro can 
  be used, e.g. UnitfulAstro.Msun / UnitfulAstro.kpc^3, which is the default.
- `format::String=".png"`: File format of the output figure. All formats supported by pgfplotsx 
  can be used, namely ".pdf", ".tex", ".svg" and ".png", which is the default. 
"""
function densityHistogramPipeline(  snap_name::String, 
                                    source_path::String, 
                                    base_output_path::String, 
                                    anim_name::String, 
                                    frame_rate::Int64;
                                    step::Int64=1,
                                    sim_cosmo::Int64=0,
                                    factor::Int64=0,
                                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr,
                                    density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3,
                                    format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    time_data = timeSeriesData(sim_files, sim_cosmo=sim_cosmo, time_unit=time_unit)

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "density_histogram/images/")

    # Generate and store the plots.
    # animation = @animate 
    for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        density = densityData(snapshot; sim_cosmo=sim_cosmo)
            
        figure = densityHistogramPlot(  density, 
                                        time_data["clock_time"][i] * time_unit; 
                                        factor, 
                                        density_unit)
        savefig(figure, base_output_path * "density_histogram/images/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    # gif(animation, 
    #     base_output_path * "density_histogram/" * anim_name * ".gif", 
    #     fps=frame_rate
    # )

    # Make de video.
    # makeVideo(  base_output_path * "density_histogram/images/", 
    #             format, 
    #             base_output_path * "density_histogram/", 
    #             anim_name, 
    #             frame_rate
    #         )

    return nothing
end

"""
    densityProfilePipeline( snap_name::String, 
                            source_path::String, 
                            base_output_path::String, 
                            anim_name::String, 
                            frame_rate::Int64, 
                            type::String; 
                            <keyword arguments>)::Nothing

Save the results of the densityProfilePlot function in one image per snapshot,
and then generate a GIF and a video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`density_profile/images/ and will be 
  named `snap_name`_XXX`format` where XXX is the number of the snapshot.
  The GIF and the video will be stored in `base_output_path`density_profile/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `type::String`: Particle type.
  "gas" -> Gas particle. 
  "dark_matter" -> Dark matter particle.
  "stars" -> Star particle.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `bins::Int64=100`: Number of subdivisions of the region to be used for the profile. 
  The default is 100.
- `factor::Int64=0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3`: Unit of density 
  to be used in the output, all available density units in Unitful and UnitfulAstro can 
  be used, e.g. UnitfulAstro.Msun / UnitfulAstro.kpc^3, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by pgfplotsx 
  can be used, namely ".pdf", ".tex", ".svg" and ".png", which is the default. 
"""
function densityProfilePipeline(snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                anim_name::String, 
                                frame_rate::Int64,
                                type::String;
                                step::Int64=1,
                                sim_cosmo::Int64=0,
                                bins::Int64=100,
                                factor::Int64=0,
                                region_factor::Float64=1.0,
                                length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                                density_unit::Unitful.FreeUnits=UnitfulAstro.Msun / UnitfulAstro.kpc^3,
                                time_unit::Unitful.FreeUnits=UnitfulAstro.Myr,
                                region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                                format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    time_data = timeSeriesData(sim_files; sim_cosmo, time_unit)

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "density_profile/image/")

    # Generate and store the plots.
    # animation = @animate 
    for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        positions = positionData(   snapshot; 
                                    sim_cosmo, 
                                    length_unit, 
                                    box_size=region_size)
        mass = massData(snapshot, type; sim_cosmo)
            
        figure = densityProfilePlot(positions,
                                    mass, 
                                    time_data["clock_time"][i] * time_unit;
                                    bins,
                                    factor,
                                    region_factor,
                                    density_unit)
            
        savefig(figure, base_output_path * "density_profile/image/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    # gif(animation, 
    #     base_output_path * "density_profile/" * anim_name * ".gif", 
    #     fps=frame_rate
    # )

    # Make de video.
    # makeVideo(  base_output_path * "density_profile/image/", 
    #             format, 
    #             base_output_path * "density_profile/", 
    #             anim_name, 
    #             frame_rate
    #         )

    return nothing
end

"""
    metallicityProfilePipeline( snap_name::String, 
                                source_path::String, 
                                base_output_path::String, 
                                anim_name::String, 
                                frame_rate::Int64, 
                                type::String; 
                                <keyword arguments>)::Nothing

Save the results of the metallicityProfilePlot function in one image per snapshot,
and then generate a GIF and a video animating the images. 

# Arguments
- `snap_name::String`: Base name of the target snapshots.
- `source_path::String`: Path where the target snapshots are located.
- `base_output_path::String`: Path of parent directory for storing the figures.
  The images will be stored in `base_output_path`metallicity_profile/images and will be 
  named `snap_name`_XXX`format` where XXX is the number of the snapshot.
  The GIF and the video will be stored in `base_output_path`metallicity_profile/.
- `anim_name::String`: Name of the generated video and GIF, without the extension.
- `frame_rate::Int64`: Frame rate of the output video and GIF.
- `type::String`: Particle type.
  "gas" -> Gas particle. 
  "dark_matter" -> Dark matter particle.
  "stars" -> Star particle.
- `step::Int64=1`: Step used to traverse the list of snapshots. The default is 1, 
  i.e. all snapshots will be plotted.
- `sim_cosmo::Int64=0`: Value of the GADGET variable ComovingIntegrationOn: 
  0 -> Newtonian simulation (static universe).
  1 -> Cosmological simulation (expanding universe).
- `bins::Int64=100`: Number of subdivisions of the region to be used for the profile. 
  The default is 100.
- `region_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `length_unit::Unitful.FreeUnits=UnitfulAstro.kpc`: Unit of length to be used in the output, 
  all available length units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.kpc, which is the default.
- `time_unit::Unitful.FreeUnits=UnitfulAstro.Myr`: Unit of time to be used in the output, 
  all available time units in Unitful and UnitfulAstro can be used, 
  e.g. UnitfulAstro.Myr, which is the default.
- `region_size::Unitful.Quantity=1000UnitfulAstro.kpc`: Size of the plotting region 
  if vacuum boundary conditions were used. It has to have units, e.g. 1000UnitfulAstro.kpc, 
  which is the default. Its units don't have to be the same as `length_unit`.
- `format::String=".png"`: File format of the output figure. All formats supported by pgfplotsx 
  can be used, namely ".pdf", ".tex", ".svg" and ".png", which is the default. 
"""
function metallicityProfilePipeline(snap_name::String, 
                                    source_path::String, 
                                    base_output_path::String, 
                                    anim_name::String, 
                                    frame_rate::Int64,
                                    type::String;
                                    step::Int64=1,
                                    sim_cosmo::Int64=0,
                                    bins::Int64=100,
                                    region_factor::Float64=1.0,
                                    length_unit::Unitful.FreeUnits=UnitfulAstro.kpc,
                                    time_unit::Unitful.FreeUnits=UnitfulAstro.Myr,
                                    region_size::Unitful.Quantity=1000UnitfulAstro.kpc,
                                    format::String=".png")::Nothing

    # Get the simulation data.
    sim = getSnapshots(snap_name, source_path)
    sim_files = sim["snap_files"]
    snap_numbers = sim["numbers"]

    time_data = timeSeriesData(sim_files; sim_cosmo, time_unit)

    # Create a directory to store the figures, if it doesn't exist.
    mkpath(base_output_path * "metallicity_profile/image/")

    # Generate and store the plots.
    # animation = @animate 
    for i in 1:step:length(sim_files)
        snapshot = sim_files[i]
        positions = positionData(   snapshot; 
                                    sim_cosmo, 
                                    length_unit, 
                                    box_size=region_size)
        mass = massData(snapshot, type; sim_cosmo)
        metallicities = zData(snapshot, type; sim_cosmo)
            
        figure = metallicityProfilePlot(positions,
                                        mass, 
                                        metallicities,
                                        time_data["clock_time"][i] * time_unit;
                                        bins,
                                        region_factor)
            
        savefig(figure, base_output_path * "metallicity_profile/image/" * snap_name * "_" * snap_numbers[i] * format)
    end

    # Make the GIF.
    # gif(animation, 
    #     base_output_path * "metallicity_profile/" * anim_name * ".gif", 
    #     fps=frame_rate
    # )

    # Make de video.
    # makeVideo(  base_output_path * "metallicity_profile/image/", 
    #             format, 
    #             base_output_path * "metallicity_profile/", 
    #             anim_name, 
    #             frame_rate
    #         )

    return nothing
end