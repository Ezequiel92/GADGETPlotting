########################################################################################
# PLOTTING FUNCTIONS.
########################################################################################

"""
    scatterGridPlot(position_data::Dict{String, Any})::Plots.Plot

Make 9 scatter plots of the positions of the gas, dark matter and stars particles in the 
XY, XZ and YZ planes.
 
The result is a single figure in a 3x3 layout with its axes in the unit given by
`position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.

# Returns
- The plot generated by the GR backend of Plots.jl.
"""
function scatterGridPlot(position_data::Dict{String, Any})::Plots.Plot

    gr()

    # Get gas, dark matter and stars coordinates.
    gas_pos = position_data["gas"]
    gas_x = @view gas_pos[1, :]
    gas_y = @view gas_pos[2, :]
    gas_z = @view gas_pos[3, :]

    dm_pos = position_data["dark_matter"]
    dm_x = @view dm_pos[1, :]
    dm_y = @view dm_pos[2, :]
    dm_z = @view dm_pos[3, :]

    stars_pos = position_data["stars"]
    stars_x = @view stars_pos[1, :]
    stars_y = @view stars_pos[2, :]
    stars_z = @view stars_pos[3, :]

    if position_data["periodic"]
        # For periodic boundary conditions.
        stars_size = gas_size = dm_size = (position_data["box_size"] / 2) * 0.95
    else
        # For vacuum boundary conditions.
        stars_size = position_data["box_size"] * 1.1
        dm_size = stars_size * 3.0
        gas_size = stars_size * 7.0
    end

    # Unit for the axes.
    unit = position_data["unit"]

    # Plots of the XY plane.
    pl_gas_x_y = scatter(
        gas_x,
        gas_y,
        title = "Gas - XY plane",
        xlabel = "x / $unit",
        ylabel = "y / $unit",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
    )
    pl_dm_x_y = scatter(
        dm_x,
        dm_y,
        title = "Dark matter - XY plane",
        xlabel = "x / $unit",
        ylabel = "y / $unit",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
    )
    pl_stars_x_y = scatter(
        stars_x,
        stars_y,
        title = "Stars - XY plane",
        xlabel = "x / $unit",
        ylabel = "y / $unit",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
    )

    # Plots of the XZ plane.
    pl_gas_x_z = scatter(
        gas_x,
        gas_z,
        title = "Gas - XZ plane",
        xlabel = "x / $unit",
        ylabel = "z / $unit",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
    )
    pl_dm_x_z = scatter(
        dm_x,
        dm_z,
        title = "Dark matter - XZ plane",
        xlabel = "x / $unit",
        ylabel = "z / $unit",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
    )
    pl_stars_x_z = scatter(
        stars_x,
        stars_z,
        title = "Stars - XZ plane",
        xlabel = "x / $unit",
        ylabel = "z / $unit",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
    )

    # Plots of the YZ plane.
    pl_gas_y_z = scatter(
        gas_y,
        gas_z,
        title = "Gas - YZ plane",
        xlabel = "y / $unit",
        ylabel = "z / $unit",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
        right_margin = 25px,
    )
    pl_dm_y_z = scatter(
        dm_y,
        dm_z,
        title = "Dark matter - YZ plane",
        xlabel = "y / $unit",
        ylabel = "z / $unit",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
        right_margin = 25px,
    )
    pl_stars_y_z = scatter(
        stars_y,
        stars_z,
        title = "Stars - YZ plane",
        xlabel = "y / $unit",
        ylabel = "z / $unit",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
        right_margin = 25px,
    )

    # Final figure containing the nine plots.
    return scatter(
        pl_gas_x_y,
        pl_gas_x_z,
        pl_gas_y_z,
        pl_dm_x_y,
        pl_dm_x_z,
        pl_dm_y_z,
        pl_stars_x_y,
        pl_stars_x_z,
        pl_stars_y_z,
        layout = (3, 3),
        size = (2020, 2020),
        aspect_ratio = 1,
        left_margin = 35px,
        framestyle = :box,
        background_color_inside = :black,
        markersize = 2,
        markerstrokewidth = 0,
        legend = false,
        fontfamily = "Computer Modern",
        titlefontsize = 24,
        xtickfontsize = 20,
        ytickfontsize = 20,
        xguidefontsize = 22,
        yguidefontsize = 22,
    )
end

"""
    densityMapPlot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        density_data::Dict{String, Any}
        hsml_data::Dict{String, Any}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of the gas density in the XY, XZ and/or YZ planes. 

The axes are in the units given by `position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `mass_data::Dict{String,Any}`: Return value of the massData function.
- `density_data::Dict{String,Any}`: Return value of the densityData function.
- `hsml_data::Dict{String,Any}`: Return value of the hsmlData function.
- `plane::String = "All"`: String indicating which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `axes::Bool = false`: If true, the axes pasing through (0.0, 0.0) are drawn. If false, 
  no axes are drawn.
- `axes_color::Symbol = :white`: Color of the axes pasing through (0.0, 0.0), only relevant 
  if `axes = true`.
- `color::Symbol = :inferno`: Color scheme for the figure. 
  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap, 
  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.

# Returns
- The plot generated by the GR backend of Plots.jl.
"""
function densityMapPlot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    density_data::Dict{String, Any},
    hsml_data::Dict{String, Any};
    plane::String = "All",
    axes::Bool = false,
    axes_color::Symbol = :white,
    color::Symbol = :inferno,
)::Plots.Plot

    gr()

    # Resolution in pixels for the binning of the grid.
    resolution = 1000

    if position_data["periodic"]
        # For periodic boundary conditions.
        box_limits = (position_data["box_size"] / 2) * 0.95
        param = mappingParameters(
            x_lim = [-box_limits, box_limits],
            y_lim = [-box_limits, box_limits],
            z_lim = [-box_limits, box_limits],
            boxsize = position_data["box_size"],
            Npixels = resolution,
        )
    else
        # For vacuum boundary conditions.
        box_limits = position_data["box_size"] * 1.05
        param = mappingParameters(
            x_lim = [-box_limits, box_limits],
            y_lim = [-box_limits, box_limits],
            z_lim = [-box_limits, box_limits],
            Npixels = resolution,
        )
    end

    binning = range(-box_limits, stop = box_limits, length = resolution)
    color_scheme = cgrad(color)
    last_color = color_scheme[1]

    # Spline kernel used inside GADGET2/3.
    # 
    #   Monaghan, J. J., & Lattanzio, J. C. (1985). A refined particle method for 
    #   astrophysical problems. Astronomy and Astrophysics, 149(1), 135–143. 
    #   https://ui.adsabs.harvard.edu/abs/1985A&A...149..135M
    # 
    #   Springel, V. (2005). The cosmological simulation code gadget-2. Monthly Notices 
    #   of the Royal Astronomical Society, 364(4), 1105–1134. 
    #   https://doi.org/10.1111/j.1365-2966.2005.09655.x
    kernel = Cubic()

    pos = position_data["gas"]
    mass = mass_data["mass"]

    # Makes sure that all the units are consistent.
    length_unit = position_data["unit"]
    mass_unit = mass_data["unit"]
    if hsml_data["unit"] != length_unit
        hsml = @. ustrip(Float64, length_unit, hsml_data["gas_hsml"] * hsml_data["unit"])
    else
        hsml = hsml_data["gas_hsml"]
    end
    if density_data["unit"] != mass_unit / length_unit^3
        ρ = @. ustrip(
            Float64,
            mass_unit / length_unit^3,
            density_data["gas_density"] * density_data["unit"],
        )
    else
        ρ = density_data["gas_density"]
    end

    if plane == "XY" || plane == "All"
        sph_density = log10.(
            sphMapping(
                pos, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        xy_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = "x / $length_unit",
            ylabel = "y / $length_unit",
            title = "XY plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            xy_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "XZ" || plane == "All"
        # Active rotation (alibi) of the galaxy, using Euler angles.
        # Rx(-90°) Ry(0°) Rz(0°)
        pos_xz = rotate_3D(pos, -90.0, 0.0, 0.0)
        sph_density = log10.(
            sphMapping(
                pos_xz, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        xz_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = "x / $length_unit",
            ylabel = "z / $length_unit",
            title = "XZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            xz_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "YZ" || plane == "All"
        # Active rotation (alibi) of the galaxy, using Euler angles.
        # Rx(-90°) Ry(0°) Rz(-90°)
        pos_yz = rotate_3D(pos, -90.0, 0.0, -90.0)
        sph_density = log10.(
            sphMapping(
                pos_yz, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        yz_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = "y / $length_unit",
            ylabel = "z / $length_unit",
            title = "YZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            yz_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "XY"
        return xy_plot
    elseif plane == "XZ"
        return xz_plot
    elseif plane == "YZ"
        return yz_plot
    elseif plane == "All"
        # Plot the three planes together.
        return plot(
            xy_plot,
            xz_plot,
            yz_plot,
            layout = (1, 3),
            size = (3030, 1000),
            left_margin = 90px,
            right_margin = 40px,
            top_margin = -25px,
            bottom_margin = 40px,
        )
    else
        error("'$plane' is not an option for a plane.")
    end
end

"""
    starMapPlot(position_data::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make a plot of the star density in the XY, XZ and/or YZ planes. 

The axes are in the units `position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the positionData function.
- `plane::String="All"`: String indicating which plane will be plotted. 
  "XY" -> XY plane alone.
  "XZ" -> XZ plane alone.
  "YZ" -> YZ plane alone.
  "All" -> The three planes in a single 1x3 figure.
- `box_factor::Float64=1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `axes::Bool = false`: If true, the axes passing through (0.0, 0.0) are drawn. If false, 
  no axes are drawn.
- `axes_color::Symbol = :white`: Color of the axes pasing through (0.0, 0.0), only relevant 
  if `axes = true`.
- `color::Symbol = :inferno`: Color scheme for the figure. 
  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap, 
  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.
  
# Returns
- The plot generated by the GR backend of Plots.jl.
"""
function starMapPlot(
    position_data::Dict{String, Any};
    plane::String = "All",
    box_factor::Float64 = 1.0,
    axes::Bool = false,
    axes_color::Symbol = :white,
    color::Symbol = :inferno,
)::Plots.Plot

    gr()

    # Get the position data.
    pos = position_data["stars"]
    if position_data["periodic"]
        # For periodic boundary conditions.
        box_limits = (position_data["box_size"] / 2) * box_factor
    else
        # For vacuum boundary conditions.
        box_limits = position_data["box_size"] * box_factor
    end

    # Resolution in pixels for the binning of the grid.
    resolution = 1000
    # Discretization of the plotting region.
    binnig = range(-box_limits, stop = box_limits, length = resolution)

    stars_present = !isempty(pos)
    if stars_present
        # If stars already formed.
        x, y, z = pos[1, :], pos[2, :], pos[3, :]
    else
        # If they didn't.
        x, y, z = binnig, binnig, zeros(Float64, resolution, resolution)
    end

    # Unit for the axes.
    length_unit = position_data["unit"]

    color_scheme = cgrad(color)
    last_color = color_scheme[1]

    if plane == "XY" || plane == "All"
        if stars_present
            density_xy = xyz(ash(x, y, rngx = binnig, rngy = binnig))
            heatmap(density_xy[1], density_xy[2], log10.(density_xy[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, :white), legend = false)
            vline!([0.0], line = (2, :white))
        end

        xy_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = "x / $length_unit",
            ylabel = "y / $length_unit",
            title = "XY plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "XZ" || plane == "All"
        if stars_present
            density_xz = xyz(ash(x, z, rngx = binnig, rngy = binnig))
            heatmap(density_xz[1], density_xz[2], log10.(density_xz[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, :white), legend = false)
            vline!([0.0], line = (2, :white), legend = false)
        end

        xz_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = "x / $length_unit",
            ylabel = "z / $length_unit",
            title = "XZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "YZ" || plane == "All"
        if stars_present
            density_yz = xyz(ash(y, z, rngx = binnig, rngy = binnig))
            heatmap(density_yz[1], density_yz[2], log10.(density_yz[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, :white), legend = false)
            vline!([0.0], line = (2, :white), legend = false)
        end

        yz_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = "y / $length_unit",
            ylabel = "z / $length_unit",
            title = "YZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "XY"
        return xy_plot
    elseif plane == "XZ"
        return xz_plot
    elseif plane == "YZ"
        return yz_plot
    elseif plane == "All"
        # Plot the three planes together.
        return plot(
            xy_plot,
            xz_plot,
            yz_plot,
            layout = (1, 3),
            size = (3030, 1000),
            left_margin = 90px,
            right_margin = 40px,
            top_margin = -25px,
            bottom_margin = 40px,
        )
    else
        error("'$plane' is not an option for a plane.")
    end
end

"""
    gasStarEvolutionPlot(
        index::Int64,
        time_series::Dict{String, Any},
        position_data::Dict{String, Any}, 
    )::Plots.Plot

Makes 3 plots, the position of the particles in the XY plane, the baryonic fractional mass 
and the SFR. The first two for stars and gas. All in a single figure with a 1x2 layout

The figure is created with the time running from 0 to `time_series["clock_time"][index]`.

# Arguments
- `index::Int64`: Index of the final time step up to which the figure will show the 
  evolution of the variables.
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.	
- `position_data::Dict{String,Any}`: Return value of the positionData function.
	
# Returns
- The plot generated by the GR backend of Plots.jl.
"""
function gasStarEvolutionPlot(
    index::Int64,
    time_series::Dict{String, Any},
    position_data::Dict{String, Any}, 
)::Plots.Plot

    gr()

    # Formatting for the axis's labels
    time_unit = time_series["units"]["time"]
    length_unit = position_data["unit"]
    sfr_unit = string(time_series["units"]["sfr"])
    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => "\\left(\\textrm{M}_{\\odot} \\, \\textrm{"),
        "^-1" => "}^{-1}\\right)",
    )

    if position_data["periodic"]
        # For periodic boundary conditions.
        size = (position_data["box_size"] / 2) * 0.95
    else
        # For vacuum boundary conditions.
        size = position_data["box_size"] * 5.5
    end

    # Raw data.
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    gas_bar_frac = time_series["gas_bar_frac"]
    star_bar_frac = time_series["star_bar_frac"]

    # Position data.
    gas_x = @view position_data["gas"][1, :]
    gas_y = @view position_data["gas"][2, :]
    stars_x = @view position_data["stars"][1, :]
    stars_y = @view position_data["stars"][2, :]

    # Trimmed data for the animation.
    reduced_time = @view t[1:index]
    reduced_sfr = @view sfr[1:index]
    reduced_gas = @view gas_bar_frac[1:index]
    reduced_stars = @view star_bar_frac[1:index]

    baryonic_frac = [reduced_gas reduced_stars]

    # Data for the time stamp.
    clock = round(t[index], sigdigits = 4)
    # Upper limit for the time axis label.     
    t_end = ceil(t[end]) * 1.025
    # Upper limit for the SFR axis label.         
    sfr_end = ceil(maximum(sfr)) * 1.05

    # Fractional baryonic mass plot.
    pl_frac = plot(
        reduced_time,
        baryonic_frac,
        xlims = (-t_end * 0.025, t_end),
        ylims = (-0.05, 1.05),
        xlabel = "t / $time_unit",
        ylabel = "Fractional baryonic mass",
        linestyle = [:solid :dash],
        lw = 4,
        label = ["Gas" "Stars"],
        legend = :bottomright,
        background_color_legend = nothing,
        foreground_color_legend = nothing,
        color = [:blueviolet :darkorange2],
    )

    # SFR plot.
    pl_sfr = plot(
        reduced_time,
        reduced_sfr,
        xlabel = "t / $time_unit",
        ylabel = L"\textrm{SFR} \ / \, %$sfr_unit",
        legend = false,
        lw = 4,
        xlims = (-t_end * 0.025, t_end),
        ylims = (-sfr_end * 0.05, sfr_end),
        color = :darkorange2,
    )

    # Scatter plot of gas and stars in the XY plane.
    scatter(
        gas_x,
        gas_y,
        xlabel = "x / $length_unit",
        ylabel = "y / $length_unit",
        xlims = (-size, size),
        ylims = (-size, size),
        aspect_ratio = 1,
        label = "Gas",
        legend = :bottomright,
        markersize = 2,
        markerstrokewidth = 0,
        background_color_inside = :black,
        markercolor = :blueviolet,
        background_color_legend = :black,
    )
    pl_scatter = scatter!(
        stars_x,
        stars_y,
        label = "Stars",
        legend = :bottomright,
        markersize = 2,
        markerstrokewidth = 0,
        markercolor = :darkorange2,
        legendfontcolor = :white,
        background_color_legend = :black,
        foreground_color_legend = nothing,
    )
    annotate!(
        relative(pl_scatter, 0.5, 0.95)...,
        text("$clock $time_unit", "Courier Bold", 25, :white, :center),
    )

    l = @layout [a{0.5w} grid(2, 1)]

    # Final figure containing the three plots.
    return plot(
        pl_scatter,
        pl_frac,
        pl_sfr,
        layout = l,
        framestyle = :box,
        size = (2200, 1100),
        left_margin = 60px,
        right_margin = 50px,
        top_margin = 20px,
        bottom_margin = 55px,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 25,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )
end

"""
    CMDFPlot(
        m_data::Dict{String, Any}, 
        z_data::Dict{String, Any},
        time::Unitful.Quantity;
        <keyword arguments>
    )::Plots.Plot
	
Make a cumulative metallicity distribution function plot, for a given time step.

`m_data` and `z_data` must be in the same units.

# Arguments
- `m_data::Dict{String, Any}`: Return value of the massData function.
- `z_data::Dict{String, Any}`: Return value of the zData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64`: Number of subdivisions of the metallicity to construct the plot.
- `x_norm::Bool = false`: If the x axis will be normalized to its maximum value. 

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function CMDFPlot(
    m_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 50,
    x_norm::Bool = false,
)::Plots.Plot

    pgfplotsx()

    # Unit consistency check.
    (
        m_data["unit"] == z_data["unit"] ||
        error("Mass and metallicity must be in the same units.")
    )

    # Get the mass data.
    mass_data = m_data["mass"]
    metallicity_data = z_data["Z"]

    # Compute the cumulative metallicity distribution function.
    max_z = findmax(metallicity_data)
    max_Z = max_z[1] / mass_data[max_z[2]]
    Z, m = CMDF(mass_data, metallicity_data, max_Z, bins; x_norm)

    # x axis label.
    if x_norm
        xlabel = L"Z \, / \, Z_{\mathrm{max}}"
    else
        xlabel = "Z"
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    return plot(
        Z,
        m,
        xlabel = xlabel,
        ylabel = L"M_{\star}(< Z) \, / \, M_{\star}",
        legend = false,
        framestyle = :box,
        size = (1200, 900),
        lw = 2,
        xtickfontsize = 25,
        ytickfontsize = 25,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.05) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    CMDFPlot(
        m_data::Vector{Dict{String, Any}}, 
        z_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2};
        <keyword arguments>
    )::Plots.Plot
	
Make a cumulative metallicity distribution function plot of several datasets, 
for a given time step.

`m_data` and `z_data` must be in the same units.

# Arguments
- `m_data::Vector{Dict{String, Any}}`: Return values of the massData function.
- `z_data::Vector{Dict{String, Any}}`: Return values of the zData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `bins::Int64`: Number of subdivisions of the metallicity to construct the plot.
- `x_norm::Bool = false`: If the x axis will be normalize to its maximum value. 

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function CMDFPlot(
    m_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    bins::Int64 = 50,
    x_norm::Bool = false,
)::Plots.Plot

    pgfplotsx()

    # Check unit consistency.
    mass_units = get.(m_data, "unit", 0)
    if !all(x -> x == mass_units[1], mass_units)
        error("The units of mass are not the same among datasets.")
    else
        m_unit = mass_units[1]
    end

    mass_z_units = get.(z_data, "unit", 0)
    if !all(x -> x == mass_z_units[1], mass_z_units)
        error("The units of metallicity are not the same among datasets.")
    else
        z_unit = mass_z_units[1]
    end

    m_unit == z_unit || error("Mass and metallicity must be in the same units.")

    # Get the mass data.
    masses = get.(m_data, "mass", 0)
    metallicities = get.(z_data, "Z", 0)

    Z = Vector{Float64}[]
    m = Vector{Float64}[]
    for (mass, metallicity) in zip(masses, metallicities)
        # Compute the cumulative metallicity distribution function.
        max_z = findmax(metallicity)
        max_Z = max_z[1] / mass[max_z[2]]
        Z_result, m_result = CMDF(mass, metallicity, max_Z, bins; x_norm)

        push!(Z, Z_result)
        push!(m, m_result)
    end

    # x axis label.
    if x_norm
        xlabel = L"Z \, / \, Z_{\mathrm{max}}"
    else
        xlabel = "Z"
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    return plot(
        hcat(Z...),
        hcat(m...),
        xlabel = xlabel,
        ylabel = L"M_{\star}(< Z) \, / \, M_{\star}",
        label = labels,
        framestyle = :box,
        size = (1200, 900),
        legend = :bottomright,
        lw = 2,
        linestyle = :auto,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        xtickfontsize = 25,
        ytickfontsize = 25,
        xguidefontsize = 30,
        yguidefontsize = 30,
        legendfontsize = 25,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.05) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    birthHistogramPlot(birth_data::Dict{String, Any}; <keyword arguments>)::Plots.Plot

Make a histogram of the number of stars born at a certain radial distance.

# Arguments
- `birth_data::Dict{String, Any}`: Return value of the birthPlace function.
- `bins::Int64 = 50`: Number of bins to use in the histogram.
	
# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function birthHistogramPlot(birth_data::Dict{String, Any}; bins::Int64 = 50)::Plots.Plot

    pgfplotsx()

    pos = birth_data["birth_place"]
    length_unit = birth_data["unit"]
    distances = sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2)

    return histogram(
        distances;
        bins = range(0, stop = maximum(distances), length = bins),
        xlabel = "r / $length_unit",
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )
end

"""
    timeSeriesPlot(time_series::Dict{String, Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. 

All the plots show the evolution of the corresponding parameter versus time.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, 
  e.g. if mass_factor = 10 => the corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 => the corresponding axis will be scaled by 10^4.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function timeSeriesPlot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    pgfplotsx()

    # Formatting for the axes labels.
    time_unit = time_series["units"]["time"]
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"),
        "^-1" => L"^{-1}}\right)$",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles"
    if number_factor != 0
        ylabel_num *= L"\ \, / \ 10^{%$number_factor}"
    end

    # Data to be plotted.
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor

    # Number of stars and gas particles vs. time.
    pl_number = plot(
        t,
        number,
        xlabel = "t / $time_unit",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Mass of stars and gas vs. time.
    pl_mass = plot(
        t,
        mass,
        xlabel = "t / $time_unit",
        ylabel = L"Total mass %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Baryonic fraction of stars and gas vs. time.
    pl_frac = plot(
        t,
        baryonic_frac,
        xlabel = "t / $time_unit",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # SFR vs. time.
    pl_sfr = plot(
        t,
        sfr,
        xlabel = "t / $time_unit",
        ylabel = L"SFR %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Final figure containing the four plots.
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        left_margin = 130px,
        top_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 30,
    )
end

"""
    scaleFactorSeriesPlot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars.

All the plots show the evolution of the corresponding parameter versus the scale factor.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, 
  e.g. if mass_factor = 10 => the corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 => the corresponding axis will be scaled by 10^4.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function scaleFactorSeriesPlot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    pgfplotsx()

    # Formatting for the axes labels.
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"),
        "^-1" => L"^{-1}}\right)$",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles"
    if number_factor != 0
        ylabel_num *= L"\ \, / \ 10^{%$number_factor}"
    end

    # Data to be plotted.
    a = time_series["scale_factor"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor

    # Number of stars and gas particles vs. scale factor.
    pl_number = plot(
        a,
        number,
        xlabel = "Scale factor",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Mass of stars and gas vs. scale factor.
    pl_mass = plot(
        a,
        mass,
        xlabel = "Scale factor",
        ylabel = L"Total mass %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Baryonic fraction of stars and gas vs. scale factor.
    pl_frac = plot(
        a,
        baryonic_frac,
        xlabel = "Scale factor",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # SFR vs. scale factor.
    pl_sfr = plot(
        a,
        sfr,
        xlabel = "Scale factor",
        ylabel = L"SFR %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Final figure containing the four plots.
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        left_margin = 130px,
        top_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 30,
    )
end

"""
    redshiftSeriesPlot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots (in a single figure with a 2x2 layout) of the number of particles, 
the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. 

All the plots show the evolution of the corresponding parameter versus the redshift.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the timeSeriesData function.
- `mass_factor::Int64=0`: Numerical exponent to scale the mass, 
  e.g. if mass_factor = 10 => the corresponding axis will be scaled by 10^10.
- `number_factor::Int64=0`: Numerical exponent to scale the number of particles, 
  e.g. if number_factor = 4 => the corresponding axis will be scaled by 10^4.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function redshiftSeriesPlot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    pgfplotsx()

    # Formatting for the axes labels.
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"),
        "^-1" => L"^{-1}}\right)$",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => L"\, / \ \left(10^{%$mass_factor} \, \mathrm{M}_{\odot}\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles.
    ylabel_num = "Number of particles"
    if number_factor != 0
        ylabel_num *= L"\ \, / \ 10^{%$number_factor}"
    end

    # Data to be plotted.
    z = time_series["redshift"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10^mass_factor

    # Number of stars and gas particles vs. redshift.
    pl_number = plot(
        z,
        number,
        xlabel = "Redshift",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Mass of stars and gas vs. redshift.
    pl_mass = plot(
        z,
        mass,
        xlabel = "Redshift",
        ylabel = L"Total mass %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Baryonic fraction of stars and gas vs. redshift.
    pl_frac = plot(
        z,
        baryonic_frac,
        xlabel = "Redshift",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # SFR vs. redshift..
    pl_sfr = plot(
        z,
        sfr,
        xlabel = "Redshift",
        ylabel = L"SFR %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )

    # Final figure containing the four plots.
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        left_margin = 130px,
        top_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 30,
    )
end

"""
    compareSimulationsPlot(
        data::Vector{Dict{String, Any}},
        x_quantity::String,
        y_quantity::String,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot comparing among several simulations `y_quantity` vs. `x_quantity` .

The data of each simulation must be in the same units, and `x_quantity` and `y_quantity` 
can be any magnitude used in the timeSeriesData function, namely:

- "scale_factor"                  
- "redshift"                  
- "clock_time" (Physical time)
- "sfr" (SFR) 			              
- "sfr_prob" (SFR probability - Not normalized) 			           
- "gas_number" (Gas particle number) 	            
- "dm_number" (Dark matter particle number)		               
- "star_number" (Star number)         
- "gas_mass" (Total gas mass)               
- "dm_mass" (Total dark matter mass)	            
- "star_mass" (Total star mass)		
- "gas_density" (Total gas density)	               
- "gas_frac" (Gas fraction)		                
- "dm_frac" (Dark matter fraction)		                
- "star_frac" (Star fraction)	                   
- "gas_bar_frac" (Baryonic gas fraction)                  
- "star_bar_frac" (Baryonic star fraction)

# Arguments
- `data::Vector{Dict{String,Any}}`: Return value of the timeSeriesData function for 
  every simulation in a Vector, e.g. [data_sim1, data_sim2].
- `x_quantity::String`: String indicating the physical magnitude for the x axis. 
- `y_quantity::String`: String indicating the physical magnitude for the y axis.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.
- `x_factor::Int64 = 0`: Numerical exponent to scale the `x_quantity`, e.g. if x_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `y_factor::Int64 = 0`: Numerical exponent to scale the `y_quantity`, e.g. if y_factor = 10 
  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `scale::Vector{Symbol} = [:identity, :identity],`: Scaling to be used for the x 
  and y axes. The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `smooth_data::Bool = false`: If true a smoothing window with no weighs is applied to 
  the y data. If false, no transformation occurs.
- `bins::Int64 = 0`: Number of subdivisions for the smoothing of the data, only relevant if
  `smooth_data = true`. 
- `legend_pos::Symbol = :bottomright`: Position of the legend, e.g. :topleft.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function compareSimulationsPlot(
    data::Vector{Dict{String, Any}},
    x_quantity::String,
    y_quantity::String,
    labels::Array{String, 2};
    title::String = "",
    x_factor::Int64 = 0,
    y_factor::Int64 = 0,
    scale::Vector{Symbol} = [:identity, :identity],
    smooth_data::Bool = false,
    bins::Int64 = 50,
    legend_pos::Symbol = :best,
)::Plots.Plot

    pgfplotsx()

    # Extract data and scale it by 10^factor.
    x_data = collect(get.(data, x_quantity, 0)) ./ 10^x_factor
    y_data = collect(get.(data, y_quantity, 0)) ./ 10^y_factor

    if smooth_data
        # If required, smooth the data with a moving window.
        smooth_data = map(
            (x, y) -> smoothWindow(x, y, bins; log = (scale[1] == :log10)),
            x_data,
            y_data,
        )
        x_data = [x[1] for x in smooth_data]
        y_data = [y[2] for y in smooth_data]
    end

    if scale[2] == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0, y_data)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting.
            @inbounds for i in eachindex(x_data, y_data)
                deleteat!(x_data[i], y_data[i] .<= 0)
                filter!(x -> x > 0, y_data[i])
            end

            # Fill the datasets with NaN so all have the same length.
            max_length = maximum(length.(x_data))
            for (i, l_x) in enumerate(length.(x_data))
                if l_x < max_length
                    @inbounds for _ in 1:(max_length - l_x)
                        push!(x_data[i], NaN)
                        push!(y_data[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale.
            scale[2] = :identity
        end
    end

    # Labels for the axes.
    ylabel = data[1]["labels"][y_quantity]
    xlabel = data[1]["labels"][x_quantity]

    # Formatting for the x axis.
    if x_quantity == "clock_time"
        unit = data[1]["units"]["time"]

        if x_factor != 0
            xlabel *= L"\ / \, \left(10^{%$x_factor} \, \mathrm{%$unit}\right)"
        else
            xlabel *= " / $unit"
        end

    elseif x_quantity == "sfr"
        unit = string(data[1]["units"]["sfr"])

        if x_factor != 0
            xlabel *= replace(
                replace(
                    unit,
                    "M⊙" => L"$\ / \, \left(10^{%$x_factor} \, \mathrm{M_{\odot} \,",
                ),
                "^-1" => L"^{-1}}\right)$",
            )
        else
            xlabel *= replace(
                replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"),
                "^-1" => L"^{-1}}\right)$",
            )
        end

    elseif x_quantity == "gas_mass" || x_quantity == "dm_mass" || x_quantity == "star_mass"
        unit = string(data[1]["units"]["mass"])

        if x_factor != 0
            xlabel *= replace(
                unit,
                "M⊙" => L"\ / \, \left(10^{%$x_factor} \, \mathrm{M}_{\odot}\right)",
            )
        else
            xlabel *= replace(unit, "M⊙" => L"\ / \, \left(\mathrm{M}_{\odot}\right)")
        end

    elseif x_quantity == "gas_density"
        unit = string(data[1]["units"]["mass"] / data[1]["units"]["length"]^3)

        if x_factor != 0
            xlabel *= replace(
                replace(
                    unit,
                    "M⊙" => L"$\ / \, \left(10^{%$x_factor} \, \mathrm{M_{\odot} \,",
                ),
                "^-3" => L"^{-3}}\right)$",
            )
        else
            xlabel *= replace(
                replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"),
                "^-3" => L"^{-3}}\right)$",
            )
        end

    elseif x_factor != 0
        xlabel *= L"\ / \, 10^{%$x_factor}"
    end

    # Formatting for the y axis.
    if y_quantity == "clock_time"
        unit = data[1]["units"]["time"]

        if y_factor != 0
            ylabel *= L"\ / \, \left(10^{%$y_factor} \, \mathrm{%$unit}\right)"
        else
            ylabel *= " / $unit"
        end

    elseif y_quantity == "sfr"
        unit = string(data[1]["units"]["sfr"])

        if y_factor != 0
            ylabel *= replace(
                replace(
                    unit,
                    "M⊙" => L"$\ / \, \left(10^{%$y_factor} \, \mathrm{M_{\odot} \,",
                ),
                "^-1" => L"^{-1}}\right)$",
            )
        else
            ylabel *= replace(
                replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"),
                "^-1" => L"^{-1}}\right)$",
            )
        end

    elseif y_quantity == "gas_mass" || y_quantity == "dm_mass" || y_quantity == "star_mass"
        unit = string(data[1]["units"]["mass"])

        if y_factor != 0
            ylabel *= replace(
                unit,
                "M⊙" => L"\ / \, \left(10^{%$y_factor} \, \mathrm{M}_{\odot}\right)",
            )
        else
            ylabel *= replace(unit, "M⊙" => L"\ / \, \left(\mathrm{M}_{\odot}\right)")
        end

    elseif y_quantity == "gas_density"
        unit = string(data[1]["units"]["mass"] / data[1]["units"]["length"]^3)

        if y_factor != 0
            ylabel *= replace(
                replace(
                    unit,
                    "M⊙" => L"$\ / \, \left(10^{%$y_factor} \, \mathrm{M_{\odot} \,",
                ),
                "^-3" => L"^{-3}}\right)$",
            )
        else
            ylabel *= replace(
                replace(unit, "M⊙" => L"$\ / \, \left(\mathrm{M_{\odot} \,"),
                "^-3" => L"^{-3}}\right)$",
            )
        end

    elseif y_factor != 0
        ylabel *= L"\ / \, 10^{%$y_factor}"
    end

    return plot(
        hcat(x_data...),
        hcat(y_data...);
        xlabel,
        ylabel,
        xscale = scale[1],
        yscale = scale[2],
        title,
        label = labels,
        legend = legend_pos,
        framestyle = :box,
        size = (1200, 700),
        lw = 4,
        linestyle = :auto,
        titlefontsize = 28,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 24,
        yguidefontsize = 24,
        legendfontsize = 25,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        ticklabel_shift = ".1cm",
        extra_kwargs = :subplot,
    )
end

"""
    densityHistogramPlot(
        density_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a histogram of the densities of the gas particles.

# Arguments
- `density_data::Dict{String,Any}`: Return value of the densityData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64 = 20`: Number of bins to use in the histogram.
- `factor::Int64 = 0`: Numerical exponent to scale `density_data`, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
	
# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function densityHistogramPlot(
    density_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 20,
    factor::Int64 = 0,
)::Plots.Plot

    pgfplotsx()

    # Get the density data.
    ρ = density_data["gas_density"]
    # Scale data by 10^factor.
    ρ ./= 10^factor

    # Formatting for the x axis label.
    str_unit = string(density_data["unit"])
    xlabel = L"\rho \ / \,"
    if factor != 0
        xlabel *= replace(
            replace(str_unit, "M⊙" => L"$\left(10^{%$factor} \, \mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    else
        xlabel *= replace(
            replace(str_unit, "M⊙" => L"$\left(\mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    return histogram(
        ρ,
        bins = range(0, stop = maximum(ρ), length = bins),
        xlabel = xlabel,
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    densityProfilePlot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a density profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the positionData function.
- `mass_data::Dict{String, Any}`: Return value of the massData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function densityProfilePlot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    type = mass_data["type"]
    masses = mass_data["mass"]

    pos = position_data[type]
    length_unit = position_data["unit"]

    # Set the units.
    density_unit = mass_data["unit"] / (length_unit^3)

    if isempty(pos)
        # In the case that there are no particles.
        distances = [Inf]
    else
        distances = sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2)
    end

    if position_data["periodic"]
        # For periodic boundary conditions.
        r_max = (position_data["box_size"] / 2) * box_factor
    else
        # Plotting region for vacuum boundary conditions.
        r_max = position_data["box_size"] * box_factor
    end

    r, ρ = densityProfile(masses, distances, r_max, bins)
    # Scale data by 10^factor.
    ρ ./= 10^factor

    if scale == :log10
        positive_rho = findall(x -> x > 0, ρ)
        if length(positive_rho) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting.
            deleteat!(r, ρ .<= 0)
            filter!(x -> x > 0, ρ)
        else
            # If the data has less than two positive values, go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    ρ_unit = string(density_unit)
    if type == "gas"
        ylabel = L"\rho_{\mathrm{gas}} \ / \,"
    elseif type == "stars"
        ylabel = L"\rho_{\mathrm{stars}} \ / \,"
    elseif type == "dark_matter"
        ylabel = L"\rho_{\mathrm{dm}} \ / \,"
    end
    if factor != 0
        ylabel *= replace(
            replace(ρ_unit, "M⊙" => L"$\left(10^{%$factor} \, \mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    else
        ylabel *= replace(
            replace(ρ_unit, "M⊙" => L"$\left(\mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    end

    return plot(
        r,
        ρ,
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    densityProfilePlot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a density profile plot comparing several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Vector of return values of the positionData 
  function.
- `mass_data::Vector{Dict{String, Any}}`: Vector of return values of the massData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile.
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function densityProfilePlot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    # Extract data from arguments and check consistency.
    types = get.(mass_data, "type", 0)
    if !all(x -> x == types[1], types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(x -> x == length_units[1], length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    if !all(x -> x == mass_units[1], mass_units)
        error("The units of mass are not the same among datasets.")
    else
        mass_unit = mass_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(x -> x == periodicities[1], periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    masses = get.(mass_data, "mass", 0)
    positions = get.(position_data, type, 0)
    # Set the units.
    density_unit = mass_unit / (length_unit^3)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles.
            push!(distances, [Inf])
        else
            push!(distances, sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2))
        end
    end

    if periodicity
        # For periodic boundary conditions.
        max_rs = (get.(position_data, "box_size", 0) ./ 2) .* box_factor
    else
        # Plotting region for vacuum boundary conditions.
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    ρ = Vector{Float64}[]
    for (mass, distance, max_r) in zip(masses, distances, max_rs)
        r_result, ρ_result = densityProfile(mass, distance, max_r, bins)
        # Scale data by 10^factor.
        ρ_result ./= 10^factor

        push!(r, r_result)
        push!(ρ, ρ_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0, ρ)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting.
            @inbounds for i in eachindex(r, ρ)
                deleteat!(r[i], ρ[i] .<= 0)
                filter!(x -> x > 0, ρ[i])
            end

            # Fill the datasets with NaN so all have the same length.
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(ρ[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    ρ_unit = string(density_unit)
    if factor != 0
        ρ_unit = replace(
            replace(ρ_unit, "M⊙" => L"$\, / \ \left(10^{%$factor} \, \mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    else
        ρ_unit = replace(
            replace(ρ_unit, "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"),
            "^-3" => L"^{-3}}\right)$",
        )
    end

    if type == "gas"
        ylabel = L"Gas density %$ρ_unit"
    elseif type == "stars"
        ylabel = L"Star density %$ρ_unit"
    elseif type == "dark_matter"
        ylabel = L"Dark matter density %$ρ_unit"
    end

    return plot(
        hcat(r...),
        hcat(ρ...),
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :topright,
        lw = 3,
        linestyle = :auto,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        palette = :Set1_9,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        legendfontsize = 25,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    metallicityProfilePlot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        z_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a metallicity profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the positionData function.
- `mass_data::Dict{String, Any}`: Return value of the massData function.
- `z_data::Dict{String ,Any}`: Return value of the zData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function metallicityProfilePlot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Union{Int64, Nothing} = 100,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    mass_unit = mass_data["unit"]
    z_unit = z_data["unit"]
    if mass_unit != z_unit
        error("The mass units should be the same as the metallicity units.")
    end

    type = mass_data["type"]
    masses = mass_data["mass"]
    metallicity = z_data["Z"]
    pos = position_data[type]
    length_unit = position_data["unit"]

    if isempty(pos)
        # In the case that there are no particles.
        distances = [Inf]
    else
        distances = sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2)
    end

    if position_data["periodic"]
        # For periodic boundary conditions.
        r_max = (position_data["box_size"] / 2) * box_factor
    else
        # Plotting region for vacuum boundary conditions.
        r_max = position_data["box_size"] * box_factor
    end

    r, z = metallicityProfile(masses, distances, metallicity, r_max, bins)

    if scale == :log10
        positive_z = findall(x -> x > 0, z)
        if length(positive_z) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting.
            deleteat!(r, z .<= 0)
            filter!(x -> x > 0, z)

        else
            # If the data has less than two positive values, go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    if type == "gas"
        ylabel = L"\mathrm{Gas} \ \mathrm{Z} \ / \ \mathrm{Z_{\odot}}"
    elseif type == "stars"
        ylabel = L"\mathrm{Star} \ \mathrm{Z} \ / \ \mathrm{Z_{\odot}}"
    end

    return plot(
        r,
        z,
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    metallicityProfilePlot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        z_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a metallicity profile plot comparing several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Return values of the positionData function.
- `mass_data::Vector{Dict{String, Any}}`: Return values of the massData function.
- `z_data::Vector{Dict{String, Any}}`: Return values of the zData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function metallicityProfilePlot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Union{Int64, Nothing} = 100,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    # Extract data from arguments and check consistency.
    types = get.(mass_data, "type", 0)
    if !all(x -> x == types[1], types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(x -> x == length_units[1], length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(x -> x == periodicities[1], periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    z_units = get.(z_data, "unit", 0)
    if !all(x -> x[1] == x[2], zip(mass_units, z_units))
        error("The mass units should be the same as the metallicity units.")
    end

    masses = get.(mass_data, "mass", 0)
    metallicities = get.(z_data, "Z", 0)
    positions = get.(position_data, type, 0)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles.
            push!(distances, [Inf])
        else
            push!(distances, sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2))
        end
    end

    if periodicity
        # For periodic boundary conditions.
        max_rs = (get.(position_data, "box_size", 0) ./ 2) .* box_factor
    else
        # Plotting region for vacuum boundary conditions.
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    z = Vector{Float64}[]
    for (mass, distance, metallicity, max_r) in
        zip(masses, distances, metallicities, max_rs)
        r_result, z_result = metallicityProfile(mass, distance, metallicity, max_r, bins)

        push!(r, r_result)
        push!(z, z_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0, z)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting.
            @inbounds for i in eachindex(r, z)
                deleteat!(r[i], z[i] .<= 0)
                filter!(x -> x > 0, z[i])
            end

            # Fill the datasets with NaN so all have the same length.
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(z[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    if type == "gas"
        ylabel = L"\mathrm{Gas} \ \mathrm{Z} \ / \ \mathrm{Z_{\odot}}"
    elseif type == "stars"
        ylabel = L"\mathrm{Star} \ \mathrm{Z} \ / \ \mathrm{Z_{\odot}}"
    end

    return plot(
        hcat(r...),
        hcat(z...),
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :topright,
        lw = 3,
        linestyle = :auto,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        palette = :Set1_9,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        legendfontsize = 25,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    massProfilePlot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make an accumulated mass profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the positionData function.
- `mass_data::Dict{String, Any}`: Return value of the massData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function massProfilePlot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    type = mass_data["type"]
    masses = mass_data["mass"]
    mass_unit = mass_data["unit"]

    pos = position_data[type]
    length_unit = position_data["unit"]

    if isempty(pos)
        # In the case that there are no particles.
        distances = [Inf]
    else
        distances = sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2)
    end

    if position_data["periodic"]
        # For periodic boundary conditions.
        r_max = (position_data["box_size"] / 2) * box_factor
    else
        # Plotting region for vacuum boundary conditions.
        r_max = position_data["box_size"] * box_factor
    end

    r, m = massProfile(masses, distances, r_max, bins)
    # Scale data by 10^factor.
    m ./= 10^factor

    if scale == :log10
        positive_mass = findall(x -> x > 0, m)
        if length(positive_mass) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting.
            deleteat!(r, m .<= 0)
            filter!(x -> x > 0, m)
        else
            # If the data has less than two positive values, go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    m_unit = string(mass_unit)
    if factor != 0
        m_unit = replace(
            m_unit,
            "M⊙" => L"\, / \ \left(10^{%$factor} \, \mathrm{M}_{\odot}\right)",
        )
    else
        m_unit = replace(m_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    if type == "gas"
        ylabel = L"Gas mass %$m_unit"
    elseif type == "stars"
        ylabel = L"Star mass %$m_unit"
    elseif type == "dark_matter"
        ylabel = L"Dark matter mass %$m_unit"
    end

    return plot(
        r,
        m,
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.1, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    massProfilePlot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make an accumulated mass profile plot of several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Return values of the positionData function.
- `mass_data::Vector{Dict{String, Any}}`: Return values of the massData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if factor = 10 
  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function massProfilePlot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    pgfplotsx()

    # Extract data from arguments and check consistency.
    types = get.(mass_data, "type", 0)
    if !all(x -> x == types[1], types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(x -> x == length_units[1], length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    if !all(x -> x == mass_units[1], mass_units)
        error("The units of mass are not the same among datasets.")
    else
        mass_unit = mass_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(x -> x == periodicities[1], periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    masses = get.(mass_data, "mass", 0)
    positions = get.(position_data, type, 0)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles.
            push!(distances, [Inf])
        else
            push!(distances, sqrt.(pos[1, :] .^ 2 .+ pos[2, :] .^ 2 .+ pos[3, :] .^ 2))
        end
    end

    if periodicity
        # For periodic boundary conditions.
        max_rs = (get.(position_data, "box_size", 0) ./ 2) .* box_factor
    else
        # Plotting region for vacuum boundary conditions.
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    m = Vector{Float64}[]
    for (mass, distance, max_r) in zip(masses, distances, max_rs)
        r_result, m_result = massProfile(mass, distance, max_r, bins)
        # Scale data by 10^factor.
        m_result ./= 10^factor

        push!(r, r_result)
        push!(m, m_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0, m)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting.
            @inbounds for i in eachindex(r, m)
                deleteat!(r[i], m[i] .<= 0)
                filter!(x -> x > 0, m[i])
            end

            # Fill the datasets with NaN so all have the same length.
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(m[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale.
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label.
    m_unit = string(mass_unit)
    if factor != 0
        m_unit = replace(
            m_unit,
            "M⊙" => L"\, / \ \left(10^{%$factor} \, \mathrm{M}_{\odot}\right)",
        )
    else
        m_unit = replace(m_unit, "M⊙" => L"\, / \ \mathrm{M}_{\odot}")
    end

    if type == "gas"
        ylabel = L"Gas mass %$m_unit"
    elseif type == "stars"
        ylabel = L"Star mass %$m_unit"
    elseif type == "dark_matter"
        ylabel = L"Dark matter mass %$m_unit"
    end

    return plot(
        hcat(r...),
        hcat(m...),
        xlabel = "r / $length_unit",
        ylabel = ylabel,
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :bottomright,
        lw = 3,
        linestyle = :auto,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        legendfontsize = 25,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.1, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    sfrTxtPlot(
        data::Dict{Union{Int64, String}, Any},
        x_axis::Int64,
        y_axis::Vector{Int64}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of column `y_axis` vs. column `x_axis`, of the sfr.txt text file.

# Warning 
THIS FUNCTION NEEDS A FILE (sfr.txt) WHICH IS NOT PRODUCED BY ANY PUBLIC VERSION OF GADGET.

# Arguments
- `data::Dict{Union{Int64, String}, Any}`: Return values of the sfrTxtData function.
- `x_axis::Int64`: Column number for the x axis.
- `y_axis::Vector{Int64}`: Vector of columns numbers for the y axis.
- `title::String = ""`: Title for the figure. If an empty string is given
  no title is printed, which is the default.
- `bins::Int64 = 0`: Number of subdivisions for the smoothing of the data. 
  The default is Inf, i.e. no smoothing.
- `scale::NTuple{2, Symbol} = (:identity, :identity)`: Scaling to be used for the x 
  and y axes. The two options are:
  :identity => no scaling.
  :log10 => logarithmic scaling.
- `min_filter::NTuple{2, Float64} = (-Inf, -Inf)`: Value filter for the x and y axes.
  If a value of the x data is lower than min_filter[1], then it is deleted. Equivalently 
  with the y axis and min_filter[2]. The default is -Inf for both, i.e. no filtering.

# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function sfrTxtPlot(
    data::Dict{Union{Int64, String}, Any},
    x_axis::Int64,
    y_axis::Vector{Int64};
    title::String = "",
    bins::Int64 = 0,
    scale::NTuple{2, Symbol} = (:identity, :identity),
    min_filter::NTuple{2, Float64} = (-Inf, -Inf),
)::Plots.Plot

    pgfplotsx()

    # Get the units.
    mass_unit = data["units"]["mass"]
    time_unit = data["units"]["time"]
    sfr_unit = data["units"]["sfr"]

    # Formatting for the axes labels.
    m_unit = replace(string(mass_unit), "M⊙" => L"\, / \mathrm{M}_{\odot}")
    str_sfr_unit = replace(
        replace(string(sfr_unit), "M⊙" => L"$\, / \ \left(\mathrm{M_{\odot} \,"),
        "^-1" => L"^{-1}}\right)$",
    )

    # Strings for the legends.
    labels = [
        "t / $time_unit",
        "Mass $m_unit",
        "SFR $str_sfr_unit",
        "SFR $str_sfr_unit",
        "Mass $m_unit",
        "SFR $str_sfr_unit",
    ]

    # Configuration of the parameters for the plot.
    figure = plot(
        xscale = scale[1],
        yscale = scale[2],
        xlabel = labels[x_axis],
        ylabel = labels[y_axis[1]],
        title = title,
        legend = :bottomright,
        palette = :Set1_9,
        framestyle = :box,
        size = (1200, 700),
        titlefontsize = 28,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 24,
        yguidefontsize = 24,
        legendfontsize = 25,
    )

    for y_type in y_axis
        x_data = data[x_axis[1]]
        y_data = data[y_type]

        # Data smoothing.
        if bins != 0
            x_data, y_data = smoothWindow(x_data, y_data, bins)
        end

        # Filter data points <= 0, to allow logarithmic plotting.
        if scale[1] == :log10
            deleteat!(y_data, x_data .<= 0)
            filter!(x -> x > 0, x_data)
        end
        if scale[2] == :log10
            deleteat!(x_data, y_data .<= 0)
            filter!(x -> x > 0, y_data)
        end

        # Filter data points < `min_filter`.
        deleteat!(y_data, x_data .< min_filter[1])
        filter!(x -> x > min_filter[1], x_data)
        deleteat!(x_data, y_data .< min_filter[2])
        filter!(x -> x > min_filter[2], y_data)

        plot!(
            figure,
            x_data,
            y_data,
            label = "Column $y_type",
            lw = 3,
            linestyle = :auto,
            foreground_color_legend = nothing,
            background_color_legend = nothing,
            ticklabel_shift = ".1cm",
            extra_kwargs = :subplot,
        )
    end

    return figure
end

"""
    temperatureHistogramPlot(
        temperature_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a histogram of the logarithm of the gas particles' temperatures.

# Arguments
- `temperature_data::Dict{String,Any}`: Return value of the tempData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64 = 20`: Number of bins to use in the histogram.
	
# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function temperatureHistogramPlot(
    temperature_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 20,
)::Plots.Plot

    pgfplotsx()

    T = temperature_data["T"]
    temp_unit = temperature_data["unit"]

    # Non zero check.
    if any(x -> isequal(x, 0.0), T)
        error("There are temperatures equal to 0!.")
    end

    # Set logarithmic scaling.
    T = log10.(T)

    # Formatting for the x axis label.
    xlabel = L"\log_{10}(\mathrm{T} \, / \, \mathrm{%$temp_unit})"

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    return histogram(
        T,
        bins = range(0, stop = maximum(T), length = bins),
        xlabel = xlabel,
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.1, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    rhoTempPlot(
        temperature_data::Dict{String, Any},
        density_data::Dict{String, Any},
        time::Unitful.Quantity,
    )::Plots.Plot

Make a plot of log10(ρ) vs. log10(T), for the gas particles at a given time step.

# Arguments
- `temperature_data::Dict{String,Any}`: Return value of the tempData function.
- `density_data::Dict{String, Any}`: Return value of the densityData function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.
	
# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function rhoTempPlot(
    temperature_data::Dict{String, Any},
    density_data::Dict{String, Any},
    time::Unitful.Quantity,
)::Plots.Plot

    pgfplotsx()

    T = temperature_data["T"]
    temp_unit = temperature_data["unit"]
    ρ = density_data["gas_density"]
    density_unit = string(density_data["unit"])

    # Non zero check.
    if any(x -> isequal(x, 0.0), T)
        error("There are temperatures equal to 0!.")
    end
    if any(x -> isequal(x, 0.0), ρ)
        error("There are densities equal to 0!.")
    end

    # Set logarithmic scaling.
    T = log10.(T)
    ρ = log10.(ρ)

    # Formatting for the x axis label.
    xlabel = L"\log_{10}(\mathrm{T} \, / \, \mathrm{%$temp_unit})"

    # Formatting for the y axis label.
    ylabel = replace(
        replace(
            density_unit, 
            "M⊙" => L"$\log_{10}\!\left(\rho \, / \, \mathrm{M_{\odot} \,",
        ),
        "^-3" => L"^{-3}}\right)$",
    )

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    return scatter(
        T,
        ρ;
        xlabel,
        ylabel,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        markersize = 2,
        markerstrokealpha = 0,
        markercolor = :darkorange2,
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$time_unit};",
        extra_kwargs = :subplot,
    )
end

"""
    KennicuttSchmidtPlot(
        gas_mass_data::Dict{String, Any},
        temperature_data::Dict{String, Any},
        star_mass_data::Dict{String, Any},
        age_data::Dict{String, Any},
        pos_data::Dict{String, Any},
        temp_filter::Unitful.Quantity,
        age_filter::Unitful.Quantity,
        max_r::Unitful.Quantity,
        time::Unitful.Quantity;
        <keyword arguments>
    )::Plots.Plot

Make a plot of the Kennicutt-Schmidt law for a given snapshot, with its fit and 
the measured values superimposed for comparison. 

# Arguments
- `gas_mass_data::Dict{String, Any}`: Return value of the massData function, for gas.
- `temperature_data::Dict{String, Any}`: Return value of the tempData function.
- `star_mass_data::Dict{String, Any}`: Return value of the massData function, for stars.
- `age_data::Dict{String, Any}`: Return value of the ageData function.
- `pos_data::Dict{String, Any}`: Return value of the positionData function.
- `temp_filter::Unitful.Quantity`: Maximum temperature allowed for the gas particles.
- `age_filter::Unitful.Quantity`: Maximum star age allowed for the calculation of the SFR. 
  It should aproximately equal to the time step of the snapshots.
- `max_r::Float64`: Maximum distance up to which the parameters will be calculated.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
- `bins::Int64 = 50`: Number of subdivisions of [0, `max_r`] to be used. 
  It has to be at least 5.
- `error_formating::String = "std_error"`: What to print as error values.
  The options are:
  "std_error": `mean ± standard_error`.
  "conf_interval": `mean ± max(upper_95% - mean, mean - lower_95%)`.
	
# Returns
- The plot generated by the PGFPlotsX backend of Plots.jl.
"""
function KennicuttSchmidtPlot(
    gas_mass_data::Dict{String, Any},
    temperature_data::Dict{String, Any},
    star_mass_data::Dict{String, Any},
    age_data::Dict{String, Any},
    pos_data::Dict{String, Any},
    temp_filter::Unitful.Quantity,
    age_filter::Unitful.Quantity,
    max_r::Unitful.Quantity,
    time::Unitful.Quantity;
    bins::Int64 = 50,
    error_formating::String = "std_error",
)::Union{Plots.Plot, Nothing}

    pgfplotsx()

    # Masses.
    gas_mass = gas_mass_data["mass"]
    gas_mass_unit = gas_mass_data["unit"]
    
    star_mass = star_mass_data["mass"]
    star_mass_unit = star_mass_data["unit"]

    # Unit consistency check.
    gas_mass_unit == star_mass_unit || error("Star and gas mass units must be the same.")

    # Positions.
    gas_pos = pos_data["gas"]
    star_pos = pos_data["stars"]
    length_unit = pos_data["unit"]
    max_R = ustrip(Float64, length_unit, max_r)
    dist_gas = sqrt.(gas_pos[1, :] .^ 2 + gas_pos[2, :] .^ 2)
    dist_stars = sqrt.(star_pos[1, :] .^ 2 + star_pos[2, :] .^ 2)

    # Temperatures
    gas_temp = temperature_data["T"]
    temp_unit = temperature_data["unit"]
    T_filter = ustrip(Float64, temp_unit, temp_filter)

    # Ages.
    star_age = age_data["ages"]
    time_unit = age_data["unit"]
    time_filter = ustrip(Float64, time_unit, age_filter)

    ksl = KennicuttSchmidtLaw(
        gas_mass,
        dist_gas,
        gas_temp,
        star_mass,
        dist_stars,
        star_age,
        T_filter,
        time_filter,
        max_R;
        bins,
    )

    if ksl === nothing
        return nothing
    end

    # Data to be plotted.
    density_data = ksl["RHO"]
    sfr_data = ksl["SFR"]

    # Get linear fit.
    linear_model = ksl["LM"]
    # Mean values.
    coeff = coef(linear_model)
    mean_intercept = coeff[1]
    mean_slope = coeff[2]
    # Errors.
    errors = stderror(linear_model)
    conf_intval = confint(linear_model)
    interval_intercept = maximum(
        [conf_intval[1,2] - mean_intercept, mean_intercept - conf_intval[1,1]]
    )
    interval_slope = maximum([conf_intval[2,2] - mean_slope, mean_slope - conf_intval[2,1]])

    # Sets the slope and intercept with the right number of digits for display.
    if error_formating == "conf_interval"
        intercept, intercept_error = format_error(mean_intercept, interval_intercept)
        slope, slope_error = format_error(mean_slope, interval_slope)
    else
        intercept, intercept_error = format_error(mean_intercept, errors[1])
        slope, slope_error = format_error(mean_slope, errors[2])
    end

    # Formatting for the x axis label.
    density_unit = gas_mass_unit / length_unit^2
    xlabel = replace(
        replace(
            string(density_unit), 
            "M⊙" => L"$\log_{10}\!\left(\Sigma_\mathrm{gas} \, / \, \mathrm{M_{\odot} \,",
        ),
        "^-2" => L"^{-2}}\right)$",
    )

    # Formatting for the y axis label.
    sfr_unit = gas_mass_unit / time_unit /length_unit^2
    ylabel = replace(
        replace(
            replace(
                string(sfr_unit), 
                "M⊙" => L"$\log_{10}\!\left(\Sigma_\mathrm{SFR} \, / \, \mathrm{M_{\odot} \,",
            ),
            "^-1" => "^{-1} \\,",
        ), 
        "^-2" => L"^{-2}}\right)$",
    )

    # Magnitude and unit for the time stamp.
    clock = round(ustrip(time), sigdigits = 4)
    clock_unit = unit(time)

    # Scatter plot of the simulated data.
    figure = scatter(
        density_data, 
        sfr_data, 
        label = "Simulation", 
        xlabel = xlabel, 
        ylabel = ylabel,
        size = (1200, 1000),
        framestyle = :box,
        xtickfontsize = 28,
        ytickfontsize = 28,
        xguidefontsize = 30,
        yguidefontsize = 30,
        legendfontsize = 25,
        markersize = 6,
        markercolor = :darkorange2,
        legend = :bottomright,
        background_color_legend = nothing,
        foreground_color_legend = nothing,
    )

    # Comparison line with the measured values by Kennicutt (1998).
    sorted_density = sort(density_data)
	KS_intercept = ustrip(Float64, sfr_unit, KENNICUTT98_INTERCEPT)
	KS_intercept *= ustrip(Float64, density_unit, KENNICUTT98_RHO_UNIT)^(-KENNICUTT98_SLOPE)
	y_KS_98 = log10(KS_intercept) .+ KENNICUTT98_SLOPE .* sorted_density

    plot!(
        figure, 
        sorted_density, 
        y_KS_98, 
        ls = :auto,
        lw = 3,
        color = :blueviolet,
        label = "Kennicutt 1998",
    )

    # Linear fit plot.
    plot!(
        figure, 
        density_data, 
        predict(linear_model), 
        lw = 3,
        color = :red,
        label = "Fit",
        ticklabel_shift = ".1cm",
        add = "\\node[font=\\Huge\\ttfamily] at (rel axis cs: 0.5, 0.95) {$clock\$\\,\$$clock_unit};",
        extra_kwargs = :subplot,
    )

    # Annotations with the fitted parameters and its errors.
    annotate!(
        relative(figure, 0.05, 0.95)...,
        text(
            L"\Sigma_\mathrm{SFR} = \mathrm{A}\,\Sigma_\mathrm{gas}^{\,\mathrm{N}}", 
            20, 
            :left,
        ),
    )
    annotate!(
        relative(figure, 0.05, 0.9)...,
        text(
            L"\mathrm{N} = %$slope \pm %$slope_error", 
            "Courier", 
            20, 
            :left,
        ),
    )
    annotate!(
        relative(figure, 0.05, 0.85)...,
        text(
            L"\mathrm{log}_{10}(\mathrm{A}) = %$intercept \pm %$intercept_error",
            20, 
            :left,
        ),
    )

    return figure
end