########################################################################################
# Plotting functions
########################################################################################

"""
    scatter_grid_plot(position_data::Dict{String, Any})::Plots.Plot

Make 9 scatter plots showing the positions of the gas, dark matter and stellar particles 
in the x-y, x-z and y-x planes.
 
The result is a single figure in a 3x3 layout with its axes in the unit given by
`position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the [`get_position`](@ref) function.

# Returns
- The plot generated by the GR backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function scatter_grid_plot(position_data::Dict{String, Any})::Plots.Plot

    # Get gas, dark matter and stellar coordinates
    gas_pos = position_data["gas"]
    gas_x = @view gas_pos[1, :]
    gas_y = @view gas_pos[2, :]
    gas_z = @view gas_pos[3, :]

    dm_pos = position_data["dark_matter"]
    dm_x = @view dm_pos[1, :]
    dm_y = @view dm_pos[2, :]
    dm_z = @view dm_pos[3, :]

    stars_pos = position_data["stars"]
    stars_x = @view stars_pos[1, :]
    stars_y = @view stars_pos[2, :]
    stars_z = @view stars_pos[3, :]

    if position_data["periodic"]
        # For periodic boundary conditions
        stars_size = gas_size = dm_size = position_data["box_size"] / 2.0
    else
        # For vacuum boundary conditions
        stars_size = position_data["box_size"] * 1.1
        dm_size = stars_size * 3.0
        gas_size = stars_size * 7.0
    end

    # Unit for the axes
    unit = position_data["unit"]

    # Plots of the x-y plane
    pl_gas_x_y = scatter(
        gas_x,
        gas_y,
        title = "Gas - xy plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
    )
    pl_dm_x_y = scatter(
        dm_x,
        dm_y,
        title = "Dark matter - xy plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
    )
    pl_stars_x_y = scatter(
        stars_x,
        stars_y,
        title = "Stars - xy plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
    )

    # Plots of the x-z plane
    pl_gas_x_z = scatter(
        gas_x,
        gas_z,
        title = "Gas - xz plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
    )
    pl_dm_x_z = scatter(
        dm_x,
        dm_z,
        title = "Dark matter - xz plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
    )
    pl_stars_x_z = scatter(
        stars_x,
        stars_z,
        title = "Stars - xz plane",
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
    )

    # Plots of the y-z plane
    pl_gas_y_z = scatter(
        gas_y,
        gas_z,
        title = "Gas - yz plane",
        xlabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :blueviolet,
        xlims = (-gas_size, gas_size),
        ylims = (-gas_size, gas_size),
        right_margin = 25px,
    )
    pl_dm_y_z = scatter(
        dm_y,
        dm_z,
        title = "Dark matter - yz plane",
        xlabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :darkgrey,
        xlims = (-dm_size, dm_size),
        ylims = (-dm_size, dm_size),
        right_margin = 25px,
    )
    pl_stars_y_z = scatter(
        stars_y,
        stars_z,
        title = "Stars - yz plane",
        xlabel = L"\mathrm{y} \, / \, \mathrm{%$unit}",
        ylabel = L"\mathrm{z} \, / \, \mathrm{%$unit}",
        markercolor = :darkorange2,
        xlims = (-stars_size, stars_size),
        ylims = (-stars_size, stars_size),
        right_margin = 25px,
    )

    # Final figure containing the nine plots
    return scatter(
        pl_gas_x_y,
        pl_gas_x_z,
        pl_gas_y_z,
        pl_dm_x_y,
        pl_dm_x_z,
        pl_dm_y_z,
        pl_stars_x_y,
        pl_stars_x_z,
        pl_stars_y_z,
        layout = (3, 3),
        size = (2020, 2020),
        aspect_ratio = 1,
        left_margin = 35px,
        framestyle = :box,
        background_color_inside = :black,
        markersize = 2,
        markerstrokewidth = 0,
        legend = false,
        fontfamily = "Computer Modern",
        titlefontsize = 24,
        xtickfontsize = 20,
        ytickfontsize = 20,
        xguidefontsize = 22,
        yguidefontsize = 22,
    )
end

"""
    density_map_plot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        density_data::Dict{String, Any}
        hsml_data::Dict{String, Any}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of the gas density in the x-y, x-z and/or y-z planes. 

The axes are in the units given by `position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the [`get_position`](@ref) function.
- `mass_data::Dict{String,Any}`: Return value of the [`get_mass`](@ref) function.
- `density_data::Dict{String,Any}`: Return value of the [`get_density`](@ref) function.
- `hsml_data::Dict{String,Any}`: Return value of the [`get_hsml`](@ref) function.
- `plane::String = "All"`: String indicating which plane will be plotted. 
  * `"XY"` ⟹ x-y plane alone.
  * `"XZ"` ⟹ x-z plane alone.
  * `"YZ"` ⟹ y-z plane alone.
  * `"All"` ⟹ The three planes in a single 1x3 figure.
- `axes::Bool = false`: If true, the axes passing through (0, 0) are drawn. If false, 
  no axes are drawn.
- `axes_color::Symbol = :white`: Color of the axes passing through (0, 0), only relevant 
  if `axes = true`.
- `color::Symbol = :inferno`: Color scheme for the figure. 
  Any one from [ColorSchemes.jl](https://github.com/JuliaGraphics/ColorSchemes.jl) can be used. Some good ones are `:batlow`, `:bone`, `:CMRmap`, 
  `:grayC`, `:seaborn_rocket_gradient`, `:YlOrRd_9` and `:inferno`, which is the default.

# Returns
- The plot generated by the GR backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function density_map_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    density_data::Dict{String, Any},
    hsml_data::Dict{String, Any};
    plane::String = "All",
    axes::Bool = false,
    axes_color::Symbol = :white,
    color::Symbol = :inferno,
)::Plots.Plot

    # Resolution in pixels for the binning of the grid
    resolution = 1000

    if position_data["periodic"]
        # For periodic boundary conditions
        box_limits = position_data["box_size"] / 2.0
    else
        # For vacuum boundary conditions
        box_limits = position_data["box_size"] * 1.05
    end

    param = mappingParameters(
        x_lim = [-box_limits, box_limits],
        y_lim = [-box_limits, box_limits],
        z_lim = [-box_limits, box_limits],
        Npixels = resolution,
    )

    binning = range(-box_limits, stop = box_limits, length = resolution)
    color_scheme = cgrad(color)
    last_color = color_scheme[1]

    # Spline kernel used inside GADGET2/3
    # 
    #   Monaghan, J. J., & Lattanzio, J. C. (1985). A refined particle method for 
    #   astrophysical problems. Astronomy and Astrophysics, 149(1), 135–143. 
    #   https://ui.adsabs.harvard.edu/abs/1985A&A...149..135M
    # 
    #   Springel, V. (2005). The cosmological simulation code gadget-2. Monthly Notices 
    #   of the Royal Astronomical Society, 364(4), 1105–1134. 
    #   https://doi.org/10.1111/j.1365-2966.2005.09655.x
    kernel = Cubic()

    pos = position_data["gas"]
    mass = mass_data["mass"]

    # Makes sure that all the units are consistent
    length_unit = position_data["unit"]
    mass_unit = mass_data["unit"]
    if hsml_data["unit"] != length_unit
        hsml = @. ustrip(Float64, length_unit, hsml_data["hsml"] * hsml_data["unit"])
    else
        hsml = hsml_data["hsml"]
    end
    if density_data["unit"] != mass_unit / length_unit^3
        ρ = @. ustrip(
            Float64,
            mass_unit / length_unit^3,
            density_data["density"] * density_data["unit"],
        )
    else
        ρ = density_data["density"]
    end

    if plane == "XY" || plane == "All"

        sph_density = log10.(
            sphMapping(
				pos, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        xy_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = L"\mathrm{x} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{y} \, / \, \mathrm{%$length_unit}",
            title = "XY plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            xy_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "XZ" || plane == "All"
        # Active rotation (alibi) of the galaxy, using Euler angles
        # Rx(-90°) Ry(0°) Rz(0°)
        pos_xz = rotate_3D(pos, -90.0, 0.0, 0.0)
        sph_density = log10.(
            sphMapping(
                pos_xz, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        xz_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = L"\mathrm{x} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{z} \, / \, \mathrm{%$length_unit}",
            title = "XZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            xz_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "YZ" || plane == "All"
        # Active rotation (alibi) of the galaxy, using Euler angles
        # Rx(-90°) Ry(0°) Rz(-90°)
        pos_yz = rotate_3D(pos, -90.0, 0.0, -90.0)
        sph_density = log10.(
            sphMapping(
                pos_yz, 
                hsml, 
                mass, 
                ρ, 
                ρ; 
                param, 
                kernel, 
                show_progress = false,
            )
        )

        yz_plot = heatmap(
            binning,
            binning,
            sph_density,
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 20px,
            framestyle = :box,
            xlabel = L"\mathrm{y} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{z} \, / \, \mathrm{%$length_unit}",
            title = "YZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            yz_plot = vline!([0.0], line = (2, axes_color))
        end
    end

    if plane == "XY"
        return xy_plot
    elseif plane == "XZ"
        return xz_plot
    elseif plane == "YZ"
        return yz_plot
    elseif plane == "All"
        # Plot the three planes together
        return plot(
            xy_plot,
            xz_plot,
            yz_plot,
            layout = (1, 3),
            size = (3030, 1000),
            left_margin = 90px,
            right_margin = 40px,
            top_margin = -25px,
            bottom_margin = 40px,
        )
    else
        error("'$plane' is not an option for a plane.")
    end
end

"""
    star_map_plot(position_data::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make a plot of the stellar density in the x-y, x-z and/or y-z planes. 

The axes are in the units given by `position_data["unit"]`.

# Arguments
- `position_data::Dict{String,Any}`: Return value of the [`get_position`](@ref) function.
- `plane::String="All"`: String indicating which plane will be plotted. 
  * `"XY"` ⟹ x-y plane alone.
  * `"XZ"` ⟹ x-z plane alone.
  * `"YZ"` ⟹ y-z plane alone.
  * `"All"` ⟹ The three planes in a single 1x3 figure.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `positions["box_size"]` if vacuum boundary conditions were used, and
  it will scale `positions["box_size"] / 2` if periodic boundary conditions were used.
- `axes::Bool = false`: If true, the axes passing through (0, 0) are drawn. If false, 
  no axes are drawn.
- `axes_color::Symbol = :white`: Color of the axes passing through (0, 0), only relevant 
  if `axes = true`.
- `color::Symbol = :inferno`: Color scheme for the figure. 
  Any one from [ColorSchemes.jl](https://github.com/JuliaGraphics/ColorSchemes.jl) can be used. Some good ones are `:batlow`, `:bone`, `:CMRmap`, 
  `:grayC`, `:seaborn_rocket_gradient`, `:YlOrRd_9` and `:inferno`, which is the default.
  
# Returns
- The plot generated by the GR backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function star_map_plot(
    position_data::Dict{String, Any};
    plane::String = "All",
    box_factor::Float64 = 1.0,
    axes::Bool = false,
    axes_color::Symbol = :white,
    color::Symbol = :inferno,
)::Plots.Plot

    # Get the position data
    pos = position_data["stars"]
    if position_data["periodic"]
        # For periodic boundary conditions
        box_limits = (position_data["box_size"] / 2.0) * box_factor
    else
        # For vacuum boundary conditions
        box_limits = position_data["box_size"] * box_factor
    end

    # Resolution in pixels for the binning of the grid
    resolution = 1000
    # Discretization of the plotting region
    binnig = range(-box_limits, stop = box_limits, length = resolution)

    stars_present = !isempty(pos)
    if stars_present
        # If stars already formed
        x, y, z = pos[1, :], pos[2, :], pos[3, :]
    else
        # If they didn't
        x, y, z = binnig, binnig, zeros(Float64, resolution, resolution)
    end

    # Unit for the axes
    length_unit = position_data["unit"]

    color_scheme = cgrad(color)
    last_color = color_scheme[1]

    if plane == "XY" || plane == "All"
        if stars_present
            density_xy = xyz(ash(x, y, rngx = binnig, rngy = binnig))
            heatmap(density_xy[1], density_xy[2], log10.(density_xy[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            vline!([0.0], line = (2, axes_color))
        end

        xy_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = L"\mathrm{x} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{y} \, / \, \mathrm{%$length_unit}",
            title = "XY plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "XZ" || plane == "All"
        if stars_present
            density_xz = xyz(ash(x, z, rngx = binnig, rngy = binnig))
            heatmap(density_xz[1], density_xz[2], log10.(density_xz[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            vline!([0.0], line = (2, axes_color), legend = false)
        end

        xz_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = L"\mathrm{x} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{z} \, / \, \mathrm{%$length_unit}",
            title = "XZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "YZ" || plane == "All"
        if stars_present
            density_yz = xyz(ash(y, z, rngx = binnig, rngy = binnig))
            heatmap(density_yz[1], density_yz[2], log10.(density_yz[3]))
        else
            heatmap(x, y, z)
        end

        if axes
            hline!([0.0], line = (2, axes_color), legend = false)
            vline!([0.0], line = (2, axes_color), legend = false)
        end

        yz_plot = heatmap!(
            xlim = (-box_limits, box_limits),
            ylim = (-box_limits, box_limits),
            size = (1010, 1010),
            aspect_ratio = 1,
            left_margin = 20px,
            right_margin = 30px,
            framestyle = :box,
            xlabel = L"\mathrm{y} \, / \, \mathrm{%$length_unit}",
            ylabel = L"\mathrm{z} \, / \, \mathrm{%$length_unit}",
            title = "YZ plane",
            fontfamily = "Computer Modern",
            xtickfontsize = 30,
            ytickfontsize = 30,
            xguidefontsize = 35,
            yguidefontsize = 35,
            titlefont = 35,
            color = color_scheme,
            colorbar = false,
            background_color_inside = last_color,
        )
    end

    if plane == "XY"
        return xy_plot
    elseif plane == "XZ"
        return xz_plot
    elseif plane == "YZ"
        return yz_plot
    elseif plane == "All"
        # Plot the three planes together
        return plot(
            xy_plot,
            xz_plot,
            yz_plot,
            layout = (1, 3),
            size = (3030, 1000),
            left_margin = 90px,
            right_margin = 40px,
            top_margin = -25px,
            bottom_margin = 40px,
        )
    else
        error("'$plane' is not an option for a plane.")
    end
end

"""
    gas_star_evolution_plot(
        index::Int64,
        time_series::Dict{String, Any},
        position_data::Dict{String, Any}, 
    )::Plots.Plot

Makes 3 plots, the position of the particles in the x-y plane, the baryonic fractional mass 
and the SFR. The first two for stars and gas. All in a single figure with a 1x2 layout.

The figure is created with the time running from 0 to `time_series["clock_time"][index]`.

# Arguments
- `index::Int64`: Index of the final time step up to which the figure will show the 
  evolution of the variables.
- `time_series::Dict{String,Any}`: Return value of the [`get_time_evolution`](@ref) function.	
- `position_data::Dict{String,Any}`: Return value of the [`get_position`](@ref) function.
	
# Returns
- The plot generated by the GR backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function gas_star_evolution_plot(
    index::Int64,
    time_series::Dict{String, Any},
    position_data::Dict{String, Any}, 
)::Plots.Plot

    # Formatting for the axis' labels
    time_unit = time_series["units"]["time"]
    length_unit = position_data["unit"]
    sfr_unit = string(time_series["units"]["sfr"])
    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
        "^-1" => "^{-1}}\\right)",
    )

    if position_data["periodic"]
        # For periodic boundary conditions
        size = position_data["box_size"] / 2.0
    else
        # For vacuum boundary conditions
        size = position_data["box_size"] * 5.5
    end

    # Raw data
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    gas_bar_frac = time_series["gas_bar_frac"]
    star_bar_frac = time_series["star_bar_frac"]

    # Position data
    gas_x = @view position_data["gas"][1, :]
    gas_y = @view position_data["gas"][2, :]
    stars_x = @view position_data["stars"][1, :]
    stars_y = @view position_data["stars"][2, :]

    # Trimmed data for the animation
    reduced_time = @view t[1:index]
    reduced_sfr = @view sfr[1:index]
    reduced_gas = @view gas_bar_frac[1:index]
    reduced_stars = @view star_bar_frac[1:index]

    baryonic_frac = [reduced_gas reduced_stars]

    # Data for the time stamp
    clock = round(t[index], sigdigits = 4)
    # Upper limit for the time axis label    
    t_end = ceil(t[end]) * 1.025
    # Upper limit for the SFR axis label        
    sfr_end = ceil(maximum(sfr)) * 1.05

    # Fractional baryonic mass plot
    pl_frac = plot(
        reduced_time,
        baryonic_frac,
        xlims = (-t_end * 0.025, t_end),
        ylims = (-0.05, 1.05),
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = "Fractional baryonic mass",
        linestyle = [:solid :dash],
        lw = 4,
        label = ["Gas" "Stars"],
        legend = :bottomright,
        background_color_legend = nothing,
        foreground_color_legend = nothing,
        color = [:blueviolet :darkorange2],
    )

    # SFR plot
    pl_sfr = plot(
        reduced_time,
        reduced_sfr,
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = L"\mathrm{SFR} \, / \, %$sfr_unit",
        legend = false,
        lw = 4,
        xlims = (-t_end * 0.025, t_end),
        ylims = (-sfr_end * 0.05, sfr_end),
        color = :darkorange2,
    )

    # Scatter plot of gas and stars in the x-y plane
    scatter(
        gas_x,
        gas_y,
        xlabel = L"\mathrm{x} \, / \, \mathrm{%$length_unit}",
        ylabel = L"\mathrm{y} \, / \, \mathrm{%$length_unit}",
        xlims = (-size, size),
        ylims = (-size, size),
        aspect_ratio = 1,
        label = "Gas",
        legend = :bottomright,
        markersize = 2,
        markerstrokewidth = 0,
        background_color_inside = :black,
        markercolor = :blueviolet,
        background_color_legend = :black,
    )
    pl_scatter = scatter!(
        stars_x,
        stars_y,
        label = "Stars",
        legend = :bottomright,
        markersize = 2,
        markerstrokewidth = 0,
        markercolor = :darkorange2,
        legendfontcolor = :white,
        background_color_legend = :black,
        foreground_color_legend = nothing,
    )
    annotate!(
        relative(pl_scatter, 0.5, 0.95)...,
        text("$clock $time_unit", "Courier Bold", 25, :white, :center),
    )

    l = @layout [a{0.5w} grid(2, 1)]

    # Final figure containing the three plots
    return plot(
        pl_scatter,
        pl_frac,
        pl_sfr,
        layout = l,
        framestyle = :box,
        size = (2200, 1100),
        left_margin = 60px,
        right_margin = 50px,
        top_margin = 20px,
        bottom_margin = 55px,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 25,
    )
end

"""
    cmdf_plot(
        m_data::Dict{String, Any}, 
        z_data::Dict{String, Any},
        time::Unitful.Quantity;
        <keyword arguments>
    )::Plots.Plot
	
Make a cumulative metallicity distribution function (CMDF) plot, for a given time step.

`m_data` and `z_data` must be in the same units.

# Arguments
- `m_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function.
- `z_data::Dict{String, Any}`: Return value of the [`get_metallicity`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64`: Number of subdivisions of the metallicity to construct the plot.
- `x_norm::Bool = false`: If the x axis will be normalized to its maximum value. 

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function cmdf_plot(
    m_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 50,
    x_norm::Bool = false,
)::Plots.Plot

    # Unit consistency check
    (
        m_data["unit"] == z_data["unit"] ||
        error("Mass and metallicity must be in the same units.")
    )

    # Get the mass data
    mass_data = m_data["mass"]
    metallicity_data = z_data["Z"]

    # Compute the cumulative metallicity distribution function
    max_z = findmax(metallicity_data)
    max_Z = max_z[1] / mass_data[max_z[2]]
    Z, m = compute_cmdf(mass_data, metallicity_data, max_Z, bins; x_norm)

    # x axis label
    if x_norm
        xlabel = L"\mathrm{Z \, / \, Z_{max}}"
    else
        xlabel = "Z"
    end
  
    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    figure = plot(
        Z,
        m,
        xlabel = xlabel,
        ylabel = L"\mathrm{M_{\star}(\!< Z) \, / \, M_{\star}}",
        legend = false,
        framestyle = :box,
        size = (1200, 900),
        lw = 3,
        left_margin = 20px,
        bottom_margin = 20px,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
    )
    annotate!(
        relative(figure, 0.5, 0.05)...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure 
end

"""
    cmdf_plot(
        m_data::Vector{Dict{String, Any}}, 
        z_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2};
        <keyword arguments>
    )::Plots.Plot
	
Make a cumulative metallicity distribution function (CMDF) plot of several datasets, 
for a given time step.

`m_data` and `z_data` must be in the same units.

# Arguments
- `m_data::Vector{Dict{String, Any}}`: Return values of the [`get_mass`](@ref) function.
- `z_data::Vector{Dict{String, Any}}`: Return values of the [`get_metallicity`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `bins::Int64`: Number of subdivisions of the metallicity to construct the plot.
- `x_norm::Bool = false`: If the x axis will be normalized to its maximum value. 

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function cmdf_plot(
    m_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    bins::Int64 = 50,
    x_norm::Bool = false,
)::Plots.Plot

    # Check unit consistency
    mass_units = get.(m_data, "unit", 0)
    if !all(isequal(mass_units[1]), mass_units)
        error("The units of mass are not the same among datasets.")
    else
        m_unit = mass_units[1]
    end

    mass_z_units = get.(z_data, "unit", 0)
    if !all(isequal(mass_z_units[1]), mass_z_units)
        error("The units of metallicity are not the same among datasets.")
    else
        z_unit = mass_z_units[1]
    end

    m_unit == z_unit || error("Mass and metallicity must be in the same units.")

    # Get the mass data
    masses = get.(m_data, "mass", 0)
    metallicities = get.(z_data, "Z", 0)

    Z = Vector{Float64}[]
    m = Vector{Float64}[]
    for (mass, metallicity) in zip(masses, metallicities)
        # Compute the cumulative metallicity distribution function
        max_z = findmax(metallicity)
        max_Z = max_z[1] / mass[max_z[2]]
        Z_result, m_result = compute_cmdf(mass, metallicity, max_Z, bins; x_norm)

        push!(Z, Z_result)
        push!(m, m_result)
    end

    # x axis label
    if x_norm
        xlabel = L"\mathrm{Z \, / \, Z_{max}}"
    else
        xlabel = "Z"
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    figure = plot(
        hcat(Z...),
        hcat(m...),
        xlabel = xlabel,
        ylabel = L"\mathrm{M_{\star}(\!< Z) \, / \, M_{\star}}",
        label = labels,
        framestyle = :box,
        size = (1200, 900),
        legend = :bottomright,
        lw = 3,
        linestyle = :auto,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        left_margin = 20px,
        bottom_margin = 20px,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.05)...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure 
end

"""
    birth_histogram_plot(birth_data::Dict{String, Any}; <keyword arguments>)::Plots.Plot

Make a histogram of the number of stars born at a certain radial distance.

# Arguments
- `birth_data::Dict{String, Any}`: Return value of the [`get_birth_place`](@ref) function.
- `bins::Int64 = 50`: Number of bins to use in the histogram.
	
# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function birth_histogram_plot(birth_data::Dict{String, Any}; bins::Int64 = 50)::Plots.Plot

    pos = birth_data["birth_place"]
    length_unit = birth_data["unit"]
    distances = [norm(col) for col in eachcol(pos)]

    return histogram(
        distances;
        bins = range(0, stop = maximum(distances), length = bins),
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
    )
end

@doc raw"""
    time_series_plot(time_series::Dict{String, Any}; <keyword arguments>)::Plots.Plot

Make four line plots of the number of particles, the total mass, the baryonic fractional 
mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.

All the plots show the evolution of the corresponding parameter versus time.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the [`get_time_evolution`](@ref) function.
- `mass_factor::Int64 = 0`: Numerical exponent to scale the mass, 
  e.g. if `mass_factor` = 10, the corresponding axis will be scaled by ``10^{10}``.
- `number_factor::Int64 = 0`: Numerical exponent to scale the number of particles, 
  e.g. if `number_factor` = 4, the corresponding axis will be scaled by ``10^4``.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function time_series_plot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    # Formatting for the axes' labels
    time_unit = time_series["units"]["time"]
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
        "^-1" => "^{-1}}\\right)",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$mass_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => "\\mathrm{M}_{\\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles
    if number_factor != 0
        ylabel_num = L"\mathrm{Number \ of \ particles} \, / \, 10^{%$number_factor}"
    else
        ylabel_num = "Number of particles"
    end

    # Data to be plotted
    t = time_series["clock_time"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10.0^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10.0^mass_factor

    # Number of stars and gas particles vs. time
    pl_number = plot(
        t,
        number,
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Mass of stars and gas vs. time
    pl_mass = plot(
        t,
        mass,
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = L"\mathrm{Total \ mass} \, / \, %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Baryonic fraction of stars and gas vs. time
    pl_frac = plot(
        t,
        baryonic_frac,
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # SFR vs. time
    pl_sfr = plot(
        t,
        sfr,
        xlabel = L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        ylabel = L"\mathrm{SFR} \, / \, %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
    )

    # Final figure containing the four plots
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        right_margin = 25px,
        left_margin = 60px,
        top_margin = 20px,
        bottom_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 28,
    )
end

@doc raw"""
    scale_factor_series_plot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots of the number of particles, the total mass, the baryonic fractional 
mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.

All the plots show the evolution of the corresponding parameter versus the scale factor.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the [`get_time_evolution`](@ref) function.
- `mass_factor::Int64 = 0`: Numerical exponent to scale the mass, 
  e.g. if `mass_factor` = 10, the corresponding axis will be scaled by ``10^{10}``.
- `number_factor::Int64 = 0`: Numerical exponent to scale the number of particles, 
  e.g. if `number_factor` = 4, the corresponding axis will be scaled by ``10^4``.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function scale_factor_series_plot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    # Formatting for the axes' labels
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
        "^-1" => "^{-1}}\\right)",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$mass_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => "\\mathrm{M}_{\\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles
    if number_factor != 0
        ylabel_num = L"\mathrm{Number \ of \ particles} \, / \, 10^{%$number_factor}"
    else
        ylabel_num = "Number of particles"
    end

    # Data to be plotted
    a = time_series["scale_factor"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10.0^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10.0^mass_factor

    # Number of stars and gas particles vs. scale factor
    pl_number = plot(
        a,
        number,
        xlabel = "Scale factor",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Mass of stars and gas vs. scale factor
    pl_mass = plot(
        a,
        mass,
        xlabel = "Scale factor",
        ylabel = L"\mathrm{Total \ mass} \, / \, %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Baryonic fraction of stars and gas vs. scale factor
    pl_frac = plot(
        a,
        baryonic_frac,
        xlabel = "Scale factor",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # SFR vs. scale factor
    pl_sfr = plot(
        a,
        sfr,
        xlabel = "Scale factor",
        ylabel = L"\mathrm{SFR} \, / \, %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
    )

    # Final figure containing the four plots
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        right_margin = 25px,
        left_margin = 60px,
        top_margin = 20px,
        bottom_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 28,
    )
end

@doc raw"""
    redshift_series_plot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot

Make four line plots of the number of particles, the total mass, the baryonic fractional 
mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.

All the plots show the evolution of the corresponding parameter versus the redshift.

# Arguments
- `time_series::Dict{String,Any}`: Return value of the [`get_time_evolution`](@ref) function.
- `mass_factor::Int64 = 0`: Numerical exponent to scale the mass, 
  e.g. if `mass_factor` = 10, the corresponding axis will be scaled by ``10^{10}``.
- `number_factor::Int64 = 0`: Numerical exponent to scale the number of particles, 
  e.g. if `number_factor` = 4, the corresponding axis will be scaled by ``10^4``.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function redshift_series_plot(
    time_series::Dict{String, Any};
    mass_factor::Int64 = 0,
    number_factor::Int64 = 0,
)::Plots.Plot

    # Formatting for the axes' labels
    sfr_unit = string(time_series["units"]["sfr"])
    mass_unit = string(time_series["units"]["mass"])

    sfr_unit = replace(
        replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
        "^-1" => "^{-1}}\\right)",
    )

    if mass_factor != 0
        mass_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$mass_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        mass_unit = replace(mass_unit, "M⊙" => "\\mathrm{M}_{\\odot}")
    end

    # Y axis label formatting, for the plot of the number of particles
    if number_factor != 0
        ylabel_num = L"\mathrm{Number \ of \ particles} \, / \, 10^{%$number_factor}"
    else
        ylabel_num = "Number of particles"
    end

    # Data to be plotted
    z = time_series["redshift"]
    sfr = time_series["sfr"]
    baryonic_frac = [time_series["gas_bar_frac"] time_series["star_bar_frac"]]
    number = [time_series["gas_number"] time_series["star_number"]] ./ 10.0^number_factor
    mass = [time_series["gas_mass"] time_series["star_mass"]] ./ 10.0^mass_factor

    # Number of stars and gas particles vs. redshift
    pl_number = plot(
        z,
        number,
        xlabel = "Redshift",
        ylabel = ylabel_num,
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Mass of stars and gas vs. redshift
    pl_mass = plot(
        z,
        mass,
        xlabel = "Redshift",
        ylabel = L"\mathrm{Total \ mass} \, / \, %$mass_unit",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # Baryonic fraction of stars and gas vs. redshift
    pl_frac = plot(
        z,
        baryonic_frac,
        xlabel = "Redshift",
        ylabel = "Fractional baryonic mass",
        label = ["Gas" "Stars"],
        linestyle = [:solid :dash],
        legend = :bottomright,
        color = [:blueviolet :darkorange2],
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )

    # SFR vs. redshift
    pl_sfr = plot(
        z,
        sfr,
        xlabel = "Redshift",
        ylabel = L"\mathrm{SFR} \, / \, %$sfr_unit",
        legend = false,
        linecolor = :darkorange2,
    )

    # Final figure containing the four plots
    return plot(
        pl_number,
        pl_mass,
        pl_frac,
        pl_sfr,
        layout = (2, 2),
        right_margin = 25px,
        left_margin = 60px,
        top_margin = 20px,
        bottom_margin = 35px,
        framestyle = :box,
        size = (2000, 1200),
        lw = 4,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 28,
    )
end

@doc raw"""
    compare_simulations_plot(
        data::Vector{Dict{String, Any}},
        x_quantity::String,
        y_quantity::String,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot comparing `y_quantity` vs. `x_quantity` of several simulations.

The data of each simulation must be in the same units, and `x_quantity` and `y_quantity` 
can be any magnitude used in the [`get_time_evolution`](@ref) function, namely:

- "scale_factor"                  
- "redshift"                  
- "clock_time" (Physical time)
- "sfr" (SFR) 			              
- "sfr_prob" (SFR probability - Not normalized) 			           
- "gas_number" (Gas particle number) 	            
- "dm_number" (Dark matter particle number)		               
- "star_number" (Star number)         
- "gas_mass" (Total gas mass)               
- "dm_mass" (Total dark matter mass)	            
- "star_mass" (Total star mass)	
- "gas_density" (Global gas density)	               
- "gas_frac" (Gas fraction)		                
- "dm_frac" (Dark matter fraction)		                
- "star_frac" (Star fraction)	                   
- "gas\_bar\_frac" (Baryonic gas fraction)                  
- "star\_bar\_frac" (Baryonic star fraction)

# Arguments
- `data::Vector{Dict{String,Any}}`: Return value of the [`get_time_evolution`](@ref) function for 
  every simulation in a Vector, e.g. [data\_sim1, data\_sim2].
- `x_quantity::String`: Physical magnitude for the x axis. 
- `y_quantity::String`: Physical magnitude for the y axis.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.
- `x_factor::Int64 = 0`: Numerical exponent to scale the `x_quantity`, e.g. if `x_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `y_factor::Int64 = 0`: Numerical exponent to scale the `y_quantity`, e.g. if `y_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `scale::NTuple{2, Symbol} = (:identity, :identity)`: Scaling to be used for the x 
  and y axes. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `smooth_data::Bool = false`: If true a smoothing window with no weighs is applied to 
  the y data. If false, no transformation occurs.
- `bins::Int64 = 0`: Number of subdivisions for the smoothing of the data, only relevant if
  `smooth_data = true`. 
- `legend_pos::Symbol = :bottomright`: Position of the legend, e.g. `:topleft`.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function compare_simulations_plot(
    data::Vector{Dict{String, Any}},
    x_quantity::String,
    y_quantity::String,
    labels::Array{String, 2};
    title::String = "",
    x_factor::Int64 = 0,
    y_factor::Int64 = 0,
    scale::NTuple{2, Symbol} = (:identity, :identity),
    smooth_data::Bool = false,
    bins::Int64 = 50,
    legend_pos::Symbol = :best,
)::Plots.Plot

    # Extract data and scale it by 10^factor
    x_data = collect(get.(data, x_quantity, 0)) ./ 10.0^x_factor
    y_data = collect(get.(data, y_quantity, 0)) ./ 10.0^y_factor

    if smooth_data
        # If required, smooth the data with a moving window
        smooth_data = map(
            (x, y) -> smooth_window(x, y, bins; log = (scale[1] == :log10)),
            x_data,
            y_data,
        )
        x_data = [x[1] for x in smooth_data]
        y_data = [y[2] for y in smooth_data]
    end

    xscale = scale[1]
    yscale = scale[2]

    # Data filtering for y axis logarithmic plotting
    if scale[2] == :log10
        length_short_cases = minimum(length.(findall.(z -> z > 0.0,y_data)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(x_data, y_data)
                deleteat!(x_data[i], y_data[i] .<= 0.0)
                filter!(z -> z > 0.0, y_data[i])
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            yscale = :identity
        end
    end

    # Data filtering for x axis logarithmic plotting
    if scale[1] == :log10
        length_short_cases = minimum(length.(findall.(z -> z > 0.0, x_data)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(x_data, y_data)
                deleteat!(y_data[i], x_data[i] .<= 0.0)
                filter!(z -> z > 0.0, x_data[i])
            end
            
        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            xscale = :identity
        end
    end

    # Fill the datasets with NaN so all have the same length
    max_length = maximum(length.(x_data))
    for (i, l_r) in enumerate(length.(x_data))
        if l_r < max_length
            @inbounds for _ in 1:(max_length - l_r)
                push!(x_data[i], NaN)
                push!(y_data[i], NaN)
            end
        end
    end

    # Unit formatting for the x axis
    if x_quantity == "clock_time"

        unit = data[1]["units"]["time"]

        if x_factor != 0
            x_unit = "\\left(10^{$x_factor} \\, \\mathrm{$unit}\\right)"
        else
            x_unit = unit
        end

    elseif x_quantity == "sfr"

        unit = string(data[1]["units"]["sfr"])

        if x_factor != 0
            x_unit = replace(
                replace(
                    unit, 
                    "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
                ),
                "^-1" => "^{-1}}\\right)",
            )
        else
            x_unit = replace(
                replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
                "^-1" => "^{-1}}\\right)",
            )
        end

    elseif x_quantity == "gas_mass" || x_quantity == "dm_mass" || x_quantity == "star_mass"

        unit = string(data[1]["units"]["mass"])

        if x_factor != 0
            x_unit = replace(
                unit,
                "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot} \\right)",
            )
        else
            x_unit = replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\right)")
        end

    elseif x_quantity == "gas_density"

        unit = string(data[1]["units"]["density"])

        if x_factor != 0
            x_unit = replace(
                replace(
                    unit, 
                    "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
                ),
                "^-3" => "^{-3}}\\right)",
            )
        else
            x_unit = replace(
                replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
                "^-3" => "^{-3}}\\right)",
            )
        end

    elseif x_factor != 0

        x_unit = "10^{$y_factor}"

    else
        x_unit = nothing
    end

    # Unit formatting for the y axis
    if y_quantity == "clock_time"

        unit = data[1]["units"]["time"]

        if y_factor != 0
            y_unit = "\\left(10^{$y_factor} \\, \\mathrm{$unit}\\right)"
        else
            y_unit = unit
        end

    elseif y_quantity == "sfr"

        unit = string(data[1]["units"]["sfr"])

        if y_factor != 0
            y_unit = replace(
                replace(
                    unit, 
                    "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
                ),
                "^-1" => "^{-1}}\\right)",
            )
        else
            y_unit = replace(
                replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
                "^-1" => "^{-1}}\\right)",
            )
        end

    elseif y_quantity == "gas_mass" || y_quantity == "dm_mass" || y_quantity == "star_mass"

        unit = string(data[1]["units"]["mass"])

        if y_factor != 0
            y_unit = replace(
                unit,
                "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot} \\right)",
            )
        else
            y_unit = replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\right)")
        end

    elseif y_quantity == "gas_density"

        unit = string(data[1]["units"]["density"])

        if y_factor != 0
            y_unit = replace(
                replace(
                    unit, 
                    "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
                ),
                "^-3" => "^{-3}}\\right)",
            )
        else
            y_unit = replace(
                replace(unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
                "^-3" => "^{-3}}\\right)",
            )
        end

    elseif y_factor != 0

        y_unit = "10^{$y_factor}"

    else
        y_unit = nothing
    end

    # Labels for the axes
    ylabel = replace(data[1]["labels"][y_quantity], " " => " \\ ")
    xlabel = replace(data[1]["labels"][x_quantity], " " => " \\ ")

    if x_unit === nothing
        x_label = L"\mathrm{%$xlabel} \, / \, \mathrm{%$x_unit}"
    else
        x_label = L"\mathrm{%$xlabel}"
    end

    if y_unit === nothing
        y_label = L"\mathrm{%$ylabel} \, / \, \mathrm{%$y_unit}"
    else
        y_label = L"\mathrm{%$ylabel}"
    end

    return plot(
        hcat(x_data...),
        hcat(y_data...);
        xlabel,
        ylabel,
        xscale = xscale,
        yscale = yscale,
        title,
        label = labels,
        legend = legend_pos,
        framestyle = :box,
        size = (1200, 700),
        lw = 4,
        linestyle = :auto,
        bottom_margin = 30px,
        left_margin = 30px,
        fontfamily = "Computer Modern",
        titlefontsize = 26,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 24,
        yguidefontsize = 24,
        legendfontsize = 22,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
    )
end

@doc raw"""
    density_histogram_plot(
        density_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a histogram with the densities of the gas particles.

# Arguments
- `density_data::Dict{String,Any}`: Return value of the [`get_density`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64 = 20`: Number of bins to use in the histogram.
- `factor::Int64 = 0`: Numerical exponent to scale `density_data`, e.g. if `factor` = 10 
  the y axis will be scaled by ``10^{10}``. The default is no scaling.
- `y_scale::Symbol = :identity`: Scaling to be used for the y axis.
  The two options are:
  * `:identity` ⟶ no scaling.
  * `:log10` ⟶ logarithmic scaling.
	
# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function density_histogram_plot(
    density_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 20,
    factor::Int64 = 0,
    y_scale::Symbol = :identity,
)::Plots.Plot

    # Get the density data
    ρ = density_data["density"]
    # Scale data by 10^factor
    ρ ./= 10^factor

    # Formatting for the x axis label
    str_unit = string(density_data["unit"])
    if factor != 0
        ρ_unit = replace(
            replace(
                str_unit, 
                "M⊙" => "\\left(10^{$factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-3" => "^{-3}}\\right)",
        )
    else
        ρ_unit = replace(
            replace(str_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
            "^-3" => "^{-3}}\\right)",
        )
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    figure = histogram(
        ρ,
        bins = range(0, stop = maximum(ρ), length = bins),
        xlabel = L"\rho \, / \, \mathrm{%$ρ_unit}",
        yscale = y_scale,
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        label = "",
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.95)...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    density_profile_plot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a density profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the [`get_position`](@ref) function.
- `mass_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if `factor` = 10 
  the y axis will be scaled by ``10^{10}``. The default is no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function density_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    type = mass_data["type"]
    masses = mass_data["mass"]

    pos = position_data[type]
    length_unit = position_data["unit"]

    # Set the units
    density_unit = mass_data["unit"] / (length_unit^3)

    if isempty(pos)
        # In the case that there are no particles
        distances = [Inf]
    else
        distances = [norm(col) for col in eachcol(pos)]
    end

    if position_data["periodic"]
        # For periodic boundary conditions
        r_max = (position_data["box_size"] / 2.0) * box_factor
    else
        # Plotting region for vacuum boundary conditions
        r_max = position_data["box_size"] * box_factor
    end

    r, ρ = density_profile(masses, distances, r_max, bins)
    # Scale data by 10^factor
    ρ ./= 10^factor

    if scale == :log10
        positive_rho = findall(x -> x > 0.0, ρ)
        if length(positive_rho) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting
            deleteat!(r, ρ .<= 0.0)
            filter!(x -> x > 0.0, ρ)
        else
            # If the data has less than two positive values, go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = "\\rho_{\\mathrm{gas}}"
    elseif type == "stars"
        ylabel = "\\rho_{\\mathrm{stars}}"
    elseif type == "dark_matter"
        ylabel = "\\rho_{\\mathrm{DM}}"
    end

    # Unit formatting for the y axis label
    ρ_unit = string(density_unit)
    if factor != 0
        y_unit = replace(
            replace(
                ρ_unit, 
                "M⊙" => "\\left(10^{$factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-3" => "^{-3}}\\right)",
        )
    else
        y_unit = replace(
            replace(ρ_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
            "^-3" => "^{-3}}\\right)",
        )
    end

    figure = plot(
        r,
        ρ,
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = L"\mathrm{%$ylabel} \, / \, \mathrm{%$y_unit}",
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
    )
    annotate!(
        relative(figure, 0.5, 0.95, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    density_profile_plot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a density profile plot comparing several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Vector of return values of the [`get_position`](@ref)
  function.
- `mass_data::Vector{Dict{String, Any}}`: Vector of return values of the [`get_mass`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile.
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if `factor` = 10 
  the y axis will be scaled by ``10^{10}``. The default is no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function density_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    # Extract data from arguments and check consistency
    types = get.(mass_data, "type", 0)
    if !all(isequal(types[1]), types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(isequal(length_units[1]), length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    if !all(isequal(mass_units[1]), mass_units)
        error("The units of mass are not the same among datasets.")
    else
        mass_unit = mass_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(isequal(periodicities[1]), periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    masses = get.(mass_data, "mass", 0)
    positions = get.(position_data, type, 0)
    # Set the units.
    density_unit = mass_unit / (length_unit^3.0)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles
            push!(distances, [Inf])
        else
            push!(
                distances, 
                [norm(col) for col in eachcol(pos)],
            )
        end
    end

    if periodicity
        # For periodic boundary conditions
        max_rs = (get.(position_data, "box_size", 0) ./ 2.0) .* box_factor
    else
        # Plotting region for vacuum boundary conditions
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    ρ = Vector{Float64}[]
    for (mass, distance, max_r) in zip(masses, distances, max_rs)
        r_result, ρ_result = density_profile(mass, distance, max_r, bins)
        # Scale data by 10^factor
        ρ_result ./= 10.0^factor

        push!(r, r_result)
        push!(ρ, ρ_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0.0, ρ)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(r, ρ)
                deleteat!(r[i], ρ[i] .<= 0.0)
                filter!(x -> x > 0.0, ρ[i])
            end

            # Fill the datasets with NaN so all have the same length
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(ρ[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = "\\rho_{\\mathrm{gas}}"
    elseif type == "stars"
        ylabel = "\\rho_{\\mathrm{stars}}"
    elseif type == "dark_matter"
        ylabel = "\\rho_{\\mathrm{DM}}"
    end

    # Unit formatting for the y axis label
    ρ_unit = string(density_unit)
    if factor != 0
        y_unit = replace(
            replace(
                ρ_unit, 
                "M⊙" => "\\left(10^{$factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-3" => "^{-3}}\\right)",
        )
    else
        y_unit = replace(
            replace(ρ_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
            "^-3" => "^{-3}}\\right)",
        )
    end

    figure =  plot(
        hcat(r...),
        hcat(ρ...),
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = L"\mathrm{%$ylabel} \, / \, \mathrm{%$y_unit}",
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :topright,
        lw = 3,
        linestyle = :auto,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        palette = :Set1_9,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px, 
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.95, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure 
end

"""
    metallicity_profile_plot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        z_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a metallicity profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the [`get_position`](@ref) function.
- `mass_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function.
- `z_data::Dict{String ,Any}`: Return value of the [`get_metallicity`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function metallicity_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Union{Int64, Nothing} = 100,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    mass_unit = mass_data["unit"]
    z_unit = z_data["unit"]
    if mass_unit != z_unit
        error("The mass units should be the same as the metallicity units.")
    end

    type = mass_data["type"]
    masses = mass_data["mass"]
    metallicity = z_data["Z"]
    pos = position_data[type]
    length_unit = position_data["unit"]

    if isempty(pos)
        # In the case that there are no particles
        distances = [Inf]
    else
        distances = [norm(col) for col in eachcol(pos)]
    end

    if position_data["periodic"]
        # For periodic boundary conditions
        r_max = (position_data["box_size"] / 2.0) * box_factor
    else
        # Plotting region for vacuum boundary conditions
        r_max = position_data["box_size"] * box_factor
    end

    r, z = metallicity_profile(masses, distances, metallicity, r_max, bins)

    if scale == :log10
        positive_z = findall(x -> x > 0.0, z)
        if length(positive_z) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting
            deleteat!(r, z .<= 0.0)
            filter!(x -> x > 0.0, z)

        else
            # If the data has less than two positive values, go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = L"\mathrm{Gas \ Z} \, / \, \mathrm{Z}_{\odot}"
    elseif type == "stars"
        ylabel = L"\mathrm{Star \ Z} \, / \, \mathrm{Z}_{\odot}"
    end

    figure = plot(
        r,
        z,
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = ylabel,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px, 
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
    )
    annotate!(
        relative(figure, 0.5, 0.95, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

"""
    metallicity_profile_plot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        z_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a metallicity profile plot comparing several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Return values of the [`get_position`](@ref) function.
- `mass_data::Vector{Dict{String, Any}}`: Return values of the [`get_mass`](@ref) function.
- `z_data::Vector{Dict{String, Any}}`: Return values of the [`get_metallicity`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function metallicity_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Union{Int64, Nothing} = 100,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    # Extract data from arguments and check consistency
    types = get.(mass_data, "type", 0)
    if !all(isequal(types[1]), types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(isequal(length_units[1]), length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(isequal(periodicities[1]), periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    z_units = get.(z_data, "unit", 0)
    if !all(x -> x[1] == x[2], zip(mass_units, z_units))
        error("The mass units should be the same as the metallicity units.")
    end

    masses = get.(mass_data, "mass", 0)
    metallicities = get.(z_data, "Z", 0)
    positions = get.(position_data, type, 0)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles
            push!(distances, [Inf])
        else
            push!(
                distances, 
                [norm(col) for col in eachcol(pos)],
            )
        end
    end

    if periodicity
        # For periodic boundary conditions
        max_rs = (get.(position_data, "box_size", 0) ./ 2.0) .* box_factor
    else
        # Plotting region for vacuum boundary conditions
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    z = Vector{Float64}[]
    for (mass, distance, metallicity, max_r) in
        zip(masses, distances, metallicities, max_rs)
        r_result, z_result = metallicity_profile(mass, distance, metallicity, max_r, bins)

        push!(r, r_result)
        push!(z, z_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0.0, z)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(r, z)
                deleteat!(r[i], z[i] .<= 0.0)
                filter!(x -> x > 0.0, z[i])
            end

            # Fill the datasets with NaN so all have the same length
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(z[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = L"\mathrm{Gas \ Z} \, / \, \mathrm{Z}_{\odot}"
    elseif type == "stars"
        ylabel = L"\mathrm{Star \ Z} \, / \, \mathrm{Z}_{\odot}"
    end

    return plot(
        hcat(r...),
        hcat(z...),
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = ylabel,
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :topright,
        lw = 3,
        linestyle = :auto,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        palette = :Set1_9,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px, 
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.95, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    mass_profile_plot(
        position_data::Dict{String, Any},
        mass_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make an accumulated mass profile plot for a given time step.

# Arguments
- `position_data::Dict{String, Any}`: Return value of the [`get_position`](@ref) function.
- `mass_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if `factor` = 10 
  the y axis will be scaled by ``10^{10}``. The default is no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function mass_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity;
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    type = mass_data["type"]
    masses = mass_data["mass"]
    mass_unit = mass_data["unit"]

    pos = position_data[type]
    length_unit = position_data["unit"]

    if isempty(pos)
        # In the case that there are no particles
        distances = [Inf]
    else
        distances = [norm(col) for col in eachcol(pos)]
    end

    if position_data["periodic"]
        # For periodic boundary conditions
        r_max = (position_data["box_size"] / 2.0) * box_factor
    else
        # Plotting region for vacuum boundary conditions
        r_max = position_data["box_size"] * box_factor
    end

    r, m = mass_profile(masses, distances, r_max, bins)
    # Scale data by 10^factor
    m ./= 10^factor

    if scale == :log10
        positive_mass = findall(x -> x > 0.0, m)
        if length(positive_mass) >= 2
            # If the data has two or more positive values, filter 
            # data points <= 0, to allow logarithmic plotting
            deleteat!(r, m .<= 0.0)
            filter!(x -> x > 0.0, m)
        else
            # If the data has less than two positive values, go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = "Gas \\ mass"
    elseif type == "stars"
        ylabel = "Stellar \\ mass"
    elseif type == "dark_matter"
        ylabel = "Dark \\ matter \\ mass"
    end

    # Unit formatting for the y axis label
    m_unit = string(mass_unit)
    if factor != 0
        y_unit = replace(
            m_unit,
            "M⊙" => "\\left(10^{$factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        y_unit = replace(m_unit, "M⊙" => L"\\mathrm{M}_{\\odot}")
    end
 
    figure =  plot(
        r,
        m,
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = L"\mathrm{%$ylabel} \, / \, \mathrm{%$y_unit}",
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = false,
        lw = 3,
        color = :red,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px, 
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
    )
    annotate!(
        relative(figure, 0.5, 0.05, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    mass_profile_plot(
        position_data::Vector{Dict{String, Any}},
        mass_data::Vector{Dict{String, Any}},
        time::Unitful.Quantity,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make an accumulated mass profile plot of several datasets, for a given time step.

# Arguments
- `position_data::Vector{Dict{String, Any}}`: Return values of the [`get_position`](@ref) function.
- `mass_data::Vector{Dict{String, Any}}`: Return values of the [`get_mass`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `scale::Symbol = :identity`: Scaling to be used for the y axis. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `bins::Int64 = 100`: Number of subdivisions of the region to be used for the profile. 
- `factor::Int64 = 0`: Numerical exponent to scale the density, e.g. if `factor` = 10 
  the y axis will be scaled by ``10^{10}``. The default is no scaling.
- `box_factor::Float64 = 1.0`: Multiplicative factor for the plotting region. 
  It will scale `position_data["box_size"]` if vacuum boundary conditions were used, and
  it will scale `position_data["box_size"] / 2.0` if periodic boundary conditions were used.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function mass_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    scale::Symbol = :identity,
    bins::Int64 = 100,
    factor::Int64 = 0,
    box_factor::Float64 = 1.0,
)::Plots.Plot

    # Extract data from arguments and check consistency
    types = get.(mass_data, "type", 0)
    if !all(isequal(types[1]), types)
        error("The types of particle are not the same among datasets.")
    else
        type = types[1]
    end

    length_units = get.(position_data, "unit", 0)
    if !all(isequal(length_units[1]), length_units)
        error("The units of length are not the same among datasets.")
    else
        length_unit = length_units[1]
    end

    mass_units = get.(mass_data, "unit", 0)
    if !all(isequal(mass_units[1]), mass_units)
        error("The units of mass are not the same among datasets.")
    else
        mass_unit = mass_units[1]
    end

    periodicities = get.(position_data, "periodic", 0)
    if !all(isequal(periodicities[1]), periodicities)
        error("The boundary conditions are not the same among datasets.")
    else
        periodicity = periodicities[1]
    end

    masses = get.(mass_data, "mass", 0)
    positions = get.(position_data, type, 0)

    distances = Vector{Float64}[]
    for pos in positions
        if isempty(pos)
            # In the case that there are no particles
            push!(distances, [Inf])
        else
            push!(
                distances, 
                [norm(col) for col in eachcol(pos)],
            )
        end
    end

    if periodicity
        # For periodic boundary conditions
        max_rs = (get.(position_data, "box_size", 0) ./ 2.0) .* box_factor
    else
        # Plotting region for vacuum boundary conditions
        max_rs = get.(position_data, "box_size", 0) .* box_factor
    end

    r = Vector{Float64}[]
    m = Vector{Float64}[]
    for (mass, distance, max_r) in zip(masses, distances, max_rs)
        r_result, m_result = mass_profile(mass, distance, max_r, bins)
        # Scale data by 10^factor.
        m_result ./= 10.0^factor

        push!(r, r_result)
        push!(m, m_result)
    end

    if scale == :log10
        length_short_cases = minimum(length.(findall.(x -> x > 0.0, m)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(r, m)
                deleteat!(r[i], m[i] .<= 0.0)
                filter!(x -> x > 0.0, m[i])
            end

            # Fill the datasets with NaN so all have the same length
            max_length = maximum(length.(r))
            for (i, l_r) in enumerate(length.(r))
                if l_r < max_length
                    @inbounds for _ in 1:(max_length - l_r)
                        push!(r[i], NaN)
                        push!(m[i], NaN)
                    end
                end
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            scale = :identity
        end
    end

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    # Formatting for the y axis label
    if type == "gas"
        ylabel = "Gas \\ mass"
    elseif type == "stars"
        ylabel = "Stellar \\ mass"
    elseif type == "dark_matter"
        ylabel = "Dark \\ matter \\ mass"
    end

    # Unit formatting for the y axis label
    m_unit = string(mass_unit)
    if factor != 0
        y_unit = replace(
            m_unit,
            "M⊙" => "\\left(10^{$factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        y_unit = replace(m_unit, "M⊙" => L"\\mathrm{M}_{\\odot}")
    end

    figure =  plot(
        hcat(r...),
        hcat(m...),
        xlabel = L"\mathrm{r} \, / \, \mathrm{%$length_unit}",
        ylabel = L"\mathrm{%$ylabel} \, / \, \mathrm{%$y_unit}",
        label = labels,
        yscale = scale,
        framestyle = :box,
        size = (1200, 800),
        legend = :bottomright,
        lw = 3,
        linestyle = :auto,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px, 
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.05, log = (false, scale == :log10))...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    sfr_txt_plot(
        data::Dict{Union{Int64, String}, Any},
        x_axis::Int64,
        y_axis::Vector{Int64}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of columns `y_axis` vs. column `x_axis` for the data in the sfr.txt file.

!!! warning
    This function takes a modified version of sfr.txt which is produced by a private version of 
    GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.

# Arguments
- `data::Dict{Union{Int64, String}, Any}`: Return values of the [`get_sfr_txt`](@ref) function.
- `x_axis::Int64`: Column number for the x axis.
- `y_axis::Vector{Int64}`: Vector of columns numbers for the y axis.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.
- `bins::Int64 = 0`: Number of subdivisions for the smoothing of the data. 
  The default is `Inf`, i.e. no smoothing.
- `scale::NTuple{2, Symbol} = (:identity, :identity)`: Scaling to be used for the x 
  and y axes. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `x_factor::Int64 = 0`: Numerical exponent to scale the `x_quantity`, e.g. if `x_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `y_factor::Int64 = 0`: Numerical exponent to scale the `y_quantity`, e.g. if `y_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `min_filter::NTuple{2, Float64} = (-Inf, -Inf)`: Value filter for the x and y axes.
  If a value of the x data is lower than `min_filter[1]`, then it is deleted. Equivalently 
  with the y axis and `min_filter[2]`. The default is `-Inf` for both, i.e. no filtering.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function sfr_txt_plot(
    data::Dict{Union{Int64, String}, Any},
    x_axis::Int64,
    y_axis::Vector{Int64};
    title::String = "",
    bins::Int64 = 0,
    scale::NTuple{2, Symbol} = (:identity, :identity),
    x_factor::Int64 = 0,
    y_factor::Int64 = 0,
    min_filter::NTuple{2, Float64} = (-Inf, -Inf),
)::Plots.Plot

    # Get the units
    mass_unit = string(data["units"]["mass"])
    time_unit = string(data["units"]["time"])
    sfr_unit = string(data["units"]["sfr"])
     
    # Formatting for the axes' labels
    mass_condition_x = x_factor != 0 && (x_axis == 2 || x_axis == 5)
    mass_condition_y = y_factor != 0 && (2 in y_axis || 5 in y_axis)
    if mass_condition_x
        m_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    elseif mass_condition_y
        m_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        m_unit = replace(mass_unit, "M⊙" => "\\mathrm{M}_{\\odot}")
    end

    sfr_condition_x = x_factor != 0 && (x_axis == 3 || x_axis == 4 || x_axis == 6)
    sfr_condition_y = y_factor != 0 && (3 in y_axis || 4 in y_axis|| 6 in y_axis)
    if sfr_condition_x
        str_sfr_unit = replace(
            replace(
                sfr_unit, 
                "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-1" => "^{-1}}\\right)",
        )
    elseif sfr_condition_y
        str_sfr_unit = replace(
            replace(
                sfr_unit, 
                "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-1" => "^{-1}}\\right)",
        )
    else
        str_sfr_unit = replace(
            replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
            "^-1" => "^{-1}}\\right)",
        )
    end

    # Strings for the legends
    labels = [
        L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        L"\mathrm{Mass} \, / \, \mathrm{%$m_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
        L"\mathrm{Mass} \, / \, \mathrm{%$m_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
    ]

    # Configuration of the parameters for the plot
    figure = plot(
        xscale = scale[1],
        yscale = scale[2],
        xlabel = labels[x_axis],
        ylabel = labels[y_axis[1]],
        title = title,
        legend = :bottomright,
        palette = :Set1_9,
        framestyle = :box,
        size = (1200, 700),
        fontfamily = "Computer Modern",
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px,
        top_margin = 20px, 
        titlefontsize = 25,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 24,
        yguidefontsize = 24,
        legendfontsize = 22,
    )

    for y_type in y_axis
        x_data = data[x_axis]
        y_data = data[y_type]

        # Data smoothing
        if bins != 0
            x_data, y_data = smooth_window(x_data, y_data, bins)
        end

        # Filter data points <= 0.0, to allow logarithmic plotting
        if scale[1] == :log10
            deleteat!(y_data, x_data .<= 0.0)
            filter!(x -> x > 0.0, x_data)
        end
        if scale[2] == :log10
            deleteat!(x_data, y_data .<= 0.0)
            filter!(x -> x > 0.0, y_data)
        end

        # Filter data points < `min_filter`
        deleteat!(y_data, x_data .< min_filter[1])
        filter!(x -> x > min_filter[1], x_data)
        deleteat!(x_data, y_data .< min_filter[2])
        filter!(x -> x > min_filter[2], y_data)

        x_data = x_data ./ 10.0^x_factor
        y_data = y_data ./ 10.0^y_factor

        plot!(
            figure,
            x_data,
            y_data,
            label = "Column $y_type",
            lw = 3,
            linestyle = :auto,
            foreground_color_legend = nothing,
            background_color_legend = nothing,
        )
    end

    return figure
end

@doc raw"""
    sfr_txt_plot(
        data::Vector{Dict{Union{Int64, String}, Any}},
        x_axis::Int64,
        y_axis::Int64,
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot comparing column `y_axis` vs. column `x_axis` for the data in the sfr.txt file
of several simulations.

!!! warning
    This function takes a modified version of sfr.txt which is produced by a private version of 
    GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.

# Arguments
- `data::Vector{Dict{Union{Int64, String}, Any}}`: Vector of return values of the [`get_sfr_txt`](@ref) function.
- `x_axis::Int64`: Column number for the x axis.
- `y_axis::Int64`: Column number for the y axis.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.
- `bins::Int64 = 0`: Number of subdivisions for the smoothing of the data. 
  The default is `Inf`, i.e. no smoothing.
- `scale::NTuple{2, Symbol} = (:identity, :identity)`: Scaling to be used for the x 
  and y axes. The two options are:
  * `:identity` ⟹ no scaling.
  * `:log10` ⟹ logarithmic scaling.
- `x_factor::Int64 = 0`: Numerical exponent to scale the `x_quantity`, e.g. if `x_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `y_factor::Int64 = 0`: Numerical exponent to scale the `y_quantity`, e.g. if `y_factor` = 10 
  the corresponding axis will be scaled by ``10^{10}``. The default is no scaling.
- `min_filter::NTuple{2, Float64} = (-Inf, -Inf)`: Value filter for the x and y axes.
  If a value of the x data is lower than `min_filter[1]`, then it is deleted. Equivalently 
  with the y axis and `min_filter[2]`. The default is `-Inf` for both, i.e. no filtering.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function sfr_txt_plot(
    data::Vector{Dict{Union{Int64, String}, Any}},
    x_axis::Int64,
    y_axis::Int64,
    labels::Array{String, 2};
    title::String = "",
    bins::Int64 = 0,
    scale::NTuple{2, Symbol} = (:identity, :identity),
    x_factor::Int64 = 0,
    y_factor::Int64 = 0,
    min_filter::NTuple{2, Float64} = (-Inf, -Inf),
)::Plots.Plot

    # Get the units
    units = get.(data, "units", 0)

    # Mass units consistency check
    mass_units = get.(units, "mass", 0)
    if !all(isequal(mass_units[1]), mass_units)
        error("The units of mass are not the same among datasets.")
    else
        mass_unit = string(mass_units[1])
    end

    # Time units consistency check
    time_units = get.(units, "time", 0)
    if !all(isequal(time_units[1]), time_units)
        error("The units of time are not the same among datasets.")
    else
        time_unit = string(time_units[1])
    end

    # SFR units consistency check
    sfr_units = get.(units, "sfr", 0)
    if !all(isequal(sfr_units[1]), sfr_units)
        error("The units of SFR are not the same among datasets.")
    else
        sfr_unit = string(sfr_units[1])
    end
     
    # Formatting for the axes' labels (mass units)
    mass_condition_x = x_factor != 0 && (x_axis == 2 || x_axis == 5)
    mass_condition_y = y_factor != 0 && (y_axis == 2 || y_axis == 5)
    if mass_condition_x
        m_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    elseif mass_condition_y
        m_unit = replace(
            mass_unit,
            "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot}\\right)",
        )
    else
        m_unit = replace(mass_unit, "M⊙" => "\\mathrm{M}_{\\odot}")
    end

    # Formatting for the axes' labels (sfr units)
    sfr_condition_x = x_factor != 0 && (x_axis == 3 || x_axis == 4 || x_axis == 6)
    sfr_condition_y = y_factor != 0 && (y_axis == 3 || y_axis == 4 || y_axis == 6)
    if sfr_condition_x
        str_sfr_unit = replace(
            replace(
                sfr_unit, 
                "M⊙" => "\\left(10^{$x_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-1" => "^{-1}}\\right)",
        )
    elseif sfr_condition_y
        str_sfr_unit = replace(
            replace(
                sfr_unit, 
                "M⊙" => "\\left(10^{$y_factor} \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
            ),
            "^-1" => "^{-1}}\\right)",
        )
    else
        str_sfr_unit = replace(
            replace(sfr_unit, "M⊙" => "\\left(\\mathrm{M}_{\\odot} \\, \\mathrm{"),
            "^-1" => "^{-1}}\\right)",
        )
    end

    # Strings for the axes legends
    axes_labels = [
        L"\mathrm{t} \, / \, \mathrm{%$time_unit}",
        L"\mathrm{Mass} \, / \, \mathrm{%$m_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
        L"\mathrm{Mass} \, / \, \mathrm{%$m_unit}",
        L"\mathrm{SFR} \, / \, \mathrm{%$str_sfr_unit}",
    ]

    x = Vector{Float64}[]
    y = Vector{Float64}[]
    for sim in data
        x_data = sim[x_axis]
        y_data = sim[y_axis]

        # Data smoothing
        if bins != 0
            x_data, y_data = smooth_window(x_data, y_data, bins)
        end
        
        # Data filtering
        deleteat!(y_data, x_data .< min_filter[1])
        filter!(z -> z > min_filter[1], x_data)
        deleteat!(x_data, y_data .< min_filter[2])
        filter!(z -> z > min_filter[2], y_data)

        # Scale data by 10^factor
        x_data = x_data ./ 10.0^x_factor
        y_data = y_data ./ 10.0^y_factor

        push!(x, x_data)
        push!(y, y_data)
    end

    xscale = scale[1]
    yscale = scale[2]

    # Data filtering for y axis logarithmic plotting
    if scale[2] == :log10
        length_short_cases = minimum(length.(findall.(z -> z > 0.0, y)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(x, y)
                deleteat!(x[i], y[i] .<= 0.0)
                filter!(z -> z > 0.0, y[i])
            end

        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            yscale = :identity
        end
    end

    # Data filtering for x axis logarithmic plotting
    if scale[1] == :log10
        length_short_cases = minimum(length.(findall.(z -> z > 0.0, x)))
        if length_short_cases >= 2

            # If every dataset has at least two data points, filter  
            # values <= 0, to allow logarithmic plotting
            @inbounds for i in eachindex(x, y)
                deleteat!(y[i], x[i] .<= 0.0)
                filter!(z -> z > 0.0, x[i])
            end
            
        else
            # If at least one dataset has less than two values, 
            # go back to linear scale
            xscale = :identity
        end
    end

    # Fill the datasets with NaN so all have the same length
    max_length = maximum(length.(x))
    for (i, l_r) in enumerate(length.(x))
        if l_r < max_length
            @inbounds for _ in 1:(max_length - l_r)
                push!(x[i], NaN)
                push!(y[i], NaN)
            end
        end
    end

    return plot(
        hcat(x...),
        hcat(y...),
        title = title,
        xscale = xscale,
        yscale = yscale,
        xlabel = axes_labels[x_axis],
        ylabel = axes_labels[y_axis],
        label = labels,
        legend = :bottomright,
        palette = :Set1_9,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        framestyle = :box,
        lw = 3,
        linestyle = :auto,
        size = (1200, 700),
        fontfamily = "Computer Modern",
        bottom_margin = 30px,
        left_margin = 30px,
        right_margin = 30px,
        top_margin = 20px, 
        titlefontsize = 25,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 24,
        yguidefontsize = 24,
        legendfontsize = 22,
    )
end

"""
    temperature_histogram_plot(
        temperature_data::Dict{String, Any},
        time::Unitful.Quantity; 
        <keyword arguments>
    )::Plots.Plot

Make a histogram of the logarithm of the gas particles' temperatures.

# Arguments
- `temperature_data::Dict{String,Any}`: Return value of the [`get_temperature`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
- `bins::Int64 = 20`: Number of bins to use in the histogram.
	
# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function temperature_histogram_plot(
    temperature_data::Dict{String, Any},
    time::Unitful.Quantity;
    bins::Int64 = 20,
)::Plots.Plot

    T = temperature_data["temperature"]
    temp_unit = temperature_data["unit"]

    # Non zero check
    if any(isequal(0.0), T)
        error("There are temperatures equal to 0!.")
    end

    # Set logarithmic scaling
    T = log10.(T)

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    figure = histogram(
        T,
        bins = range(0, stop = maximum(T), length = bins),
        xlabel = L"\log_{10}(\mathrm{T} \, / \, \mathrm{%$temp_unit})",
        normalize = :probability,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        fontfamily = "Computer Modern",
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.15, 0.95)...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

@doc raw"""
    rho_temp_plot(
        temperature_data::Dict{String, Any},
        density_data::Dict{String, Any},
        time::Unitful.Quantity,
    )::Plots.Plot

Make a plot of ``\mathrm{log}_{10}(\rho) \ \mathrm{vs.} \ \mathrm{log}_{10}(T)``, 
for the gas particles at a given time step.

# Arguments
- `temperature_data::Dict{String,Any}`: Return value of the [`get_temperature`](@ref) function.
- `density_data::Dict{String, Any}`: Return value of the [`get_density`](@ref) function.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
  All available time units in [Unitful](https://github.com/PainterQubits/Unitful.jl) and [UnitfulAstro](https://github.com/JuliaAstro/UnitfulAstro.jl) can be used, e.g. UnitfulAstro.Myr.
	
# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function rho_temp_plot(
    temperature_data::Dict{String, Any},
    density_data::Dict{String, Any},
    time::Unitful.Quantity,
)::Plots.Plot

    T = temperature_data["temperature"]
    temp_unit = temperature_data["unit"]
    ρ = density_data["density"]
    density_unit = string(density_data["unit"])

    # Non zero check
    if any(isequal(0.0), T)
        error("There are temperatures equal to 0!.")
    end
    if any(isequal(0.0), ρ)
        error("There are densities equal to 0!.")
    end

    # Set logarithmic scaling
    T = log10.(T)
    ρ = log10.(ρ)

    # Formatting for the x axis label
    xlabel = L"\log_{10}(\mathrm{T} \, / \, \mathrm{%$temp_unit})"

    # Formatting for the y axis label
    ylabel = replace(
        replace(
            density_unit, 
            "M⊙" => L"$\log_{10}\!\left(\rho \, / \, \mathrm{M_{\odot} \,",
        ),
        "^-3" => L"^{-3}}\right)$",
    )

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    time_unit = unit(time)

    figure = scatter(
        T,
        ρ;
        xlabel = L"\log_{10}(\mathrm{T} \, / \, \mathrm{%$temp_unit})",
        ylabel,
        size = (1000, 800),
        framestyle = :box,
        legend = false,
        markersize = 3,
        markerstrokewidth = 0,
        markercolor = :darkorange2,
        fontfamily = "Computer Modern",
        left_margin = 25px,
        right_margin = 30px,
        xtickfontsize = 22,
        ytickfontsize = 22,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 22,
    )
    annotate!(
        relative(figure, 0.5, 0.95)...,
        text("$clock $time_unit", "Courier", 22, :center),
    )

    return figure
end

"""
    kennicutt_schmidt_plot(
        gas_mass_data::Dict{String, Any},
        temperature_data::Dict{String, Any},
        star_mass_data::Dict{String, Any},
        age_data::Dict{String, Any},
        pos_data::Dict{String, Any},
        temp_filter::Unitful.Quantity,
        age_filter::Unitful.Quantity,
        max_r::Unitful.Quantity,
        time::Unitful.Quantity;
        <keyword arguments>
    )::Plots.Plot

Make a plot of the Kennicutt-Schmidt law for a given snapshot, with the linear fit and 
the measured values superimposed for comparison. 

# Arguments
- `gas_mass_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function, for gas.
- `temperature_data::Dict{String, Any}`: Return value of the [`get_temperature`](@ref) function.
- `star_mass_data::Dict{String, Any}`: Return value of the [`get_mass`](@ref) function, for stars.
- `age_data::Dict{String, Any}`: Return value of the [`get_age`](@ref) function.
- `pos_data::Dict{String, Any}`: Return value of the [`get_position`](@ref) function.
- `temp_filter::Unitful.Quantity`: Maximum temperature allowed for the gas particles.
- `age_filter::Unitful.Quantity`: Maximum stellar age allowed.
- `max_r::Unitful.Quantity`: Maximum distance up to which the parameters will be calculated.
- `time::Unitful.Quantity`: Time with units for the time stamp of the plot. 
- `bins::Int64 = 50`: Number of subdivisions of [0, `max_r`] to be used. 
  It has to be at least 5.
- `error_formating::String = "std_error"`: What to print as error values. The options are:
  * `"std_error"` ⟹ mean ± standard_error.
  * `"conf_interval"` ⟹ mean ± max(upper\\_95% - mean, mean - lower\\_95%).
	
# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function kennicutt_schmidt_plot(
    gas_mass_data::Dict{String, Any},
    temperature_data::Dict{String, Any},
    star_mass_data::Dict{String, Any},
    age_data::Dict{String, Any},
    pos_data::Dict{String, Any},
    temp_filter::Unitful.Quantity,
    age_filter::Unitful.Quantity,
    max_r::Unitful.Quantity,
    time::Unitful.Quantity;
    bins::Int64 = 50,
    error_formating::String = "std_error",
)::Union{Plots.Plot, Nothing}

    # Masses
    gas_mass = gas_mass_data["mass"]
    gas_mass_unit = gas_mass_data["unit"]
    
    star_mass = star_mass_data["mass"]
    star_mass_unit = star_mass_data["unit"]

    # Unit consistency check
    gas_mass_unit == star_mass_unit || error("Star and gas mass units must be the same.")

    # Positions
    gas_pos = pos_data["gas"]
    star_pos = pos_data["stars"]
    length_unit = pos_data["unit"]
    max_R = ustrip(Float64, length_unit, max_r)
    dist_gas = [norm(col) for col in eachcol(gas_pos)]
    dist_stars = [norm(col) for col in eachcol(star_pos)]

    # Temperatures
    gas_temp = temperature_data["temperature"]
    T_filter = ustrip(temp_filter)

    # Ages
    star_age = age_data["ages"]
    time_unit = age_data["unit"]
    time_filter = ustrip(Float64, time_unit, age_filter)

    ksl = kennicutt_schmidt_law(
        gas_mass,
        dist_gas,
        gas_temp,
        star_mass,
        dist_stars,
        star_age,
        T_filter,
        time_filter,
        max_R;
        bins,
    )

    if ksl === nothing
        return nothing
    end

    # Data to be plotted
    density_data = ksl["RHO"]
    sfr_data = ksl["SFR"]

    # Get linear fit
    linear_model = ksl["LM"]
    # Mean values
    coeff = coef(linear_model)
    mean_intercept = coeff[1]
    mean_slope = coeff[2]
    # Errors
    errors = stderror(linear_model)
    conf_intval = confint(linear_model)
    interval_intercept = maximum(
        [conf_intval[1, 2] - mean_intercept, mean_intercept - conf_intval[1, 1]]
    )
    interval_slope = maximum(
        [conf_intval[2, 2] - mean_slope, mean_slope - conf_intval[2, 1]]
    )

    # Sets the slope and intercept with the right number of digits for display
    if error_formating == "conf_interval"
        intercept, intercept_error = format_error(mean_intercept, interval_intercept)
        slope, slope_error = format_error(mean_slope, interval_slope)
    else
        intercept, intercept_error = format_error(mean_intercept, errors[1])
        slope, slope_error = format_error(mean_slope, errors[2])
    end

    # Formatting for the x axis label
    density_unit = gas_mass_unit / length_unit^2
    xlabel = replace(
        replace(
            string(density_unit), 
            "M⊙" => "\\log_{10}\\left(\\Sigma_\\mathrm{gas} \\, / \\, \\mathrm{M}_{\\odot} \\, \\mathrm{",
        ),
        "^-2" => "^{-2}}\\right)",
    )

    # Formatting for the y axis label
    sfr_unit = gas_mass_unit / time_unit /length_unit^2
    ylabel = replace(
        replace(
            replace(
                string(sfr_unit), 
                "M⊙" => "\\log_{10}\\left(\\Sigma_\\mathrm{SFR} \\, / \\, \\mathrm{M_{\\odot} \\,",
            ),
            "^-1" => "^{-1} \\,",
        ), 
        "^-2" => "^{-2}}\\right)",
    )

    # Magnitude and unit for the time stamp
    clock = round(ustrip(time), sigdigits = 4)
    clock_unit = unit(time)

    # Scatter plot of the simulated data
    figure = scatter(
        density_data, 
        sfr_data, 
        label = "Simulation", 
        xlabel = L"%$xlabel", 
        ylabel = L"%$ylabel",
        size = (1200, 1000),
        framestyle = :box,
        left_margin = 30px,
        right_margin = 30px,
        bottom_margin = 25px,
        fontfamily = "Computer Modern",
        xtickfontsize = 20,
        ytickfontsize = 20,
        xguidefontsize = 25,
        yguidefontsize = 25,
        legendfontsize = 20,
        markersize = 6,
        markerstrokewidth = 0,
        markercolor = :darkorange2,
        legend = :bottomright,
        background_color_legend = nothing,
        foreground_color_legend = nothing,
    )

    # Comparison line with the measured values by Kennicutt (1998)
    sorted_density = sort(density_data)
	KS_intercept = ustrip(Float64, sfr_unit, KENNICUTT98_INTERCEPT)
	KS_intercept *= ustrip(Float64, density_unit, KENNICUTT98_RHO_UNIT)^(-KENNICUTT98_SLOPE)
	y_KS_98 = log10(KS_intercept) .+ KENNICUTT98_SLOPE .* sorted_density

    plot!(
        figure, 
        sorted_density, 
        y_KS_98, 
        ls = :auto,
        lw = 4,
        color = :blueviolet,
        label = "Kennicutt 1998",
    )

    # Linear fit plot
    plot!(
        figure, 
        density_data, 
        predict(linear_model), 
        lw = 4,
        color = :red,
        label = "Fit",
    )
    annotate!(
        relative(figure, 0.5, 0.95)...,
        text("$clock $clock_unit", "Courier", 22, :center),
    )

    # Annotations with the fitted parameters and its errors
    annotate!(
        relative(figure, 0.05, 0.95)...,
        text(
            L"\Sigma_\mathrm{SFR} = \mathrm{A}\,\Sigma_\mathrm{gas}^{\,\mathrm{N}}", 
            20, 
            :left,
        ),
    )
    annotate!(
        relative(figure, 0.05, 0.9)...,
        text(
            L"\mathrm{N} = %$slope \pm %$slope_error", 
            "Courier", 
            20, 
            :left,
        ),
    )
    annotate!(
        relative(figure, 0.05, 0.85)...,
        text(
            L"\mathrm{log}_{10}(\mathrm{A}) = %$intercept \pm %$intercept_error",
            20, 
            :left,
        ),
    )

    return figure
end

"""
    cpu_txt_plot(
        data::Dict{String, Matrix{Float64}}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of the CPU usage of several processes (as percentages), from the data in the 
cpu.txt file.

# Arguments
- `data::Dict{String, Matrix{Float64}}`: Return values of the [`get_cpu_txt`](@ref) function.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function cpu_txt_plot(
    data::Dict{String, Matrix{Float64}},
    title::String = "",
)::Plots.Plot

    # Configuration of the parameters for the plot
    figure = plot(
        xlabel = "CPU steps",
        ylabel = L"\mathrm{CPU \ usage} \ \mathrm{\%}",
        title = title,
        legend = :topright,
        palette = :Set1_9,
        framestyle = :box,
        size = (1200, 700),
        fontfamily = "Computer Modern",
        left_margin = 25px,
        right_margin = 40px,
        bottom_margin = 25px,
        titlefontsize = 25,
        xtickfontsize = 20,
        ytickfontsize = 20,
        xguidefontsize = 22,
        yguidefontsize = 22,
        legendfontsize = 22,
    )

    for (key, value) in data

        plot!(
            figure,
            value[:, 1],
            value[:, 2],
            label = key,
            lw = 4,
            foreground_color_legend = nothing,
            background_color_legend = nothing,
        )

    end  

    return figure
end

"""
    cpu_txt_plot(
        data::Vector{Dict{String, Matrix{Float64}}},
        labels::Array{String, 2}; 
        <keyword arguments>
    )::Plots.Plot

Make a plot of a process' CPU usage (as percentages) for several simulations, from 
the data in the cpu.txt file.

If data contains more than ones process, only the first one will be used.

# Arguments
- `data::Vector{Dict{String, Matrix{Float64}}}`: Vector of return values of the
  [`get_cpu_txt`](@ref) function.
- `labels::Array{String, 2}`: Labels for the different simulations.
- `title::String = ""`: Title for the figure. If an empty string is given no title is 
  printed, which is the default.

# Returns
- The plot generated by the PGFPlotsX backend of [Plots.jl](https://github.com/JuliaPlots/Plots.jl).
"""
function cpu_txt_plot(
    data::Vector{Dict{String, Matrix{Float64}}},
    labels::Array{String, 2},
    title::String = "",
)::Plots.Plot

    percentages = [first(values(dict))[:, 2] for dict in data]
    cycles = [first(values(dict))[:, 1] for dict in data]

    return plot(
        cycles,
        percentages,
        xlabel = "CPU steps",
        ylabel = L"\mathrm{CPU \ usage} \ \mathrm{\%}",
        label = labels,
        title = title,
        legend = :topright,
        palette = :Set1_9,
        framestyle = :box,
        size = (1200, 700),
        lw = 4,
        foreground_color_legend = nothing,
        background_color_legend = nothing,
        fontfamily = "Computer Modern",
        left_margin = 25px,
        right_margin = 40px,
        bottom_margin = 25px,
        titlefontsize = 25,
        xtickfontsize = 20,
        ytickfontsize = 20,
        xguidefontsize = 22,
        yguidefontsize = 22,
        legendfontsize = 22,
    )
end