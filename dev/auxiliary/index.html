<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Auxiliary Functions · GADGETPlotting.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GADGETPlotting.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../pipelines/">Pipeline Functions</a></li><li><a class="tocitem" href="../plotting/">Plotting Functions</a></li><li><a class="tocitem" href="../data_acquisition/">Data Acquisition Functions</a></li><li class="is-active"><a class="tocitem" href>Auxiliary Functions</a></li><li><a class="tocitem" href="../func_list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Auxiliary Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Auxiliary Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ezequiel92/GADGETPlotting/blob/main/docs/src/auxiliary.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Auxiliary"><a class="docs-heading-anchor" href="#Auxiliary">Auxiliary</a><a id="Auxiliary-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.center_of_mass-Tuple{Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}" href="#GADGETPlotting.center_of_mass-Tuple{Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}"><code>GADGETPlotting.center_of_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center_of_mass(
    position_data::Matrix{&lt;:Real},
    mass_data::Vector{&lt;:Real},
)::NTuple{3, Float64}</code></pre><p>Calculate the center of mass as</p><p><span>$R_c = \frac{1}{M} \sum_i m_i \, r_i \, ,$</span></p><p>where <span>$M = \sum_i m_i$</span> and <span>$m_i$</span> and <span>$r_i$</span> are the mass and distance  from the origin of the i-th particle.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Matrix{&lt;:Real}</code>: The positions of the particles.</li><li><code>mass_data::Vector{&lt;:Real}</code>: The masses of the particles.</li></ul><p><strong>Returns</strong></p><ul><li>The center of mass in the unis of <code>position_data</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L808-L827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison-Tuple{Any, Any}" href="#GADGETPlotting.comparison-Tuple{Any, Any}"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool</code></pre><p>Determines is two elements are equal.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: First element to be compared.</li><li><code>y</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance (for compatibility).</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance (for compatibility).</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if <code>x == y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L878-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison-Tuple{Union{Real, Tuple{Vararg{Real, N} where N}, AbstractArray{var&quot;#s5&quot;, N} where {var&quot;#s5&quot;&lt;:Real, N}}, Union{Real, Tuple{Vararg{Real, N} where N}, AbstractArray{var&quot;#s3&quot;, N} where {var&quot;#s3&quot;&lt;:Real, N}}}" href="#GADGETPlotting.comparison-Tuple{Union{Real, Tuple{Vararg{Real, N} where N}, AbstractArray{var&quot;#s5&quot;, N} where {var&quot;#s5&quot;&lt;:Real, N}}, Union{Real, Tuple{Vararg{Real, N} where N}, AbstractArray{var&quot;#s3&quot;, N} where {var&quot;#s3&quot;&lt;:Real, N}}}"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison(
    x::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}, 
    y::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two numbers, numeric arrays or numeric tuples are approximately equal.</p><p><strong>Arguments</strong></p><ul><li><code>x::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}</code>: First element to be compared.</li><li><code>y::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements (X, Y) in (x, y) pass <code>julia norm(X - Y) &lt;= max(atol, rtol * max(norm(X), norm(Y)))</code>`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L845-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compute_cmdf-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.compute_cmdf-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.compute_cmdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_cmdf(
    mass_data::Vector{Float64},
    metallicity_data::Vector{Float64},
    max_Z::Float64,
    bins::Int64; 
    &lt;keyword arguments&gt;
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute the cumulative metallicity distribution function up to a metallicity <code>max_Z</code>. </p><p>The CMDF is calculated separating the stellar metallicity in <code>bins</code> windows from 0 to  <code>max_Z</code> metallicity. Within the j-th window the CMDF is</p><p><span>$\sum_{i = 1}^j \frac{m_i}{M_T}$</span> vs. <span>$\bar{Z}_j$</span></p><p>or, for <code>x_norm = true</code>, </p><p><span>$\sum_{i = 1}^j \frac{m_i}{M_T}$</span> vs. <span>$\bar{Z}_j / max(\bar{Z}_j)$</span></p><p>where <span>$M_T$</span> is the total stellar mass, <span>$m_i$</span> the stellar mass of the i-th window and <span>$\bar{Z}_j$</span> the mean stellar metallicity of the j-th window.</p><p><code>mass_data</code> and <code>metallicity_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>metallicity_data::Vector{Float64}</code>: Metallicities of the particles. </li><li><code>max_Z::Float64</code>: Maximum metallicity up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_Z</code>] to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the metallicities and the second with the accumulated masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L418-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.deep_comparison-Tuple{Dict, Dict}" href="#GADGETPlotting.deep_comparison-Tuple{Dict, Dict}"><code>GADGETPlotting.deep_comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deep_comparison(
    x::Dict, 
    y::Dict; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two dictionaries are approximately equal.</p><p>Numeric elements are compared with <code>comparison()</code>, everything else with <code>isequal()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Dict</code>: First dictionary to be compared.</li><li><code>y::Dict</code>: Second dictionary to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L898-L918">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.deep_comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}" href="#GADGETPlotting.deep_comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}"><code>GADGETPlotting.deep_comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deep_comparison(
    x::Union{AbstractArray, Tuple}, 
    y::Union{AbstractArray, Tuple}; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two arrays or tuples are approximately equal.</p><p>Numeric elements are compared with <code>comparison()</code>, everything else with <code>isequal()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Union{AbstractArray, Tuple}</code>: First array to be compared.</li><li><code>y::Union{AbstractArray, Tuple}</code>: Second array to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L934-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.density_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.density_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a density profile up to a radius <code>max_radius</code>. </p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a density for the j-th shell of</p><p><span>$\rho = \frac{M}{\frac{4}{3}\,\pi\,\mathrm{width}^3\,(3\,j^2 - 3\,j + 1)}$</span></p><p>where <span>$M$</span> is the total mass within each shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays.  The first with the radial distances and the second with the densities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L204-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.energy_integrand-Tuple{GadgetIO.SnapshotHeader, Float64}" href="#GADGETPlotting.energy_integrand-Tuple{GadgetIO.SnapshotHeader, Float64}"><code>GADGETPlotting.energy_integrand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_integrand(header::GadgetIO.SnapshotHeader, a::Float64)::Float64</code></pre><p>Give the integrand of the scale factor to physical time function</p><p><span>$\frac{1}{H\,\sqrt{\epsilon}}$</span>, </p><p>where <span>$H = H_0 \, a$</span> and <span>$\epsilon = \Omega_\lambda + (1 - \Omega_\lambda - \Omega_0) / a^2 + \Omega_0 / a^3$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>header::GadgetIO.SnapshotHeader</code>: Header of the relevant snapshot file.</li><li><code>a::Float64</code>: Dimensionless scale factor.</li></ul><p><strong>Returns</strong></p><ul><li>The integrand evaluated in <code>a</code> in Gyr.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L725-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.format_error-Tuple{Float64, Float64}" href="#GADGETPlotting.format_error-Tuple{Float64, Float64}"><code>GADGETPlotting.format_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">format_error(mean::Float64, error::Float64)::String</code></pre><p>Format the mean and error values.</p><p>It follows the traditional rules for error presentation. The error has only one significant   digit, unless such digit is a one, in which case, two significant digits are used.   The mean will have a number of digits such as to match the error. </p><p><strong>Arguments</strong></p><ul><li><code>mean::Float64</code>: Mean value.</li><li><code>error::Float64</code>: Error value. It must be positive.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the formatted mean and error values.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; format_error(69.42069, 0.038796)
(69.42, 0.04)

julia&gt; format_error(69.42069, 0.018796)
(69.421, 0.019)

julia&gt; format_error(69.42069, 0.0)
(69.42069, 0.0)

julia&gt; format_error(69.42069, 73.4)
(0.0, 70.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L616-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_law-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}" href="#GADGETPlotting.kennicutt_schmidt_law-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}"><code>GADGETPlotting.kennicutt_schmidt_law</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_law(
    gas_mass_data::Vector{Float64},
    gas_distance_data::Vector{Float64},
    temperature_data::Vector{Float64},
    star_mass_data::Vector{Float64},
    star_distance_data::Vector{Float64},
    age_data::Vector{Float64},
    temp_filter::Float64,
    age_filter::Float64,
    max_r::Float64; 
    &lt;keyword arguments&gt;
)::Union{Nothing, Dict{String, Any}}</code></pre><p>Compute mass area density and the SFR area density for the Kennicutt-Schmidt law. </p><p><code>temp_filter</code> and <code>temperature_data</code> must be in the same units, and <code>age_filter</code> and  <code>age_data</code> must be in the same units too.</p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Vector{Float64}</code>: Masses of the gas particles.</li><li><code>gas_distance_data::Vector{Float64}</code>: 2D distances of the gas particles. </li><li><code>temperature_data::Vector{Float64}</code>: Temperatures of the gas particles.</li><li><code>star_mass_data::Vector{Float64}</code>: Masses of the stars.</li><li><code>star_distance_data::Vector{Float64}</code>: 2D distances of the stars.</li><li><code>age_data::Vector{Float64}</code>: Ages of the stars.</li><li><code>temp_filter::Float64</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Unitful.Quantity</code>: Maximum star age allowed for the calculation of the SFR.  It should be approximately equal to the time step of the snapshots.</li><li><code>max_r::Float64</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used.  It has to be at least 5.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with three entries.<ul><li>Key &quot;RHO&quot; =&gt; Logarithm of the area mass densities.</li><li>Key &quot;SFR&quot; =&gt; Logarithm of the SFR area densities.</li><li>Key &quot;LM&quot; =&gt; Linear model given by GLM.jl.</li></ul></li><li>Or <code>nothing</code> if there are less than 5 data point in the end result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L506-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.make_video-Tuple{String, String, String, String, Int64}" href="#GADGETPlotting.make_video-Tuple{String, String, String, String, Int64}"><code>GADGETPlotting.make_video</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_video(
    source_path::String,
    source_format::String,
    output_path::String,
    output_filename::String,
    frame_rate::Int64,
)::Nothing</code></pre><p>Make a MP4 video from a series of images. </p><p>The H.264 codec is used with no compression and the source images can be in any format available in ImageIO.jl, e.g. &quot;.png&quot;, &quot;.svg&quot;, &quot;.jpeg&quot;, etc.</p><p><strong>Arguments</strong></p><ul><li><code>source_path::String</code>: Path to the directory containing the images.	</li><li><code>source_format::String</code>: File format of the source images. </li><li><code>output_path::String</code>: Path to the directory where the resulting video will be saved.</li><li><code>output_filename::String</code>: Name of the video to be generated without extension.	</li><li><code>frame_rate::Int64</code>: Frame rate of the video to be generated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L83-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.mass_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.mass_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute an accumulated mass profile up to a radius <code>max_radius</code>. </p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a accumulated mass for  the j-th shell of</p><p><span>$M = \sum_{i = 1}^j m_i$</span></p><p>where <span>$m_i$</span> is the total mass within the i-th shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the radial distances and the second with the accumulated masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L350-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.metallicity_profile-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.metallicity_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">metallicity_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    z_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a metallicity profile up to a radius <code>max_radius</code>, and normalize it to the  solar metallicity.</p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a relative metallicity for  the j-th shell of</p><p><span>$\rho = \frac{z}{M\,Z_\odot}$</span></p><p>where <span>$M$</span> is the total mass and <span>$z$</span> the total content of metals, within each shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units. <code>z_data</code> and <code>mass_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>z_data::Vector{Float64}</code>: Metal content of the particles in mass units.</li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the radial distances and the second with the metallicities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L274-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.num_integrate" href="#GADGETPlotting.num_integrate"><code>GADGETPlotting.num_integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_integrate(
    func::Function, 
    inf_lim::Float64, 
    sup_lim::Float64, 
    steps::Int64 = 200,
)::Float64</code></pre><p>Give the numerical integral of <code>func</code> between <code>inf_val</code> and <code>sup_val</code>. </p><p>The result is given by</p><p><span>$\int_\mathrm{inf\_lim}^\mathrm{sup\_lim} f(x) \mathrm{dx} \approx \sum_{i = 1}^\mathrm{steps} f(\mathrm{inf\_lim} + \mathrm{width}\,i ) \, ,$</span></p><p>where <span>$\mathrm{width} = (\mathrm{sup\_lim} - \mathrm{inf\_lim}) / \mathrm{steps}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>func::Function</code>: 1D function to be integrated.</li><li><code>inf_lim::Float64</code>: Inferior limit of the integral.</li><li><code>sup_lim::Float64</code>: Superior limit if the integral.</li><li><code>steps::Int64</code>: Number of subdivisions to be used for the discretization of  the <code>sup_lim</code> - <code>inf_lim</code> region.</li></ul><p><strong>Returns</strong></p><ul><li>The value of the integral.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; num_integrate(sin, 0, 3π)
1.9996298761360816

julia&gt; num_integrate(x -&gt; x^3 + 6 * x^2 + 9 * x + 2, 0, 4.69)
438.9004836958452

julia&gt; num_integrate(x -&gt; exp(x^x), 0, 1.0)
2.1975912134624904</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L754-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.pass_all-Tuple{String, String}" href="#GADGETPlotting.pass_all-Tuple{String, String}"><code>GADGETPlotting.pass_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pass_all(snap_file::String, type::String)::Vector{Int64}</code></pre><p>Default filter function for <code>read_blocks_over_all_files</code>.</p><p>It does not filter out any particles, allowing the data acquisition functions to gather  all data. </p><p><strong>Arguments</strong></p><ul><li><code>snap_file::String</code>: Snapshot file path.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li></ul><p><strong>Returns</strong></p><ul><li>A Vector with the indices of the allowed particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L688-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.relative" href="#GADGETPlotting.relative"><code>GADGETPlotting.relative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative(
    p::Plots.Plot,
    rx::Float64,
    ry::Float64,
    rz::Union{Float64, Nothing} = nothing; 
    &lt;keyword arguments&gt;
)::Union{NTuple{2, Float64}, NTuple{3, Float64}}</code></pre><p>Give the absolute coordinates within a Plot, given the relative ones.</p><p><strong>Arguments</strong></p><ul><li><code>p::Plots.Plot</code>: Plot for which the absolute coordinates will be calculated.</li><li><code>rx::Float64</code>: relative x coordinate, rx ∈ [0, 1].</li><li><code>ry::Float64</code>: relative y coordinate, ry ∈ [0, 1].</li><li><code>rz::Union{Float64,Nothing} = nothing</code>: relative z coordinate, rz ∈ [0, 1].</li><li><code>log::Union{NTuple{2, Bool}, NTuple{3, Bool}} = (false, false, false)</code> = If the x, y or z axis will be in a logarithmic scale.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the absolute coordinates: (x, y) or (x, y, z).</li></ul><p><strong>Examples</strong></p><p>```julia-repl julia&gt; GADGETPlotting.relative(plot(rand(100)), 0.5, 0.5) (50.5, 0.5047114800322484)</p><p>julia&gt; GADGETPlotting.relative(surface(rand(100, 100)), 0.5, 0.5, 0.5) (50.5, 50.5, 0.5000284432744244)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.smooth_window-Tuple{Vector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, Int64}" href="#GADGETPlotting.smooth_window-Tuple{Vector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, Int64}"><code>GADGETPlotting.smooth_window</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smooth_window(
    x_data::Vector{&lt;:Real},
    y_data::Vector{&lt;:Real},
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Separate the range of values of <code>x_data</code> in <code>bins</code> contiguous windows, and replaces  every x and y value within the window with the mean in order to smooth out the data. </p><p><strong>Arguments</strong></p><ul><li><code>x_data::Vector{&lt;:Real}</code>: Data used to create the windows.</li><li><code>y_data::Vector{&lt;:Real}</code>: Data to be smoothed out.</li><li><code>bins::Int64</code>: Number of windows to be used in the smoothing.</li><li><code>log::Bool = false</code>: If the x axis will be divided using logarithmic bins.</li></ul><p><strong>Returns</strong></p><ul><li>The smooth data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/be3f54b56a5f9d2e573b16af3490012b4005491c/src/auxiliary.jl#L132-L150">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_acquisition/">« Data Acquisition Functions</a><a class="docs-footer-nextpage" href="../func_list/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 May 2021 15:46">Wednesday 12 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
