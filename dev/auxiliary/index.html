<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Auxiliary Functions · GADGETPlotting.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GADGETPlotting.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../pipelines/">Pipeline Functions</a></li><li><a class="tocitem" href="../plotting/">Plotting Functions</a></li><li><a class="tocitem" href="../data_acquisition/">Data Acquisition Functions</a></li><li class="is-active"><a class="tocitem" href>Auxiliary Functions</a></li><li><a class="tocitem" href="../func_list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Auxiliary Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Auxiliary Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ezequiel92/GADGETPlotting/blob/main/docs/src/auxiliary.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Auxiliary-Functions"><a class="docs-heading-anchor" href="#Auxiliary-Functions">Auxiliary Functions</a><a id="Auxiliary-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.center_of_mass-Tuple{Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}" href="#GADGETPlotting.center_of_mass-Tuple{Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}"><code>GADGETPlotting.center_of_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center_of_mass(
    position_data::Matrix{&lt;:Real},
    mass_data::Vector{&lt;:Real},
)::Union{NTuple{3, Float64}, Nothing}</code></pre><p>Compute the center of mass as</p><p class="math-container">\[R_c = \frac{1}{M} \sum_n m_n \, r_n \, ,\]</p><p>where <span>$M = \sum_n m_n$</span> and <span>$m_n$</span> and <span>$r_n$</span> are the mass and distance  from the origin of the <span>$n$</span>-th particle.</p><p>If the length of <span>$R$</span> is less than <span>$10^-3$</span> the length of the larger position vector in <code>position_data</code>, nothing is returned.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Matrix{&lt;:Real}</code>: Positions of the particles.</li><li><code>mass_data::Vector{&lt;:Real}</code>: Masses of the particles.</li></ul><p><strong>Returns</strong></p><ul><li>The center of mass in the unis of <code>position_data</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1086-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison-Tuple{Any, Any}" href="#GADGETPlotting.comparison-Tuple{Any, Any}"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool</code></pre><p>Determine if two elements are equal, as per the <a href="https://docs.julialang.org/en/v1/base/base/#Base.isequal">isequal</a> function.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: First element to be compared.</li><li><code>y</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance (for compatibility).</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance (for compatibility).</li></ul><p><strong>Returns</strong></p><ul><li>Returns <code>isequal(x, y)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1203-L1216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison-Tuple{Number, Number}" href="#GADGETPlotting.comparison-Tuple{Number, Number}"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool</code></pre><p>Determine if two elements are equal, as per the <a href="https://docs.julialang.org/en/v1/base/base/#Base.isequal">isequal</a> function.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: First element to be compared.</li><li><code>y</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance (for compatibility).</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance (for compatibility).</li></ul><p><strong>Returns</strong></p><ul><li>Returns <code>isequal(x, y)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1179-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}" href="#GADGETPlotting.comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool</code></pre><p>Determine if two elements are equal, as per the <a href="https://docs.julialang.org/en/v1/base/base/#Base.isequal">isequal</a> function.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: First element to be compared.</li><li><code>y</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance (for compatibility).</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance (for compatibility).</li></ul><p><strong>Returns</strong></p><ul><li>Returns <code>isequal(x, y)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1154-L1167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compute_cmdf-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.compute_cmdf-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.compute_cmdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_cmdf(
    mass_data::Vector{Float64},
    metallicity_data::Vector{Float64},
    max_Z::Float64,
    bins::Int64; 
    &lt;keyword arguments&gt;
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute the cumulative metallicity distribution function up to a metallicity of <code>max_Z</code>. </p><p>The CMDF is calculated separating in <code>bins</code> windows the stellar metallicity, within the  range [0, <code>max_Z</code>]. For the <span>$n$</span>-th window the CMDF is</p><p class="math-container">\[\sum_{i = 1}^n \dfrac{m_i}{M_T} \quad \mathrm{vs.} \quad \bar{Z}_n \, ,\]</p><p>or, for <code>x_norm = true</code>, </p><p class="math-container">\[\sum_{i = 1}^n \dfrac{m_i}{M_T} \quad \mathrm{vs.} \quad \dfrac{\bar{Z}_n}{\mathrm{max}(\bar{Z}_n)} \, ,\]</p><p>where <span>$M_T$</span> is the total stellar mass, <span>$m_i$</span> the stellar mass of the <span>$i$</span>-th window and <span>$\bar{Z}_n$</span> the mean stellar metallicity of the <span>$n$</span>-th window.</p><p><code>mass_data</code> and <code>metallicity_data</code> must be in the same mass units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>metallicity_data::Vector{Float64}</code>: Metallicities of the particles. </li><li><code>max_Z::Float64</code>: Maximum metallicity up to which the CMDF will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_Z</code>] to be used for the CMDF.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the metallicities and the second with the accumulated masses,  of each window.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L429-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.deep_comparison-Tuple{Dict, Dict}" href="#GADGETPlotting.deep_comparison-Tuple{Dict, Dict}"><code>GADGETPlotting.deep_comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deep_comparison(
    x::Dict, 
    y::Dict; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determine if two dictionaries are approximately equal.</p><p>Numeric elements are compared with the <a href="#GADGETPlotting.comparison-Tuple{Any, Any}"><code>comparison</code></a> function, everything else with  the <a href="https://docs.julialang.org/en/v1/base/base/#Base.isequal">isequal</a> function.</p><p><strong>Arguments</strong></p><ul><li><code>x::Dict</code>: First dictionary to be compared.</li><li><code>y::Dict</code>: Second dictionary to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements within the dictionaries pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1223-L1244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.deep_comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}" href="#GADGETPlotting.deep_comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}"><code>GADGETPlotting.deep_comparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deep_comparison(
    x::Union{AbstractArray, Tuple}, 
    y::Union{AbstractArray, Tuple}; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines if two arrays or tuples are approximately equal.</p><p>Numeric elements are compared with the <a href="#GADGETPlotting.comparison-Tuple{Any, Any}"><code>comparison</code></a> function, everything else with  the <a href="https://docs.julialang.org/en/v1/base/base/#Base.isequal">isequal</a> function.</p><p><strong>Arguments</strong></p><ul><li><code>x::Union{AbstractArray, Tuple}</code>: First array to be compared.</li><li><code>y::Union{AbstractArray, Tuple}</code>: Second array to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1260-L1281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.density_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.density_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a density profile up to a radius <code>max_radius</code>. </p><p>It divides a sphere of radius <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius</code> / <code>bins</code>. This results in a volume for the <span>$n$</span>-th shell of</p><p class="math-container">\[V_n = \frac{4}{3}\,\pi\,\mathrm{width}^3\,(3\,n^2 - 3\,n + 1) \, .\]</p><p>So, the assigned density for that shell is <span>$\rho_n = M_n / V_n$</span> where <span>$M_n$</span> is the total  mass within the shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same length units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with two arrays.  The first with the radial distances and the second with the densities, of each shell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L208-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.energy_integrand-Tuple{GadgetIO.SnapshotHeader, Float64}" href="#GADGETPlotting.energy_integrand-Tuple{GadgetIO.SnapshotHeader, Float64}"><code>GADGETPlotting.energy_integrand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_integrand(header::GadgetIO.SnapshotHeader, a::Float64)::Float64</code></pre><p>Give the integrand of the scale factor to physical time function</p><p class="math-container">\[\frac{1}{H\,\sqrt{\epsilon}} \, ,\]</p><p>where </p><p class="math-container">\[\epsilon = \Omega_\lambda + \frac{1 - \Omega_\lambda - \Omega_0}{a^2} + \frac{\Omega_0}{a^3} \, , \]</p><p class="math-container">\[H = H_0 \, a \, .\]</p><p><strong>Arguments</strong></p><ul><li><code>header::GadgetIO.SnapshotHeader</code>: Header of the relevant snapshot file.</li><li><code>a::Float64</code>: Dimensionless scale factor.</li></ul><p><strong>Returns</strong></p><ul><li>The integrand in Gyr evaluated in <code>a</code> .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L992-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.format_error-Tuple{Float64, Float64}" href="#GADGETPlotting.format_error-Tuple{Float64, Float64}"><code>GADGETPlotting.format_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">format_error(mean::Float64, error::Float64)::String</code></pre><p>Format the mean and error values.</p><p>It follows the traditional rules for error presentation. The error has only one significant   digit, unless such digit is a one, in which case, two significant digits are used.   The mean will have a number of digits such as to match the last significant position  of the error. </p><p><strong>Arguments</strong></p><ul><li><code>mean::Float64</code>: Mean value.</li><li><code>error::Float64</code>: Error value. It must be positive.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the formatted mean and error values.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; format_error(69.42069, 0.038796)
(69.42, 0.04)

julia&gt; format_error(69.42069, 0.018796)
(69.421, 0.019)

julia&gt; format_error(69.42069, 0.0)
(69.42069, 0.0)

julia&gt; format_error(69.42069, 73.4)
(0.0, 70.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L882-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_law-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}" href="#GADGETPlotting.kennicutt_schmidt_law-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}"><code>GADGETPlotting.kennicutt_schmidt_law</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_law(
    gas_mass_data::Vector{Float64},
    gas_distance_data::Vector{Float64},
    temperature_data::Vector{Float64},
    star_mass_data::Vector{Float64},
    star_distance_data::Vector{Float64},
    age_data::Vector{Float64},
    temp_filter::Float64,
    age_filter::Float64,
    max_r::Float64; 
    &lt;keyword arguments&gt;
)::Union{Nothing, Dict{String, Any}}</code></pre><p>Compute the mass area density and the SFR area density for the <a href="https://en.wikipedia.org/wiki/Kennicutt%E2%80%93Schmidt_law">Kennicutt-Schmidt law</a>. </p><p>The area densities are calculated by projecting the positions of the stars and of the  particles of gas to the x-y plane. Then the space is subdivided in <code>bins</code> concentric  rings from 0 to <code>max_r</code>, each of equal width <code>max_r</code> / <code>bins</code>. This results in an area  for the <span>$n$</span>-th ring of</p><p class="math-container">\[A_n = π \, \mathrm{width}^2 \, (2 \, n - 1) \, .\]</p><p>So, the assigned SFR for that ring is </p><p class="math-container">\[\Sigma_\mathrm{SFR}^n = \frac{M_*^n}{\mathrm{age\_filter}\,A_n} \, ,\]</p><p>where <span>$M_*^n$</span> is the total mass of stars younger than <code>age_filter</code> within the ring.</p><p>Equivalently, the mass area density of the gas is given by</p><p class="math-container">\[\Sigma_\rho^n = \frac{M_\rho^n}{A_n} \, ,\]</p><p>where <span>$M_\rho^n$</span> is the total mass of gas colder than <code>temp_filter</code> within the ring.</p><p><code>temp_filter</code> and <code>temperature_data</code> must be in the same temperature units,  and <code>age_filter</code> and <code>age_data</code> must be in the same time units.</p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Vector{Float64}</code>: Masses of the gas particles.</li><li><code>gas_distance_data::Vector{Float64}</code>: 2D radial distances of the gas particles. </li><li><code>temperature_data::Vector{Float64}</code>: Temperatures of the gas particles.</li><li><code>star_mass_data::Vector{Float64}</code>: Masses of the stars.</li><li><code>star_distance_data::Vector{Float64}</code>: 2D radial distances of the stars.</li><li><code>age_data::Vector{Float64}</code>: Ages of the stars.</li><li><code>temp_filter::Float64</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Float64</code>: Maximum age allowed for the stars.</li><li><code>max_r::Float64</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used. It has to be at  least 5.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with three entries.<ul><li>Key &quot;RHO&quot; =&gt; Logarithm of the area mass densities.</li><li>Key &quot;SFR&quot; =&gt; Logarithm of the SFR area densities.</li><li>Key &quot;LM&quot; =&gt; Linear model given by <a href="https://github.com/JuliaStats/GLM.jl">GLM.jl</a>.</li></ul></li><li>Or <code>nothing</code> if there are less than 5 data points in the end result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L522-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.make_video-Tuple{String, String, String, String, Int64}" href="#GADGETPlotting.make_video-Tuple{String, String, String, String, Int64}"><code>GADGETPlotting.make_video</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_video(
    source_path::String,
    source_format::String,
    output_path::String,
    output_filename::String,
    frame_rate::Int64,
)::Nothing</code></pre><p>Make an MP4 video from a series of images. </p><p>The H.264 codec with no compression is used and the source images can be in any format available in <a href="https://github.com/JuliaIO/ImageIO.jl">ImageIO.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>source_path::String</code>: Path to the directory containing the images.	</li><li><code>source_format::String</code>: File format of the source images, e.g. &quot;.png&quot;, &quot;.svg&quot;, etc.</li><li><code>output_path::String</code>: Path to the directory where the resulting video will be saved.</li><li><code>output_filename::String</code>: Name of the video to be generated without extension.	</li><li><code>frame_rate::Int64</code>: Frame rate of the video to be generated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L87-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.mass_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.mass_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute an cumulative mass profile up to a radius <code>max_radius</code>. </p><p>It divides a sphere of radius <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a cumulative mass for  the <span>$n$</span>-th shell of</p><p class="math-container">\[M_n = \sum_{i = 1}^n m_i \, ,\]</p><p>where <span>$m_i$</span> is the total mass within the <span>$i$</span>-th shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same length units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two arrays. The first with the radial distances and the second with the accumulated masses,  of each shell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L358-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.max_length-Tuple{Matrix{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real}" href="#GADGETPlotting.max_length-Tuple{Matrix{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real}"><code>GADGETPlotting.max_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_length(data::Matrix{&lt;:Real})::Float64</code></pre><p>Maximum norm of the positions in <code>data</code>.</p><p><code>data</code> must be a matrix with three rows (x, y, and z coordinates respectively) and where  each column is a position.</p><p><strong>Arguments</strong></p><ul><li><code>data::Matrix{&lt;:Real}</code>: Positions of the particles.</li></ul><p><strong>Returns</strong></p><ul><li>The maximum norm of the position vectors in <code>data</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1134-L1147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#GADGETPlotting.metallicity_profile-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>GADGETPlotting.metallicity_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">metallicity_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    z_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a metallicity profile up to a radius <code>max_radius</code> (normalized to solar metallicity).</p><p>It divides a sphere of radius <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a relative metallicity for  the <span>$n$</span>-th shell of</p><p class="math-container">\[\rho_n = \dfrac{z_n}{M_n\,Z_\odot} \, ,\]</p><p>where <span>$M_n$</span> is the total mass and <span>$z_n$</span> the total content of metals, within the shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same length units,  and <code>z_data</code> and <code>mass_data</code> must be in the same mass units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>z_data::Vector{Float64}</code>: Metal content of the particles in mass units.</li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two arrays. The first with the radial distances and the second with the metallicities, of each shell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L281-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.num_integrate" href="#GADGETPlotting.num_integrate"><code>GADGETPlotting.num_integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_integrate(
    func::Function, 
    inf_lim::Float64, 
    sup_lim::Float64, 
    steps::Int64 = 200,
)::Float64</code></pre><p>Give the numerical integral of <code>func</code> between <code>inf_val</code> and <code>sup_val</code>. </p><p>The result is given by</p><p class="math-container">\[\int_\mathrm{inf\_lim}^\mathrm{sup\_lim} f(x) \mathrm{dx} \approx \sum_{i = 1}^\mathrm{steps} f(\mathrm{inf\_lim} + \mathrm{width}\,i ) \, ,\]</p><p>where <span>$\mathrm{width} = (\mathrm{sup\_lim} - \mathrm{inf\_lim}) / \mathrm{steps}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>func::Function</code>: 1D function to be integrated.</li><li><code>inf_lim::Float64</code>: Lower limit of the integral.</li><li><code>sup_lim::Float64</code>: Upper limit if the integral.</li><li><code>steps::Int64</code>: Number of subdivisions to be used for the discretization of  the [<code>inf_lim</code>, <code>sup_lim</code>] region.</li></ul><p><strong>Returns</strong></p><ul><li>The value of the integral.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; num_integrate(sin, 0, 3π)
1.9996298761360816

julia&gt; num_integrate(x -&gt; x^3 + 6 * x^2 + 9 * x + 2, 0, 4.69)
438.9004836958452

julia&gt; num_integrate(x -&gt; exp(x^x), 0, 1.0)
2.1975912134624904</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1030-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.pass_all-Tuple{String, String}" href="#GADGETPlotting.pass_all-Tuple{String, String}"><code>GADGETPlotting.pass_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pass_all(snap_file::String, type::String)::Vector{Int64}</code></pre><p>Default filter function for the <a href="https://ludwigboess.github.io/GadgetIO.jl/stable/api/#GadgetIO.read_blocks_over_all_files-Tuple{String,%20Array{String,%20N}%20where%20N}">read_blocks_over_all_files</a> function.</p><p>It does not filter out any particles, allowing the data acquisition functions to gather  all the data. </p><p><strong>Arguments</strong></p><ul><li><code>snap_file::String</code>: Snapshot file path.</li><li><code>type::String</code>: Particle type.<ul><li>&quot;gas&quot; -&gt; Gas particle. </li><li>&quot;dark_matter&quot; -&gt; Dark matter particle.</li><li>&quot;stars&quot; -&gt; Star particle.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A Vector with the indices of the allowed particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L955-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.quantities_2D-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Float64, Float64, Float64}" href="#GADGETPlotting.quantities_2D-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Float64, Float64, Float64}"><code>GADGETPlotting.quantities_2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quantities_2D(
    gas_mass_data::Vector{Float64},
    gas_distance_data::Vector{Float64},
    temperature_data::Vector{Float64},
    star_mass_data::Vector{Float64},
    star_distance_data::Vector{Float64},
    age_data::Vector{Float64},
    metal_mass_data::Matrix{Float64},
    fmol_data::Vector{Float64},
    temp_filter::Float64,
    age_filter::Float64,	
    max_r::Float64;
    bins::Int64 = 50,
)::Dict{String, Vector}</code></pre><p>Compute the surface density of several quantities. </p><p>The area densities are calculated by projecting the positions of the stars and the  particles of gas to the x-y plane. Then the space is subdivided in <code>bins</code> concentric  rings from 0 to <code>max_r</code>, each of equal width <code>max_r</code> / <code>bins</code>. This results in an area  for the <span>$n$</span>-th ring of</p><p class="math-container">\[A_n = π \, \mathrm{width}^2 \, (2 \, n - 1) \, .\]</p><p>So, the assigned SFR for that ring is </p><p class="math-container">\[\Sigma_\mathrm{SFR}^n = \frac{M_*^n}{\mathrm{age\_filter}\,A_n} \, ,\]</p><p>where <span>$M_*^n$</span> is the total mass of stars younger than <code>age_filter</code> within the ring.</p><p>Equivalently, the mass area density of the gas and stars is given by</p><p class="math-container">\[\Sigma_\rho^n = \frac{M_\rho^n}{A_n} \, ,\]</p><p class="math-container">\[\Sigma_*^n = \frac{M_*^n}{A_n} \, ,\]</p><p>where <span>$M_\rho^n$</span> is the total mass of gas colder than <code>temp_filter</code> within the ring.</p><p><code>temp_filter</code> and <code>temperature_data</code> must be in the same temperature units,  and <code>age_filter</code> and <code>age_data</code> must be in the same time units.</p><p>The rest of the parameters are define as follows</p><p class="math-container">\[\mathrm{SSFR}^n = \frac{\Sigma_\mathrm{SFR}^n}{\Sigma_{*\mathrm{(total)}}^n} \, ,\]</p><p class="math-container">\[\mathrm{SFE}^n = \frac{\Sigma_\mathrm{SFR}^n}{\Sigma_{\rho\mathrm{(total)}}^n} \, ,\]</p><p class="math-container">\[\mathrm{P}^n = \Sigma_{\rho\mathrm{(total)}}^n\left(\Sigma_{\rho\mathrm{(total)}}^n + \Sigma_{*\mathrm{(total)}}^n\right) \, ,\]</p><p class="math-container">\[\mathrm{Ψ/H_2}^n = \frac{\Sigma_\mathrm{SFR}^n \, A_n}{M_{H_2}^n} \, ,\]</p><p>where <span>$\Sigma_{\rho\mathrm{(total)}}^n$</span> is the mass density of all the gas,  <span>$\Sigma_{*\mathrm{(total)}}^n$</span> is the stellar density of all the stars and <span>$M_{H_2}^n$</span> is the total mass of molecular Hydrogen.</p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Vector{Float64}</code>: Masses of the gas particles.</li><li><code>gas_distance_data::Vector{Float64}</code>: 2D radial distances of the gas particles. </li><li><code>temperature_data::Vector{Float64}</code>: Temperatures of the gas particles.</li><li><code>star_mass_data::Vector{Float64}</code>: Masses of the stars.</li><li><code>star_distance_data::Vector{Float64}</code>: 2D radial distances of the stars.</li><li><code>age_data::Vector{Float64}</code>: Ages of the stars.</li><li><code>metal_mass_data::Matrix{Float64}</code>: Masses of the individual elements (H, O, He, C, etc.) within the gas particles.</li><li><code>fmol_data::Vector{Float64}</code>: Fraction of molecular Hydrogen of the gas particles.</li><li><code>temp_filter::Float64</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Unitful.Quantity</code>: Maximum age allowed for the stars.</li><li><code>max_r::Float64</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used. It has to be at  least 5.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with nine entries.<ul><li>Key &quot;GAS&quot; =&gt; Surface mass density of gas</li><li>Key &quot;COLD_GAS&quot; =&gt; Surface mass density of cold gas</li><li>Key &quot;STARS&quot; =&gt; Surface mass density of stars</li><li>Key &quot;OH&quot; =&gt; 12 + log10(oxygen<em>mass / hydrogen</em>mass)</li><li>Key &quot;SFR&quot; =&gt; Star formation rate surface density</li><li>Key &quot;SSFR&quot; =&gt; Specific star formation rate surface density</li><li>Key &quot;SFE&quot; =&gt; Star formation efficiency surface density</li><li>Key &quot;P&quot; =&gt; Proportional to the pressure</li><li>Key &quot;Psi_FMOL&quot; =&gt; Star formation rate per unit of molecular gas</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L656-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.relative" href="#GADGETPlotting.relative"><code>GADGETPlotting.relative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative(
    p::Plots.Plot,
    rx::Float64,
    ry::Float64,
    rz::Union{Float64, Nothing} = nothing; 
    &lt;keyword arguments&gt;
)::Union{NTuple{2, Float64}, NTuple{3, Float64}}</code></pre><p>Give the absolute coordinates within a plot, from the relative ones.</p><p>If any of the axes are in a logarithmic scale, you should set <code>log</code> appropriately to get  correct results.</p><p><strong>Arguments</strong></p><ul><li><code>p::Plots.Plot</code>: Plot for which the absolute coordinates will be calculated.</li><li><code>rx::Float64</code>: relative x coordinate, <code>rx</code> ∈ [0, 1].</li><li><code>ry::Float64</code>: relative y coordinate, <code>ry</code> ∈ [0, 1].</li><li><code>rz::Union{Float64,Nothing} = nothing</code>: relative z coordinate, <code>rz</code> ∈ [0, 1].</li><li><code>log::Union{NTuple{2, Bool}, NTuple{3, Bool}} = (false, false, false)</code>: If the x, y or z  axes are in a logarithmic scale.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the absolute coordinates: (x, y) or (x, y, z).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GADGETPlotting.relative(plot(rand(100)), 0.5, 0.5)
(50.5, 0.5047114800322484)

julia&gt; GADGETPlotting.relative(surface(rand(100, 100)), 0.5, 0.5, 0.5)
(50.5, 50.5, 0.5000284432744244)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L5-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.set_vertical_flags-Tuple{Union{Nothing, Tuple{Vector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:AbstractString}}, Plots.Plot}" href="#GADGETPlotting.set_vertical_flags-Tuple{Union{Nothing, Tuple{Vector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:AbstractString}}, Plots.Plot}"><code>GADGETPlotting.set_vertical_flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_vertical_flags(
    flags::Union{Tuple{Vector{&lt;:Real}, Vector{&lt;:AbstractString}}, Nothing}, 
    plot::Plots.Plot; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Draw vertical lines at specified positions.</p><p>If you only want labels for the vertical lines, the original plot should have <code>label = &quot;&quot;</code>.</p><p><strong>Arguments</strong></p><ul><li><code>flags::Union{Tuple{Vector{&lt;:Real}, Vector{&lt;:AbstractString}}, Nothing} = nothing</code>: The first  vector in the Tuple has the positions of the vetical lines. The second has the  corresponding labels.</li><li><code>plot::Plots.Plot</code>: Plot to which the vertical lines will be added.</li></ul><p><strong>Returns</strong></p><ul><li>New plot with the vertical lines added.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L1297-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.smooth_window-Tuple{Vector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, Int64}" href="#GADGETPlotting.smooth_window-Tuple{Vector{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Real, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, Int64}"><code>GADGETPlotting.smooth_window</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smooth_window(
    x_data::Vector{&lt;:Real},
    y_data::Vector{&lt;:Real},
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Separate the values in <code>x_data</code> in <code>bins</code> contiguous windows, and replaces every x and y  value within the window with the corresponding mean to smooth out the data. </p><p><strong>Arguments</strong></p><ul><li><code>x_data::Vector{&lt;:Real}</code>: x-axis data.</li><li><code>y_data::Vector{&lt;:Real}</code>: y-axis data.</li><li><code>bins::Int64</code>: Number of windows to be used in the smoothing.</li><li><code>log::Bool = false</code>: If the x-axis data will be separated using logarithmic bins.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with two arrays containing the smoothed out x and y data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/141afbdcc35299115fbec4666d5d83527dfcf7eb/src/auxiliary.jl#L136-L154">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_acquisition/">« Data Acquisition Functions</a><a class="docs-footer-nextpage" href="../func_list/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 November 2021 00:58">Monday 15 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
