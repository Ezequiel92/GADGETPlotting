<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GADGETPlotting.jl · GADGETPlotting.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GADGETPlotting.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>GADGETPlotting.jl</a><ul class="internal"><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Internal-functions"><span>Internal functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>GADGETPlotting.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GADGETPlotting.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ezequiel92/GADGETPlotting/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GADGETPlotting.jl"><a class="docs-heading-anchor" href="#GADGETPlotting.jl">GADGETPlotting.jl</a><a id="GADGETPlotting.jl-1"></a><a class="docs-heading-anchor-permalink" href="#GADGETPlotting.jl" title="Permalink"></a></h1><ul><li><a href="#GADGETPlotting.jl">GADGETPlotting.jl</a></li><ul><li><a href="#Exported-Functions">Exported Functions</a></li><ul><li><a href="#Pipelines">Pipelines</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Testing">Testing</a></li></ul><li><a href="#Internal-functions">Internal functions</a></li><ul><li><a href="#Data-Acquisition">Data Acquisition</a></li><li><a href="#Auxiliary">Auxiliary</a></li></ul><li><a href="#Index">Index</a></li></ul></ul><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><h3 id="Pipelines"><a class="docs-heading-anchor" href="#Pipelines">Pipelines</a><a id="Pipelines-1"></a><a class="docs-heading-anchor-permalink" href="#Pipelines" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.scatter_grid_pipeline" href="#GADGETPlotting.scatter_grid_pipeline"><code>GADGETPlotting.scatter_grid_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scatter_grid_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the scatter_grid_plot function as one image per snapshot,  and then generate a GIF and video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;scatter_grid&quot;</code>: Path to the output directory. The images will  be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX  is the number of the snapshot. The GIF and the video will be stored in <code>output\_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the GR backend can be used, namely &quot;.pdf&quot;, &quot;.ps&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L5-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_map_pipeline" href="#GADGETPlotting.density_map_pipeline"><code>GADGETPlotting.density_map_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_map_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the density_map_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;density_map&quot;</code>: Path to the output directory. The images will  be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX  is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>plane::String = &quot;All&quot;</code>: Indicates which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the  GR backend can be used, namely &quot;.pdf&quot;, &quot;.ps&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L112-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.star_map_pipeline" href="#GADGETPlotting.star_map_pipeline"><code>GADGETPlotting.star_map_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">star_map_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the star_map_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;star_map&quot;</code>: Path to the output directory. The images will  be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX  is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>plane::String = &quot;All&quot;</code>: Indicates which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the  GR backend can be used, namely &quot;.pdf&quot;, &quot;.ps&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L217-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.gas_star_evolution_pipeline" href="#GADGETPlotting.gas_star_evolution_pipeline"><code>GADGETPlotting.gas_star_evolution_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gas_star_evolution_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of <code>gas_star_evolution_plot</code> for the last snapshot as one image and  generate a GIF and a video animating the whole evolution for all snapshots. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;gas_star_evolution&quot;</code>: Path to the output directory.  The image will be stored in <code>output_path</code>/images/ and will be named  <code>base_name</code>_XXX<code>format</code> where XXX is the number of the last snapshot.  The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the  GR backend can be used, namely &quot;.pdf&quot;, &quot;.ps&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L331-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.evolution_summary_pipeline" href="#GADGETPlotting.evolution_summary_pipeline"><code>GADGETPlotting.evolution_summary_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolution_summary_pipeline(
    base_name::String,
    source_path::String,
    fig_name::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Produce up to three figures summarizing the time evolution of the simulation.</p><p>The plotted parameters are the number of particles, the total mass, the baryonic  fractional mass and the star formation rate (SFR), the first three for gas and stars. If the simulation is Newtonian, only one figure is produced (parameters vs. time), but if the simulation is cosmological, three figures are produced (parameters vs. time, parameters vs. scale factor and parameters vs. redshift).</p><p>Args:</p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>fig_name::String</code>: Base name for the figures. The images will be named <code>fig_name</code>_vs_XXX<code>format</code> where XXX is &#39;time&#39;, &#39;redshift&#39; or &#39;scale_factor&#39;.</li><li><code>output_path::String = &quot;evolution_summary&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>mass_factor::Int64 = 0</code>: Numerical exponent to scale the mass, e.g. if mass_factor = 10  the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64 = 0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 the corresponding axis will be scaled by 10^4.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L819-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compare_simulations_pipeline" href="#GADGETPlotting.compare_simulations_pipeline"><code>GADGETPlotting.compare_simulations_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compare_simulations_pipeline(
    base_name::Vector{String},
    source_path::Vector{String},
    labels::Array{String, 2},
    fig_name::String,
    x_quantity::String,
    y_quantity::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Make a figure comparing <code>y_quantity</code> vs. <code>x_quantity</code> for several simulations.</p><p><code>x_quantity</code> and <code>y_quantity</code> can be any magnitude used in the timeSeriesData  function, namely:</p><ul><li>&quot;scale_factor&quot;                  </li><li>&quot;redshift&quot;                  </li><li>&quot;clock_time&quot; (Physical time)</li><li>&quot;sfr&quot; (SFR) 			              </li><li>&quot;sfr_prob&quot; (SFR probability - Not normalized) 			           </li><li>&quot;gas_number&quot; (Gas particle number) 	            </li><li>&quot;dm_number&quot; (Dark matter particle number)		               </li><li>&quot;star_number&quot; (Star number)         </li><li>&quot;gas_mass&quot; (Total gas mass)               </li><li>&quot;dm_mass&quot; (Total dark matter mass)	            </li><li>&quot;star_mass&quot; (Total star mass)	</li><li>&quot;gas_density&quot; (Total gas density)	               </li><li>&quot;gas_frac&quot; (Gas fraction)		                </li><li>&quot;dm_frac&quot; (Dark matter fraction)		                </li><li>&quot;star_frac&quot; (Star fraction)	                   </li><li>&quot;gas<em>bar</em>frac&quot; (Baryonic gas fraction)                  </li><li>&quot;star<em>bar</em>frac&quot; (Baryonic star fraction)</li></ul><p>The numeric values of a quantity can also be saved as a text files for the simulations.  One column per simulation, one row per sanpshot.</p><p><strong>Arguments</strong></p><ul><li><code>base_name::Vector{String}</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations, e.g. [label1 label2 ...].</li><li><code>fig_name::String</code>: Base name for the figure. The file will be named <code>fig_name</code><em>`y</em>quantity<code>_vs_</code>x_quantity<code></code>format`.</li><li><code>x_quantity::String</code>: Physical magnitude for the x axis. </li><li><code>y_quantity::String</code>: Physical magnitude for the y axis.</li><li><code>output_path::String = &quot;compare_simulations&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given, no title is  printed.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>scale::Vector{Symbol} = [:identity, :identity]</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>smooth_data::Bool = false</code>: If true a smoothing window with no weighs is applied to  the y data. If false (the default) no transformation occurs.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data, only relevant if <code>smooth_data = true</code>. </li><li><code>legend_pos::Symbol = :bottomright</code>: Position of the legend, e.g. :topleft.</li><li><code>text_quantity::String = &quot;&quot;</code>: Name of the quantity to be saved in a text file.  Any magnitude used in the timeSeriesData function can be used. If left empty no  text file will be produced.</li><li><code>file_name::String = &quot;results&quot;</code>: Name of the <code>.dat</code> that will be generated if  <code>text_quantity</code> is not an empty string.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used,  e.g. UnitfulAstro.Msun.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used,  e.g. UnitfulAstro.Myr.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.</li><li><code>density_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3</code>: Unit of  density to be used in the output, all available density units in Unitful.jl and  UnitfulAstro.jl can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L924-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_histogram_pipeline" href="#GADGETPlotting.density_histogram_pipeline"><code>GADGETPlotting.density_histogram_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_histogram_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the density_histogram_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;density_histogram&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where  XXX is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>density_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3</code>: Unit of  density to be used in the output, all available density units in Unitful and UnitfulAstro  can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1119-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile_pipeline" href="#GADGETPlotting.density_profile_pipeline"><code>GADGETPlotting.density_profile_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_profile_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64,
    type::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the density_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>output_path::String = &quot;density_profile&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where  XXX is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1227-L1283">source</a></section><section><div><pre><code class="language-none">density_profile_pipeline(
    base_name::Vector{String},
    source_path::Vector{String},
    anim_name::String,
    frame_rate::Int64,
    type::String,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the density_profile_plot function for several simulations as one image  per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::Vector{String}</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>output_path::String = &quot;density_profile&quot;</code>: Path to the output directory. The images will  be stored in <code>output_path</code>/images/ and will be named frame<em>XXX<code>format</code> where XXX is the  ordinal of the frame. The GIF and the video will be stored in `output</em>path`.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1373-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile_pipeline" href="#GADGETPlotting.metallicity_profile_pipeline"><code>GADGETPlotting.metallicity_profile_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">metallicity_profile_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64,
    type::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the metallicity_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>output_path::String = &quot;metallicity_profile&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where  XXX is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1530-L1578">source</a></section><section><div><pre><code class="language-none">metallicity_profile_pipeline(
    base_name::Vector{String},
    source_path::Vector{String},
    anim_name::String,
    frame_rate::Int64,
    type::String,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the metallicity_profile_plot function for several simulations as one  image per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::Vector{String}</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>labels::Array{String,2}</code>: Labels for the different simulations.</li><li><code>output_path::String = &quot;metallicity_profile&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named frame<em>XXX<code>format</code> where XXX is  the ordinal of the frame. The GIF and the video will be stored in `output</em>path`.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used.  Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1667-L1721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile_pipeline" href="#GADGETPlotting.mass_profile_pipeline"><code>GADGETPlotting.mass_profile_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mass_profile_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64,
    type::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the mass_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>output_path::String = &quot;mass_profile&quot;</code>: Path to the output directory. The images will be  stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX is  the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the mass, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1819-L1875">source</a></section><section><div><pre><code class="language-none">mass_profile_pipeline(
    base_name::Vector{String},
    source_path::Vector{String},
    anim_name::String,
    frame_rate::Int64,
    type::String,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the mass_profile_plot function for several simulations as one image  per snapshot, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::Vector{String}</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>output_path::String = &quot;mass_profile&quot;</code>: Path to the output directory. The images will be  stored in <code>output_path</code>/images/ and will be named frame<em>XXX<code>format</code> where XXX is the  ordinal of the frame. The GIF and the video will be stored in `output</em>path`.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the mass, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn&#39;t have to be the same  as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L1965-L2023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.cmdf_pipeline" href="#GADGETPlotting.cmdf_pipeline"><code>GADGETPlotting.cmdf_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cmdf_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the cmdf_plot function as one image per snapshot, if there are stars  present, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;CMDF&quot;</code>: Path to the output directory. The images will be stored  in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX is the  number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the time  stamps, all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L464-L499">source</a></section><section><div><pre><code class="language-none">cmdf_pipeline(
    base_name::Vector{String},
    source_path::Vector{String},
    anim_name::String,
    frame_rate::Int64,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the cmdf_plot function for several simulations as one image per snapshot, if there are stars present, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::Vector{String}</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>output_path::String = &quot;CMDF&quot;</code>: Path to the output directory. The images will be stored  in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX is the  ordinal of the frame. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the time stamps, all available time units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L579-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.birth_histogram_pipeline" href="#GADGETPlotting.birth_histogram_pipeline"><code>GADGETPlotting.birth_histogram_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">birth_histogram_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the birth<em>histogram</em>plot function as one image per snapshot, if there are  stars present, and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;birth_histogram&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where  XXX is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L706-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.sfr_txt_pipeline" href="#GADGETPlotting.sfr_txt_pipeline"><code>GADGETPlotting.sfr_txt_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sfr_txt_pipeline(
    snapshots::Vector{String},
    source_path::Vector{String},
    x_axis::Int64,
    y_axis::Vector{Int64}; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the sfr_txt_plot function as one image per simulation or one image  per column depending on <code>comparison_type</code>.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>snapshots::Vector{String}</code>: Path to the snapshot files, to get its headers.</li><li><code>source_path::Vector{String}</code>: Paths to the directories containing the sfr.txt files,  set in the GADGET variable OutputDir.</li><li><code>x_axis::Int64</code>: Column number for the x axis.</li><li><code>y_axis::Vector{Int64}</code>: Column numbers for the y axis.</li><li><code>output_path::String = &quot;sfr_txt&quot;</code>: Path to the output directory.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>comparison_type::Int64 = 0</code>: Selects which parameters (columns or simulations) will be compared: 0 -&gt; Different columns are compared, for a single simulation (one plot per simulation). 1 -&gt; Different simulations are compared, using the same column (one plot per column).</li><li><code>title::Vector{String} = String[]</code>: Titles for the figures. If an empty string is given, no title is printed.</li><li><code>names::Vector{String} = String[]</code>: Names for the files. If an empty string is given, the  images will be assigned a number given by the order of <code>source_path</code>.</li><li><code>labels::Union{Nothing, Array{String, 2}} = nothing</code>: Labels for the different  simulations. Only relevant if <code>comparison_type = 1</code>.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data.  The default is 0, i.e. no smoothing. It will apply equally to every figure produced.</li><li><code>scale::NTuple{2, Symbol} = (:identity, :identity)</code>: Scaling to be used for the x and y  axes. It will apply equally to every figure produced. The options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>min_filter::NTuple{2, Float64} = (-Inf, -Inf)</code>: Value filter for the x and y axes.  It will apply equally to every figure produced. If a value of the x data is lower  than min<em>filter[1], then it is deleted. Equivalently with the y axis and min\</em>filter[2].  The default is -Inf for both, i.e. no filtering.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L2122-L2182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.temperature_histogram_pipeline" href="#GADGETPlotting.temperature_histogram_pipeline"><code>GADGETPlotting.temperature_histogram_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temperature_histogram_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the temperature_histogram_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;temperature_histogram&quot;</code>: Path to the output directory. The images  will be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where  XXX is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>temp_unit::Unitful.FreeUnits = Unitful.K</code>: Unit of temperature to be used in the  output, all available temperature units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L2273-L2307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.rho_temp_pipeline" href="#GADGETPlotting.rho_temp_pipeline"><code>GADGETPlotting.rho_temp_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rho_temp_pipeline(
    base_name::String,
    source_path::String,
    anim_name::String,
    frame_rate::Int64; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the rho_temp_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. </p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>anim_name::String</code>: File name of the generated video and GIF, without the extension.</li><li><code>frame_rate::Int64</code>: Frame rate of the output video and GIF.</li><li><code>output_path::String = &quot;rho_vs_temp&quot;</code>: Path to the output directory. The images will be  stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX is  the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>temp_unit::Unitful.FreeUnits = Unitful.K</code>: Unit of temperature to be used in the  output, all available temperature units in Unitful and UnitfulAstro can be used.</li><li><code>density_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3</code>: Unit of  density to be used in the output, all available density units in Unitful and UnitfulAstro  can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L2375-L2412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_pipeline" href="#GADGETPlotting.kennicutt_schmidt_pipeline"><code>GADGETPlotting.kennicutt_schmidt_pipeline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_pipeline(
    base_name::String,
    source_path::String; 
    &lt;keyword arguments&gt;
)::Nothing</code></pre><p>Save the results of the kennicutt_schmidt_plot function as one image per snapshot.</p><p>It will produce output only for the snapshots that have enough young stars to produce  at least five data points for the linear fitting.</p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.</li><li><code>source_path::String</code>: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.</li><li><code>output_path::String = &quot;Kennicutt_Schmidt&quot;</code>: Path to the output directory. The images will  be stored in <code>output_path</code>/images/ and will be named <code>base_name</code>_XXX<code>format</code> where XXX  is the number of the snapshot. The GIF and the video will be stored in <code>output_path</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>step::Int64 = 1</code>: Step used to traverse the list of snapshots. The default is 1,  i.e. all snapshots will be plotted.</li><li><code>temp_filter::Unitful.Quantity = Inf * Unitful.K</code>: Maximum temperature allowed for the  gas particles.</li><li><code>age_filter::Unitful.Quantity = 20.UnitfulAstro.Myr</code>: Maximum star age allowed for the  calculation of the SFR.</li><li><code>max_r::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Maximum distance up to which the  parameters will be calculated, with units.</li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used.  It has to be at least 5.</li><li><code>error_formating::String = &quot;std_error&quot;</code>: What type of error for the fitting results to  print. The options are: &quot;std<em>error&quot;: `mean ± standard</em>error<code>. &quot;conf_interval&quot;:</code>mean ± max(upper_95% - mean, mean - lower_95%)`.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.</li><li><code>format::String = &quot;.png&quot;</code>: File format of the output figure. All formats supported by the pgfplotsx backend can be used, namely &quot;.pdf&quot;, &quot;.tex&quot;, &quot;.svg&quot; and &quot;.png&quot;. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/pipelines.jl#L2482-L2530">source</a></section></article><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.scatter_grid_plot" href="#GADGETPlotting.scatter_grid_plot"><code>GADGETPlotting.scatter_grid_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scatter_grid_plot(position_data::Dict{String, Any})::Plots.Plot</code></pre><p>Make 9 scatter plots of the positions of the gas, dark matter and stars particles in the  XY, XZ and YZ planes.</p><p>The result is a single figure in a 3x3 layout with its axes in the unit given by <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_map_plot" href="#GADGETPlotting.density_map_plot"><code>GADGETPlotting.density_map_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_map_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    density_data::Dict{String, Any}
    hsml_data::Dict{String, Any}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of the gas density in the XY, XZ and/or YZ planes. </p><p>The axes are in the units given by <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String,Any}</code>: Return value of the massData function.</li><li><code>density_data::Dict{String,Any}</code>: Return value of the densityData function.</li><li><code>hsml_data::Dict{String,Any}</code>: Return value of the hsmlData function.</li><li><code>plane::String = &quot;All&quot;</code>: String indicating which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>axes_color::Symbol = :white</code>: Color of the axes passing through (0.0, 0.0), only relevant  if <code>axes = true</code>.</li><li><code>color::Symbol = :inferno</code>: Color scheme for the figure.  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn<em>rocket</em>gradient, :YlOrRd_9 and :inferno, which is the default.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L181-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.star_map_plot" href="#GADGETPlotting.star_map_plot"><code>GADGETPlotting.star_map_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">star_map_plot(position_data::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make a plot of the star density in the XY, XZ and/or YZ planes. </p><p>The axes are in the units <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li><li><code>plane::String=&quot;All&quot;</code>: String indicating which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>box_factor::Float64=1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>axes_color::Symbol = :white</code>: Color of the axes passing through (0.0, 0.0), only relevant  if <code>axes = true</code>.</li><li><code>color::Symbol = :inferno</code>: Color scheme for the figure.  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn<em>rocket</em>gradient, :YlOrRd_9 and :inferno, which is the default.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L448-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.gas_star_evolution_plot" href="#GADGETPlotting.gas_star_evolution_plot"><code>GADGETPlotting.gas_star_evolution_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gas_star_evolution_plot(
    index::Int64,
    time_series::Dict{String, Any},
    position_data::Dict{String, Any}, 
)::Plots.Plot</code></pre><p>Makes 3 plots, the position of the particles in the XY plane, the baryonic fractional mass  and the SFR. The first two for stars and gas. All in a single figure with a 1x2 layout</p><p>The figure is created with the time running from 0 to <code>time_series[&quot;clock_time&quot;][index]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>index::Int64</code>: Index of the final time step up to which the figure will show the  evolution of the variables.</li><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.	</li><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L649-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.cmdf_plot" href="#GADGETPlotting.cmdf_plot"><code>GADGETPlotting.cmdf_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cmdf_plot(
    m_data::Dict{String, Any}, 
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a cumulative metallicity distribution function plot, for a given time step.</p><p><code>m_data</code> and <code>z_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>m_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>z_data::Dict{String, Any}</code>: Return value of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64</code>: Number of subdivisions of the metallicity to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L811-L833">source</a></section><section><div><pre><code class="language-none">cmdf_plot(
    m_data::Vector{Dict{String, Any}}, 
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a cumulative metallicity distribution function plot of several datasets,  for a given time step.</p><p><code>m_data</code> and <code>z_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>m_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>z_data::Vector{Dict{String, Any}}</code>: Return values of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>bins::Int64</code>: Number of subdivisions of the metallicity to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L889-L914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.birth_histogram_plot" href="#GADGETPlotting.birth_histogram_plot"><code>GADGETPlotting.birth_histogram_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">birth_histogram_plot(birth_data::Dict{String, Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make a histogram of the number of stars born at a certain radial distance.</p><p><strong>Arguments</strong></p><ul><li><code>birth_data::Dict{String, Any}</code>: Return value of the birthPlace function.</li><li><code>bins::Int64 = 50</code>: Number of bins to use in the histogram.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L995-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.time_series_plot" href="#GADGETPlotting.time_series_plot"><code>GADGETPlotting.time_series_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_series_plot(time_series::Dict{String, Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. </p><p>All the plots show the evolution of the corresponding parameter versus time.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1032-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.scale_factor_series_plot" href="#GADGETPlotting.scale_factor_series_plot"><code>GADGETPlotting.scale_factor_series_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale_factor_series_plot(time_series::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars.</p><p>All the plots show the evolution of the corresponding parameter versus the scale factor.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1170-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.redshift_series_plot" href="#GADGETPlotting.redshift_series_plot"><code>GADGETPlotting.redshift_series_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">redshift_series_plot(time_series::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. </p><p>All the plots show the evolution of the corresponding parameter versus the redshift.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1307-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compare_simulations_plot" href="#GADGETPlotting.compare_simulations_plot"><code>GADGETPlotting.compare_simulations_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compare_simulations_plot(
    data::Vector{Dict{String, Any}},
    x_quantity::String,
    y_quantity::String,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot comparing among several simulations <code>y_quantity</code> vs. <code>x_quantity</code> .</p><p>The data of each simulation must be in the same units, and <code>x_quantity</code> and <code>y_quantity</code>  can be any magnitude used in the timeSeriesData function, namely:</p><ul><li>&quot;scale_factor&quot;                  </li><li>&quot;redshift&quot;                  </li><li>&quot;clock_time&quot; (Physical time)</li><li>&quot;sfr&quot; (SFR) 			              </li><li>&quot;sfr_prob&quot; (SFR probability - Not normalized) 			           </li><li>&quot;gas_number&quot; (Gas particle number) 	            </li><li>&quot;dm_number&quot; (Dark matter particle number)		               </li><li>&quot;star_number&quot; (Star number)         </li><li>&quot;gas_mass&quot; (Total gas mass)               </li><li>&quot;dm_mass&quot; (Total dark matter mass)	            </li><li>&quot;star_mass&quot; (Total star mass)		</li><li>&quot;gas_density&quot; (Total gas density)	               </li><li>&quot;gas_frac&quot; (Gas fraction)		                </li><li>&quot;dm_frac&quot; (Dark matter fraction)		                </li><li>&quot;star_frac&quot; (Star fraction)	                   </li><li>&quot;gas<em>bar</em>frac&quot; (Baryonic gas fraction)                  </li><li>&quot;star<em>bar</em>frac&quot; (Baryonic star fraction)</li></ul><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Dict{String,Any}}</code>: Return value of the timeSeriesData function for  every simulation in a Vector, e.g. [data_sim1, data_sim2].</li><li><code>x_quantity::String</code>: String indicating the physical magnitude for the x axis. </li><li><code>y_quantity::String</code>: String indicating the physical magnitude for the y axis.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is  printed, which is the default.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>scale::Vector{Symbol} = [:identity, :identity],</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>smooth_data::Bool = false</code>: If true a smoothing window with no weighs is applied to  the y data. If false, no transformation occurs.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data, only relevant if <code>smooth_data = true</code>. </li><li><code>legend_pos::Symbol = :bottomright</code>: Position of the legend, e.g. :topleft.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1444-L1500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_histogram_plot" href="#GADGETPlotting.density_histogram_plot"><code>GADGETPlotting.density_histogram_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_histogram_plot(
    density_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a histogram of the densities of the gas particles.</p><p><strong>Arguments</strong></p><ul><li><code>density_data::Dict{String,Any}</code>: Return value of the densityData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64 = 20</code>: Number of bins to use in the histogram.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale <code>density_data</code>, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1721-L1740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile_plot" href="#GADGETPlotting.density_profile_plot"><code>GADGETPlotting.density_profile_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a density profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1792-L1820">source</a></section><section><div><pre><code class="language-none">density_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a density profile plot comparing several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Vector of return values of the positionData  function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Vector of return values of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L1920-L1951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile_plot" href="#GADGETPlotting.metallicity_profile_plot"><code>GADGETPlotting.metallicity_profile_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">metallicity_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a metallicity profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>z_data::Dict{String ,Any}</code>: Return value of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2112-L2140">source</a></section><section><div><pre><code class="language-none">metallicity_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a metallicity profile plot comparing several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Return values of the positionData function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>z_data::Vector{Dict{String, Any}}</code>: Return values of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2228-L2258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile_plot" href="#GADGETPlotting.mass_profile_plot"><code>GADGETPlotting.mass_profile_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mass_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make an accumulated mass profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2401-L2429">source</a></section><section><div><pre><code class="language-none">mass_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make an accumulated mass profile plot of several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Return values of the positionData function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2525-L2555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.sfr_txt_plot" href="#GADGETPlotting.sfr_txt_plot"><code>GADGETPlotting.sfr_txt_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sfr_txt_plot(
    data::Dict{Union{Int64, String}, Any},
    x_axis::Int64,
    y_axis::Vector{Int64}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of columns <code>y_axis</code> vs. column <code>x_axis</code>, of the sfr.txt text file.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{Union{Int64, String}, Any}</code>: Return values of the <code>sfr_txt_data</code> function.</li><li><code>x_axis::Int64</code>: Column number for the x axis.</li><li><code>y_axis::Vector{Int64}</code>: Vector of columns numbers for the y axis.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is printed, which is the default.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.</li><li><code>scale::NTuple{2, Symbol} = (:identity, :identity)</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>min_filter::NTuple{2, Float64} = (-Inf, -Inf)</code>: Value filter for the x and y axes. If a value of the x data is lower than <code>min_filter[1]</code>, then it is deleted. Equivalently  with the y axis and <code>min_filter[2]</code>. The default is -Inf for both, i.e. no filtering.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2711-L2747">source</a></section><section><div><pre><code class="language-none">sfr_txt_plot(
    data::Vector{Dict{Union{Int64, String}, Any}},
    x_axis::Int64,
    y_axis::Int64,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot comparing among several simulations <code>y_axis</code> vs. column <code>x_axis</code>,  of the sfr.txt text file.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Dict{Union{Int64, String}, Any}}</code>: Vector of return values of the  <code>sfr_txt_data</code> function.</li><li><code>x_axis::Int64</code>: Column number for the x axis.</li><li><code>y_axis::Int64</code>: Column number for the y axis.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is printed, which is the default.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.</li><li><code>scale::NTuple{2, Symbol} = (:identity, :identity)</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>min_filter::NTuple{2, Float64} = (-Inf, -Inf)</code>: Value filter for the x and y axes. If a value of the x data is lower than <code>min_filter[1]</code>, then it is deleted. Equivalently  with the y axis and <code>min_filter[2]</code>. The default is -Inf for both, i.e. no filtering.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L2883-L2923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.temperature_histogram_plot" href="#GADGETPlotting.temperature_histogram_plot"><code>GADGETPlotting.temperature_histogram_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temperature_histogram_plot(
    temperature_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a histogram of the logarithm of the gas particles&#39; temperatures.</p><p><strong>Arguments</strong></p><ul><li><code>temperature_data::Dict{String,Any}</code>: Return value of the tempData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64 = 20</code>: Number of bins to use in the histogram.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L3132-L3149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.rho_temp_plot" href="#GADGETPlotting.rho_temp_plot"><code>GADGETPlotting.rho_temp_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rho_temp_plot(
    temperature_data::Dict{String, Any},
    density_data::Dict{String, Any},
    time::Unitful.Quantity,
)::Plots.Plot</code></pre><p>Make a plot of log10(ρ) vs. log10(T), for the gas particles at a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>temperature_data::Dict{String,Any}</code>: Return value of the tempData function.</li><li><code>density_data::Dict{String, Any}</code>: Return value of the densityData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L3194-L3211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_plot" href="#GADGETPlotting.kennicutt_schmidt_plot"><code>GADGETPlotting.kennicutt_schmidt_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_plot(
    gas_mass_data::Dict{String, Any},
    temperature_data::Dict{String, Any},
    star_mass_data::Dict{String, Any},
    age_data::Dict{String, Any},
    pos_data::Dict{String, Any},
    temp_filter::Unitful.Quantity,
    age_filter::Unitful.Quantity,
    max_r::Unitful.Quantity,
    time::Unitful.Quantity;
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of the Kennicutt-Schmidt law for a given snapshot, with its fit and  the measured values superimposed for comparison. </p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Dict{String, Any}</code>: Return value of the massData function, for gas.</li><li><code>temperature_data::Dict{String, Any}</code>: Return value of the tempData function.</li><li><code>star_mass_data::Dict{String, Any}</code>: Return value of the massData function, for stars.</li><li><code>age_data::Dict{String, Any}</code>: Return value of the ageData function.</li><li><code>pos_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>temp_filter::Unitful.Quantity</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Unitful.Quantity</code>: Maximum star age allowed for the calculation of the SFR.  It should aproximately equal to the time step of the snapshots.</li><li><code>max_r::Unitful.Quantity</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot. </li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used.  It has to be at least 5.</li><li><code>error_formating::String = &quot;std_error&quot;</code>: What to print as error values. The options are: &quot;std_error&quot;: <code>mean ± standard_error</code>. &quot;conf_interval&quot;: <code>mean ± max(upper_95% - mean, mean - lower_95%)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of Plots.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/plotting.jl#L3274-L3311">source</a></section></article><h3 id="Testing"><a class="docs-heading-anchor" href="#Testing">Testing</a><a id="Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Testing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.comparison" href="#GADGETPlotting.comparison"><code>GADGETPlotting.comparison</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">comparison(
    x::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}, 
    y::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two numbers, numeric arrays or numeric tuples are approximately equal.</p><p><strong>Arguments</strong></p><ul><li><code>x::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}</code>: First element to be compared.</li><li><code>y::Union{Real, AbstractArray{&lt;:Real}, Tuple{Vararg{Real}}}</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements (X, Y) in (x, y) pass <code>julia norm(X - Y) &lt;= max(atol, rtol * max(norm(X), norm(Y)))</code>`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L845-L866">source</a></section><section><div><pre><code class="language-none">comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool</code></pre><p>Determines is two elements are equal.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: First element to be compared.</li><li><code>y</code>: Second element to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance (for compatibility).</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance (for compatibility).</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if <code>x == y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L878-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.deep_comparison" href="#GADGETPlotting.deep_comparison"><code>GADGETPlotting.deep_comparison</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deep_comparison(
    x::Dict, 
    y::Dict; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two dictionaries are approximately equal.</p><p>Numeric elements are compared with <code>comparison()</code>, everything else with <code>isequal()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Dict</code>: First dictionary to be compared.</li><li><code>y::Dict</code>: Second dictionary to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L898-L918">source</a></section><section><div><pre><code class="language-none">deep_comparison(
    x::Union{AbstractArray, Tuple}, 
    y::Union{AbstractArray, Tuple}; 
    atol::Float64 = 1e-5, 
    rtol::Float64 = 1e-5,
)::Bool</code></pre><p>Determines is two arrays or tuples are approximately equal.</p><p>Numeric elements are compared with <code>comparison()</code>, everything else with <code>isequal()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Union{AbstractArray, Tuple}</code>: First array to be compared.</li><li><code>y::Union{AbstractArray, Tuple}</code>: Second array to be compared.</li><li><code>atol::Float64 = 1e-5</code>: Absolute tolerance for numeric elements.</li><li><code>rtol::Float64 = 1e-5</code>: Relative tolerance for numeric elements.</li></ul><p><strong>Returns</strong></p><ul><li>Return <code>true</code> if every pair of elements pass the equality tests.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L934-L954">source</a></section></article><h2 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h2><h3 id="Data-Acquisition"><a class="docs-heading-anchor" href="#Data-Acquisition">Data Acquisition</a><a id="Data-Acquisition-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Acquisition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_snapshot_path" href="#GADGETPlotting.get_snapshot_path"><code>GADGETPlotting.get_snapshot_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_snapshot_path(
    base_name::String,
    source_path::String,
)::Dict{String, Vector{String}}</code></pre><p>Get the paths to the GADGET output files, grouping them by snapshot.</p><p><strong>Arguments</strong></p><ul><li><code>base_name::String</code>: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.</li><li><code>source_path::String</code>: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries. <ul><li>Key &quot;numbers&quot; =&gt; A Vector with the numbers that characterize each snapshot.</li><li>Key &quot;snap_files&quot; =&gt; A Vector with the paths to the snapshot files.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_time_evolution" href="#GADGETPlotting.get_time_evolution"><code>GADGETPlotting.get_time_evolution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_evolution(snap_files::Vector{String}; &lt;keyword arguments&gt;)::Dict{String, Any}</code></pre><p>Get several parameters defined at every snapshot, as a series of values for the whole  simulation. </p><p>The parameters are:</p><ul><li>&quot;scale_factor&quot;                  </li><li>&quot;redshift&quot;                  </li><li>&quot;clock_time&quot; (Physical time)</li><li>&quot;sfr&quot; (SFR) 			              </li><li>&quot;sfr_prob&quot; (SFR probability - Not normalized) 			           </li><li>&quot;gas_number&quot; (Gas particle number) 	            </li><li>&quot;dm_number&quot; (Dark matter particle number)		               </li><li>&quot;star_number&quot; (Star number)         </li><li>&quot;gas_mass&quot; (Total gas mass)               </li><li>&quot;dm_mass&quot; (Total dark matter mass)	            </li><li>&quot;star_mass&quot; (Total star mass)	</li><li>&quot;gas_density&quot; (Global gas density)	               </li><li>&quot;gas_frac&quot; (Gas fraction)		                </li><li>&quot;dm_frac&quot; (Dark matter fraction)		                </li><li>&quot;star_frac&quot; (Star fraction)	                   </li><li>&quot;gas<em>bar</em>frac&quot; (Baryonic gas fraction)                  </li><li>&quot;star<em>bar</em>frac&quot; (Baryonic star fraction)</li></ul><p><strong>Arguments</strong></p><ul><li><code>snap_files::Vector{String}</code>: Output of the function <code>get_snapshot_paths</code> corresponding  to the key &quot;snap_files&quot;, containing an Array with the paths to the snapshots.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful.jl and UnitfulAstro.jl can be used.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful.jl and UnitfulAstro.jl  can be used.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.</li><li><code>density_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3</code>: Unit of  density to be used in the output, all available density units in Unitful.jl and  UnitfulAstro.jl can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary.<ul><li>Key &quot;{property}&quot; =&gt; A Vector with the numeric values  of the {property} in the key (one value per snapshot) for the whole simulation. </li><li>Key &quot;units&quot; =&gt; A dictionary with the units used, for easy piping with other functions.</li><li>Key &quot;labels&quot; =&gt; A dictionary with the labels to be used when plotting the quantities.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L51-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_position" href="#GADGETPlotting.get_position"><code>GADGETPlotting.get_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_position(snapshot::String; &lt;keyword arguments&gt;)::Dict{String, Any}</code></pre><p>Get the coordinates of the particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>box_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc</code>: Size of the plotting region if  vacuum boundary conditions were used. It has to have units but they don&#39;t have to be  the same as <code>length_unit</code>.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with six entries.<ul><li>Keys &quot;gas&quot;, &quot;dark_matter&quot;, &quot;stars&quot; =&gt; 2 dimensional arrays with the positions of  the particles of the type given by the key. Each row is a  particle and each column correspond to coordinates x, y and z respectively.</li><li>Key &quot;box_size&quot; =&gt; The range of values for the plotting of the positions,  i.e. a range of ± <code>box_size</code> if vacuum boundary conditions were used,  or (0, <code>header.boxsize</code>) if periodic boundary conditions were used. Notice how the side length of the region is 2 * <code>box_size</code> for vacuum boundary  conditions and <code>header.boxsize</code> for periodic boundary conditions.</li><li>Key &quot;periodic&quot; =&gt; A Boolean indicating the type of boundary condition. false -&gt; vacuum boundary condition. true -&gt; periodic boundary condition.</li><li>Key &quot;unit&quot; =&gt; The unit of length used, i.e. is a pass-through of <code>length_unit</code>. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L393-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_density" href="#GADGETPlotting.get_density"><code>GADGETPlotting.get_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_density(snapshot::String; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the densities of the gas particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to the snapshot file.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>density_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3</code>: Unit of  density to be used in the output, all available density units in Unitful.jl and  UnitfulAstro.jl can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries.<ul><li>Key &quot;density&quot; =&gt; Array with the densities of the gas particles. </li><li>Key &quot;unit&quot; =&gt; The unit of density used, i.e. is a pass-through of <code>density_unit</code>. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L601-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_hsml" href="#GADGETPlotting.get_hsml"><code>GADGETPlotting.get_hsml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_hsml(snapshot::String; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the smoothing lengths of the gas particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries.<ul><li>Key &quot;hsml&quot; =&gt; A Vector with the smoothing lengths of the gas particles. </li><li>Key &quot;unit&quot; =&gt; The unit of length used, i.e. is a pass-through of <code>length_unit</code>. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L680-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_mass" href="#GADGETPlotting.get_mass"><code>GADGETPlotting.get_mass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_mass(snapshot::String, type::String; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the mass of the particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with three entries.<ul><li>Key &quot;mass&quot; =&gt; A Vector with the masses of the particles. </li><li>Key &quot;unit&quot; =&gt; The unit of mass used, i.e. is a pass-through of <code>mass_unit</code>. </li><li>Key &quot;type&quot; =&gt; A String with the particle type.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L759-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_metallicity" href="#GADGETPlotting.get_metallicity"><code>GADGETPlotting.get_metallicity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_metallicity(snapshot::String, type::String; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the metallicity (as mass content of metals) of the particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;stars&quot; -&gt; Star particle.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries.<ul><li>Key &quot;Z&quot; =&gt; A Vector with the metallicities of the particles.  </li><li>Key &quot;unit&quot; =&gt; The unit of mass used, i.e. is a pass-through of <code>mass_unit</code>. </li><li>Key &quot;type&quot; =&gt; A String with the particle type. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L855-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_temperature" href="#GADGETPlotting.get_temperature"><code>GADGETPlotting.get_temperature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_temperature(snapshot::String; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the temperature of the gas particles at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>temp_unit::Unitful.FreeUnits = Unitful.K</code>: Unit of temperature to be used in the output,  all available temperature units in Unitful.jl and UnitfulAstro.jl can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries.<ul><li>Key &quot;temperature&quot; =&gt; A Vector with the temperatures of the particles.  </li><li>Key &quot;unit&quot; =&gt; The unit of temperature used, i.e. is a pass-through of <code>temp_unit</code>. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L956-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_age" href="#GADGETPlotting.get_age"><code>GADGETPlotting.get_age</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_age(snapshot::String, time::Unitful.Quantity; &lt;keyword arguments&gt;)::Dict{String,Any}</code></pre><p>Get the ages of the stars at a specific time step.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::String</code>: Path to a given snapshot.</li><li><code>time::Unitful.Quantity</code>: Clock time of <code>snapshot</code>, with units. All available time units  in Unitful.jl and UnitfulAstro.jl can be used.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>snap_0::String = &quot;&quot;</code>: Path to the fist snapshot. Only relevant for cosmological simulations (<code>sim_cosmo = 1</code>).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See pass_all() in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with two entries.<ul><li>Key &quot;ages&quot; =&gt; The ages of the stars.  </li><li>Key &quot;unit&quot; =&gt; The unit of time used. </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L1083-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_birth_place" href="#GADGETPlotting.get_birth_place"><code>GADGETPlotting.get_birth_place</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_birth_place(
    snap_index::Int64,
    snap_files::Vector{String},
    time_stamps::Vector{Float64},
    stamps_unit::Unitful.FreeUnits; 
    &lt;keyword arguments&gt;
)::Dict{String, Any}</code></pre><p>Get the birth location of the stars in a given snapshot.</p><p><strong>Arguments</strong></p><ul><li><code>snap_index::Int64</code>: Index in <code>snap_files</code> of the snapshot whose stars will be located.</li><li><code>snap_files::Vector{String}</code>: Output of the function <code>get_snapshot_paths</code> corresponding  to the key &quot;snap_files&quot;, containing an Array with the paths to the snapshots.</li><li><code>time_stamps::Vector{Float64}</code>: Clock time of every snapshot in <code>snap_files</code>.</li><li><code>stamps_unit::Unitful.FreeUnits</code>: Unit of time of the <code>time_stamps</code>.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>filter_function::Function = pass_all</code>: A function with the signature:  foo(snap_file::String, type::String)::Vector{Int64}. See <code>pass_all</code> in <code>src/auxiliary.jl</code>  for an example. By default no particles are filtered.</li><li><code>length_unit::Unitful.FreeUnits = UnitfulAstro.kpc</code>: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time of <code>time_stamps</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A 2 dimensional arrays with the positions of the stars. Each row is a star and each column corresponds to coordinates x, y and z respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L1183-L1214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.get_sfr_txt" href="#GADGETPlotting.get_sfr_txt"><code>GADGETPlotting.get_sfr_txt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sfr_txt(
    source_path::String,
    snapshot::String; 
    &lt;keyword arguments&gt;
)::Dict{Union{Int64, String}, Any}</code></pre><p>Get the column data from the sfr.txt file.</p><p>Transform from internal units to the ones given by <code>mass_unit</code>, <code>time_unit</code> and <code>sfr_unit</code>.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt generated by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>source_path::String</code>: Path to the directory containing the sfr.txt file.</li><li><code>snapshot::String</code>: Path to a particular snapshot file, to use its header.</li><li><code>sim_cosmo::Int64 = 0</code>: Value of the GADGET variable ComovingIntegrationOn:  0 -&gt; Newtonian simulation (static universe). 1 -&gt; Cosmological simulation (expanding universe).</li><li><code>mass_unit::Unitful.FreeUnits = UnitfulAstro.Msun</code>: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.</li><li><code>time_unit::Unitful.FreeUnits = UnitfulAstro.Myr</code>: Unit of time to be used in the output,  all available time units in Unitful.jl and UnitfulAstro.jl can be used.</li><li><code>sfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr</code>: Unit of mass/time to  be used in the output, all available time and mass units in Unitful.jl and UnitfulAstro.jl  can be used.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with six entries.<ul><li>Key &quot;1&quot; =&gt; The first column (time).  </li><li>Key &quot;2&quot; =&gt; The second column (total mass - probability).  </li><li>Key &quot;3&quot; =&gt; The third column (SFR - original GADGET).  </li><li>Key &quot;4&quot; =&gt; The fourth column (SFR - probability).  </li><li>Key &quot;5&quot; =&gt; The fifth column (real total mass).  </li><li>Key &quot;6&quot; =&gt; The sixth column (real SFR).  </li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/data_acquisition.jl#L1362-L1399">source</a></section></article><h3 id="Auxiliary"><a class="docs-heading-anchor" href="#Auxiliary">Auxiliary</a><a id="Auxiliary-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.relative" href="#GADGETPlotting.relative"><code>GADGETPlotting.relative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative(
    p::Plots.Plot,
    rx::Float64,
    ry::Float64,
    rz::Union{Float64, Nothing} = nothing; 
    &lt;keyword arguments&gt;
)::Union{NTuple{2, Float64}, NTuple{3, Float64}}</code></pre><p>Give the absolute coordinates within a Plot, given the relative ones.</p><p><strong>Arguments</strong></p><ul><li><code>p::Plots.Plot</code>: Plot for which the absolute coordinates will be calculated.</li><li><code>rx::Float64</code>: relative x coordinate, rx ∈ [0, 1].</li><li><code>ry::Float64</code>: relative y coordinate, ry ∈ [0, 1].</li><li><code>rz::Union{Float64,Nothing} = nothing</code>: relative z coordinate, rz ∈ [0, 1].</li><li><code>log::Union{NTuple{2, Bool}, NTuple{3, Bool}} = (false, false, false)</code> = If the x, y or z axis will be in a logarithmic scale.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the absolute coordinates: (x, y) or (x, y, z).</li></ul><p><strong>Examples</strong></p><p>```julia-repl julia&gt; GADGETPlotting.relative(plot(rand(100)), 0.5, 0.5) (50.5, 0.5047114800322484)</p><p>julia&gt; GADGETPlotting.relative(surface(rand(100, 100)), 0.5, 0.5, 0.5) (50.5, 50.5, 0.5000284432744244)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.make_video" href="#GADGETPlotting.make_video"><code>GADGETPlotting.make_video</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_video(
    source_path::String,
    source_format::String,
    output_path::String,
    output_filename::String,
    frame_rate::Int64,
)::Nothing</code></pre><p>Make a MP4 video from a series of images. </p><p>The H.264 codec is used with no compression and the source images can be in any format available in ImageIO.jl, e.g. &quot;.png&quot;, &quot;.svg&quot;, &quot;.jpeg&quot;, etc.</p><p><strong>Arguments</strong></p><ul><li><code>source_path::String</code>: Path to the directory containing the images.	</li><li><code>source_format::String</code>: File format of the source images. </li><li><code>output_path::String</code>: Path to the directory where the resulting video will be saved.</li><li><code>output_filename::String</code>: Name of the video to be generated without extension.	</li><li><code>frame_rate::Int64</code>: Frame rate of the video to be generated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L83-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.smooth_window" href="#GADGETPlotting.smooth_window"><code>GADGETPlotting.smooth_window</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">smooth_window(
    x_data::Vector{&lt;:Real},
    y_data::Vector{&lt;:Real},
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Separate the range of values of <code>x_data</code> in <code>bins</code> contiguous windows, and replaces  every x and y value within the window with the mean in order to smooth out the data. </p><p><strong>Arguments</strong></p><ul><li><code>x_data::Vector{&lt;:Real}</code>: Data used to create the windows.</li><li><code>y_data::Vector{&lt;:Real}</code>: Data to be smoothed out.</li><li><code>bins::Int64</code>: Number of windows to be used in the smoothing.</li><li><code>log::Bool = false</code>: If the x axis will be divided using logarithmic bins.</li></ul><p><strong>Returns</strong></p><ul><li>The smooth data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L132-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile" href="#GADGETPlotting.density_profile"><code>GADGETPlotting.density_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a density profile up to a radius <code>max_radius</code>. </p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a density for the j-th shell of</p><p><span>$\rho = \frac{M}{\frac{4}{3}\,\pi\,\mathrm{width}^3\,(3\,j^2 - 3\,j + 1)}$</span></p><p>where <span>$M$</span> is the total mass within each shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays.  The first with the radial distances and the second with the densities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L204-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile" href="#GADGETPlotting.metallicity_profile"><code>GADGETPlotting.metallicity_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">metallicity_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    z_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute a metallicity profile up to a radius <code>max_radius</code>, and normalize it to the  solar metallicity.</p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a relative metallicity for  the j-th shell of</p><p><span>$\rho = \frac{z}{M\,Z_\odot}$</span></p><p>where <span>$M$</span> is the total mass and <span>$z$</span> the total content of metals, within each shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units. <code>z_data</code> and <code>mass_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>z_data::Vector{Float64}</code>: Metal content of the particles in mass units.</li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the radial distances and the second with the metallicities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L274-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile" href="#GADGETPlotting.mass_profile"><code>GADGETPlotting.mass_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mass_profile(
    mass_data::Vector{Float64},
    distance_data::Vector{Float64},
    max_radius::Float64,
    bins::Int64,
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute an accumulated mass profile up to a radius <code>max_radius</code>. </p><p>It divides the sphere of radious <code>max_radius</code>, centered at (0, 0, 0), in <code>bins</code> spherical  shells of equal width <code>max_radius / bins</code>. This results in a accumulated mass for  the j-th shell of</p><p><span>$M = \sum_{i = 1}^j m_i$</span></p><p>where <span>$m_i$</span> is the total mass within the i-th shell.</p><p><code>max_radius</code> and <code>distance_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>distance_data::Vector{Float64}</code>: Radial distances of the particles. </li><li><code>max_radius::Float64</code>: Maximum distance up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_radius</code>] to be used for the profile.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the radial distances and the second with the accumulated masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L350-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compute_cmdf" href="#GADGETPlotting.compute_cmdf"><code>GADGETPlotting.compute_cmdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_cmdf(
    mass_data::Vector{Float64},
    metallicity_data::Vector{Float64},
    max_Z::Float64,
    bins::Int64; 
    &lt;keyword arguments&gt;
)::NTuple{2, Vector{Float64}}</code></pre><p>Compute the cumulative metallicity distribution function up to a metallicity <code>max_Z</code>. </p><p>The CMDF is calculated separating the stellar metallicity in <code>bins</code> windows from 0 to  <code>max_Z</code> metallicity. Within the j-th window the CMDF is</p><p><span>$\sum_{i = 1}^j \frac{m_i}{M_T}$</span> vs. <span>$\bar{Z}_j$</span></p><p>or, for <code>x_norm = true</code>, </p><p><span>$\sum_{i = 1}^j \frac{m_i}{M_T}$</span> vs. <span>$\bar{Z}_j / max(\bar{Z}_j)$</span></p><p>where <span>$M_T$</span> is the total stellar mass, <span>$m_i$</span> the stellar mass of the i-th window and <span>$\bar{Z}_j$</span> the mean stellar metallicity of the j-th window.</p><p><code>mass_data</code> and <code>metallicity_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>mass_data::Vector{Float64}</code>: Masses of the particles.</li><li><code>metallicity_data::Vector{Float64}</code>: Metallicities of the particles. </li><li><code>max_Z::Float64</code>: Maximum metallicity up to which the profile will be calculated.</li><li><code>bins::Int64</code>: Number of subdivisions of [0, <code>max_Z</code>] to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>A Tuple of two Arrays. The first with the metallicities and the second with the accumulated masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L418-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_law" href="#GADGETPlotting.kennicutt_schmidt_law"><code>GADGETPlotting.kennicutt_schmidt_law</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_law(
    gas_mass_data::Vector{Float64},
    gas_distance_data::Vector{Float64},
    temperature_data::Vector{Float64},
    star_mass_data::Vector{Float64},
    star_distance_data::Vector{Float64},
    age_data::Vector{Float64},
    temp_filter::Float64,
    age_filter::Float64,
    max_r::Float64; 
    &lt;keyword arguments&gt;
)::Union{Nothing, Dict{String, Any}}</code></pre><p>Compute mass area density and the SFR area density for the Kennicutt-Schmidt law. </p><p><code>temp_filter</code> and <code>temperature_data</code> must be in the same units, and <code>age_filter</code> and  <code>age_data</code> must be in the same units too.</p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Vector{Float64}</code>: Masses of the gas particles.</li><li><code>gas_distance_data::Vector{Float64}</code>: 2D distances of the gas particles. </li><li><code>temperature_data::Vector{Float64}</code>: Temperatures of the gas particles.</li><li><code>star_mass_data::Vector{Float64}</code>: Masses of the stars.</li><li><code>star_distance_data::Vector{Float64}</code>: 2D distances of the stars.</li><li><code>age_data::Vector{Float64}</code>: Ages of the stars.</li><li><code>temp_filter::Float64</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Unitful.Quantity</code>: Maximum star age allowed for the calculation of the SFR.  It should be approximately equal to the time step of the snapshots.</li><li><code>max_r::Float64</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used.  It has to be at least 5.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary with three entries.<ul><li>Key &quot;RHO&quot; =&gt; Logarithm of the area mass densities.</li><li>Key &quot;SFR&quot; =&gt; Logarithm of the SFR area densities.</li><li>Key &quot;LM&quot; =&gt; Linear model given by GLM.jl.</li></ul></li><li>Or <code>nothing</code> if there are less than 5 data point in the end result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L506-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.format_error" href="#GADGETPlotting.format_error"><code>GADGETPlotting.format_error</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format_error(mean::Float64, error::Float64)::String</code></pre><p>Format the mean and error values.</p><p>It follows the traditional rules for error presentation. The error has only one significant   digit, unless such digit is a one, in which case, two significant digits are used.   The mean will have a number of digits such as to match the error. </p><p><strong>Arguments</strong></p><ul><li><code>mean::Float64</code>: Mean value.</li><li><code>error::Float64</code>: Error value. It must be positive.</li></ul><p><strong>Returns</strong></p><ul><li>A Tuple with the formatted mean and error values.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; format_error(69.42069, 0.038796)
(69.42, 0.04)

julia&gt; format_error(69.42069, 0.018796)
(69.421, 0.019)

julia&gt; format_error(69.42069, 0.0)
(69.42069, 0.0)

julia&gt; format_error(69.42069, 73.4)
(0.0, 70.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L616-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.pass_all" href="#GADGETPlotting.pass_all"><code>GADGETPlotting.pass_all</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pass_all(snap_file::String, type::String)::Vector{Int64}</code></pre><p>Default filter function for <code>read_blocks_over_all_files</code>.</p><p>It does not filter out any particles, allowing the data acquisition functions to gather  all data. </p><p><strong>Arguments</strong></p><ul><li><code>snap_file::String</code>: Snapshot file path.</li><li><code>type::String</code>: Particle type. &quot;gas&quot; -&gt; Gas particle.  &quot;dark_matter&quot; -&gt; Dark matter particle. &quot;stars&quot; -&gt; Star particle.</li></ul><p><strong>Returns</strong></p><ul><li>A Vector with the indices of the allowed particles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L688-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.energy_integrand" href="#GADGETPlotting.energy_integrand"><code>GADGETPlotting.energy_integrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">energy_integrand(header::GadgetIO.SnapshotHeader, a::Float64)::Float64</code></pre><p>Give the integrand of the scale factor to physical time function</p><p><span>$\frac{1}{H\,\sqrt{\epsilon}}$</span>, </p><p>where <span>$H = H_0 \, a$</span> and <span>$\epsilon = \Omega_\lambda + (1 - \Omega_\lambda - \Omega_0) / a^2 + \Omega_0 / a^3$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>header::GadgetIO.SnapshotHeader</code>: Header of the relevant snapshot file.</li><li><code>a::Float64</code>: Dimensionless scale factor.</li></ul><p><strong>Returns</strong></p><ul><li>The integrand evaluated in <code>a</code> in Gyr.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L725-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.num_integrate" href="#GADGETPlotting.num_integrate"><code>GADGETPlotting.num_integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_integrate(
    func::Function, 
    inf_lim::Float64, 
    sup_lim::Float64, 
    steps::Int64 = 200,
)::Float64</code></pre><p>Give the numerical integral of <code>func</code> between <code>inf_val</code> and <code>sup_val</code>. </p><p>The result is given by</p><p><span>$\int_\mathrm{inf\_lim}^\mathrm{sup\_lim} f(x) \mathrm{dx} \approx \sum_{i = 1}^\mathrm{steps} f(\mathrm{inf\_lim} + \mathrm{width}\,i ) \, ,$</span></p><p>where <span>$\mathrm{width} = (\mathrm{sup\_lim} - \mathrm{inf\_lim}) / \mathrm{steps}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>func::Function</code>: 1D function to be integrated.</li><li><code>inf_lim::Float64</code>: Inferior limit of the integral.</li><li><code>sup_lim::Float64</code>: Superior limit if the integral.</li><li><code>steps::Int64</code>: Number of subdivisions to be used for the discretization of  the <code>sup_lim</code> - <code>inf_lim</code> region.</li></ul><p><strong>Returns</strong></p><ul><li>The value of the integral.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; num_integrate(sin, 0, 3π)
1.9996298761360816

julia&gt; num_integrate(x -&gt; x^3 + 6 * x^2 + 9 * x + 2, 0, 4.69)
438.9004836958452

julia&gt; num_integrate(x -&gt; exp(x^x), 0, 1.0)
2.1975912134624904</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L754-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.center_of_mass" href="#GADGETPlotting.center_of_mass"><code>GADGETPlotting.center_of_mass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">center_of_mass(
    position_data::Matrix{&lt;:Real},
    mass_data::Vector{&lt;:Real},
)::NTuple{3, Float64}</code></pre><p>Calculate the center of mass as</p><p><span>$R_c = \frac{1}{M} \sum_i m_i \, r_i \, ,$</span></p><p>where <span>$M = \sum_i m_i$</span> and <span>$m_i$</span> and <span>$r_i$</span> are the mass and distance  from the origin of the i-th particle.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Matrix{&lt;:Real}</code>: The positions of the particles.</li><li><code>mass_data::Vector{&lt;:Real}</code>: The masses of the particles.</li></ul><p><strong>Returns</strong></p><ul><li>The center of mass in the unis of <code>position_data</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/beabe83f1c37dfd3c62441fa3140bd9e856347e8/src/auxiliary.jl#L808-L827">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GADGETPlotting.birth_histogram_pipeline"><code>GADGETPlotting.birth_histogram_pipeline</code></a></li><li><a href="#GADGETPlotting.birth_histogram_plot"><code>GADGETPlotting.birth_histogram_plot</code></a></li><li><a href="#GADGETPlotting.center_of_mass"><code>GADGETPlotting.center_of_mass</code></a></li><li><a href="#GADGETPlotting.cmdf_pipeline"><code>GADGETPlotting.cmdf_pipeline</code></a></li><li><a href="#GADGETPlotting.cmdf_plot"><code>GADGETPlotting.cmdf_plot</code></a></li><li><a href="#GADGETPlotting.compare_simulations_pipeline"><code>GADGETPlotting.compare_simulations_pipeline</code></a></li><li><a href="#GADGETPlotting.compare_simulations_plot"><code>GADGETPlotting.compare_simulations_plot</code></a></li><li><a href="#GADGETPlotting.comparison"><code>GADGETPlotting.comparison</code></a></li><li><a href="#GADGETPlotting.compute_cmdf"><code>GADGETPlotting.compute_cmdf</code></a></li><li><a href="#GADGETPlotting.deep_comparison"><code>GADGETPlotting.deep_comparison</code></a></li><li><a href="#GADGETPlotting.density_histogram_pipeline"><code>GADGETPlotting.density_histogram_pipeline</code></a></li><li><a href="#GADGETPlotting.density_histogram_plot"><code>GADGETPlotting.density_histogram_plot</code></a></li><li><a href="#GADGETPlotting.density_map_pipeline"><code>GADGETPlotting.density_map_pipeline</code></a></li><li><a href="#GADGETPlotting.density_map_plot"><code>GADGETPlotting.density_map_plot</code></a></li><li><a href="#GADGETPlotting.density_profile"><code>GADGETPlotting.density_profile</code></a></li><li><a href="#GADGETPlotting.density_profile_pipeline"><code>GADGETPlotting.density_profile_pipeline</code></a></li><li><a href="#GADGETPlotting.density_profile_plot"><code>GADGETPlotting.density_profile_plot</code></a></li><li><a href="#GADGETPlotting.energy_integrand"><code>GADGETPlotting.energy_integrand</code></a></li><li><a href="#GADGETPlotting.evolution_summary_pipeline"><code>GADGETPlotting.evolution_summary_pipeline</code></a></li><li><a href="#GADGETPlotting.format_error"><code>GADGETPlotting.format_error</code></a></li><li><a href="#GADGETPlotting.gas_star_evolution_pipeline"><code>GADGETPlotting.gas_star_evolution_pipeline</code></a></li><li><a href="#GADGETPlotting.gas_star_evolution_plot"><code>GADGETPlotting.gas_star_evolution_plot</code></a></li><li><a href="#GADGETPlotting.get_age"><code>GADGETPlotting.get_age</code></a></li><li><a href="#GADGETPlotting.get_birth_place"><code>GADGETPlotting.get_birth_place</code></a></li><li><a href="#GADGETPlotting.get_density"><code>GADGETPlotting.get_density</code></a></li><li><a href="#GADGETPlotting.get_hsml"><code>GADGETPlotting.get_hsml</code></a></li><li><a href="#GADGETPlotting.get_mass"><code>GADGETPlotting.get_mass</code></a></li><li><a href="#GADGETPlotting.get_metallicity"><code>GADGETPlotting.get_metallicity</code></a></li><li><a href="#GADGETPlotting.get_position"><code>GADGETPlotting.get_position</code></a></li><li><a href="#GADGETPlotting.get_sfr_txt"><code>GADGETPlotting.get_sfr_txt</code></a></li><li><a href="#GADGETPlotting.get_snapshot_path"><code>GADGETPlotting.get_snapshot_path</code></a></li><li><a href="#GADGETPlotting.get_temperature"><code>GADGETPlotting.get_temperature</code></a></li><li><a href="#GADGETPlotting.get_time_evolution"><code>GADGETPlotting.get_time_evolution</code></a></li><li><a href="#GADGETPlotting.kennicutt_schmidt_law"><code>GADGETPlotting.kennicutt_schmidt_law</code></a></li><li><a href="#GADGETPlotting.kennicutt_schmidt_pipeline"><code>GADGETPlotting.kennicutt_schmidt_pipeline</code></a></li><li><a href="#GADGETPlotting.kennicutt_schmidt_plot"><code>GADGETPlotting.kennicutt_schmidt_plot</code></a></li><li><a href="#GADGETPlotting.make_video"><code>GADGETPlotting.make_video</code></a></li><li><a href="#GADGETPlotting.mass_profile"><code>GADGETPlotting.mass_profile</code></a></li><li><a href="#GADGETPlotting.mass_profile_pipeline"><code>GADGETPlotting.mass_profile_pipeline</code></a></li><li><a href="#GADGETPlotting.mass_profile_plot"><code>GADGETPlotting.mass_profile_plot</code></a></li><li><a href="#GADGETPlotting.metallicity_profile"><code>GADGETPlotting.metallicity_profile</code></a></li><li><a href="#GADGETPlotting.metallicity_profile_pipeline"><code>GADGETPlotting.metallicity_profile_pipeline</code></a></li><li><a href="#GADGETPlotting.metallicity_profile_plot"><code>GADGETPlotting.metallicity_profile_plot</code></a></li><li><a href="#GADGETPlotting.num_integrate"><code>GADGETPlotting.num_integrate</code></a></li><li><a href="#GADGETPlotting.pass_all"><code>GADGETPlotting.pass_all</code></a></li><li><a href="#GADGETPlotting.redshift_series_plot"><code>GADGETPlotting.redshift_series_plot</code></a></li><li><a href="#GADGETPlotting.relative"><code>GADGETPlotting.relative</code></a></li><li><a href="#GADGETPlotting.rho_temp_pipeline"><code>GADGETPlotting.rho_temp_pipeline</code></a></li><li><a href="#GADGETPlotting.rho_temp_plot"><code>GADGETPlotting.rho_temp_plot</code></a></li><li><a href="#GADGETPlotting.scale_factor_series_plot"><code>GADGETPlotting.scale_factor_series_plot</code></a></li><li><a href="#GADGETPlotting.scatter_grid_pipeline"><code>GADGETPlotting.scatter_grid_pipeline</code></a></li><li><a href="#GADGETPlotting.scatter_grid_plot"><code>GADGETPlotting.scatter_grid_plot</code></a></li><li><a href="#GADGETPlotting.sfr_txt_pipeline"><code>GADGETPlotting.sfr_txt_pipeline</code></a></li><li><a href="#GADGETPlotting.sfr_txt_plot"><code>GADGETPlotting.sfr_txt_plot</code></a></li><li><a href="#GADGETPlotting.smooth_window"><code>GADGETPlotting.smooth_window</code></a></li><li><a href="#GADGETPlotting.star_map_pipeline"><code>GADGETPlotting.star_map_pipeline</code></a></li><li><a href="#GADGETPlotting.star_map_plot"><code>GADGETPlotting.star_map_plot</code></a></li><li><a href="#GADGETPlotting.temperature_histogram_pipeline"><code>GADGETPlotting.temperature_histogram_pipeline</code></a></li><li><a href="#GADGETPlotting.temperature_histogram_plot"><code>GADGETPlotting.temperature_histogram_plot</code></a></li><li><a href="#GADGETPlotting.time_series_plot"><code>GADGETPlotting.time_series_plot</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 May 2021 01:11">Wednesday 12 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
