<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting Functions · GADGETPlotting.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GADGETPlotting.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../pipelines/">Pipeline Functions</a></li><li class="is-active"><a class="tocitem" href>Plotting Functions</a></li><li><a class="tocitem" href="../data_acquisition/">Data Acquisition Functions</a></li><li><a class="tocitem" href="../auxiliary/">Auxiliary Functions</a></li><li><a class="tocitem" href="../func_list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Plotting Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ezequiel92/GADGETPlotting/blob/main/docs/src/plotting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.birth_histogram_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.birth_histogram_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.birth_histogram_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">birth_histogram_plot(birth_data::Dict{String, Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make a histogram of the number of stars born at a certain radial distance.</p><p><strong>Arguments</strong></p><ul><li><code>birth_data::Dict{String, Any}</code>: Return value of the birthPlace function.</li><li><code>bins::Int64 = 50</code>: Number of bins to use in the histogram.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L995-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.cmdf_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.cmdf_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.cmdf_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cmdf_plot(
    m_data::Dict{String, Any}, 
    z_data::Dict{String, Any},
    time::Unitful.Quantity;
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a cumulative metallicity distribution function plot, for a given time step.</p><p><code>m_data</code> and <code>z_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>m_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>z_data::Dict{String, Any}</code>: Return value of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64</code>: Number of subdivisions of the metallicity to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L811-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.cmdf_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}" href="#GADGETPlotting.cmdf_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}"><code>GADGETPlotting.cmdf_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cmdf_plot(
    m_data::Vector{Dict{String, Any}}, 
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2};
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a cumulative metallicity distribution function plot of several datasets,  for a given time step.</p><p><code>m_data</code> and <code>z_data</code> must be in the same units.</p><p><strong>Arguments</strong></p><ul><li><code>m_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>z_data::Vector{Dict{String, Any}}</code>: Return values of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>bins::Int64</code>: Number of subdivisions of the metallicity to construct the plot.</li><li><code>x_norm::Bool = false</code>: If the x axis will be normalized to its maximum value. </li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L889-L914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.compare_simulations_plot-Tuple{Vector{Dict{String, Any}}, String, String, Matrix{String}}" href="#GADGETPlotting.compare_simulations_plot-Tuple{Vector{Dict{String, Any}}, String, String, Matrix{String}}"><code>GADGETPlotting.compare_simulations_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compare_simulations_plot(
    data::Vector{Dict{String, Any}},
    x_quantity::String,
    y_quantity::String,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot comparing among several simulations <code>y_quantity</code> vs. <code>x_quantity</code> .</p><p>The data of each simulation must be in the same units, and <code>x_quantity</code> and <code>y_quantity</code>  can be any magnitude used in the timeSeriesData function, namely:</p><ul><li>&quot;scale_factor&quot;                  </li><li>&quot;redshift&quot;                  </li><li>&quot;clock_time&quot; (Physical time)</li><li>&quot;sfr&quot; (SFR) 			              </li><li>&quot;sfr_prob&quot; (SFR probability - Not normalized) 			           </li><li>&quot;gas_number&quot; (Gas particle number) 	            </li><li>&quot;dm_number&quot; (Dark matter particle number)		               </li><li>&quot;star_number&quot; (Star number)         </li><li>&quot;gas_mass&quot; (Total gas mass)               </li><li>&quot;dm_mass&quot; (Total dark matter mass)	            </li><li>&quot;star_mass&quot; (Total star mass)		</li><li>&quot;gas_density&quot; (Total gas density)	               </li><li>&quot;gas_frac&quot; (Gas fraction)		                </li><li>&quot;dm_frac&quot; (Dark matter fraction)		                </li><li>&quot;star_frac&quot; (Star fraction)	                   </li><li>&quot;gas<em>bar</em>frac&quot; (Baryonic gas fraction)                  </li><li>&quot;star<em>bar</em>frac&quot; (Baryonic star fraction)</li></ul><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Dict{String,Any}}</code>: Return value of the timeSeriesData function for  every simulation in a Vector, e.g. [data_sim1, data_sim2].</li><li><code>x_quantity::String</code>: String indicating the physical magnitude for the x axis. </li><li><code>y_quantity::String</code>: String indicating the physical magnitude for the y axis.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is  printed, which is the default.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>scale::Vector{Symbol} = [:identity, :identity],</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>smooth_data::Bool = false</code>: If true a smoothing window with no weighs is applied to  the y data. If false, no transformation occurs.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data, only relevant if <code>smooth_data = true</code>. </li><li><code>legend_pos::Symbol = :bottomright</code>: Position of the legend, e.g. :topleft.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1444-L1500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.density_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.density_histogram_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_histogram_plot(
    density_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a histogram of the densities of the gas particles.</p><p><strong>Arguments</strong></p><ul><li><code>density_data::Dict{String,Any}</code>: Return value of the densityData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64 = 20</code>: Number of bins to use in the histogram.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale <code>density_data</code>, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1721-L1740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_map_plot-NTuple{4, Dict{String, Any}}" href="#GADGETPlotting.density_map_plot-NTuple{4, Dict{String, Any}}"><code>GADGETPlotting.density_map_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_map_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    density_data::Dict{String, Any}
    hsml_data::Dict{String, Any}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of the gas density in the XY, XZ and/or YZ planes. </p><p>The axes are in the units given by <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String,Any}</code>: Return value of the massData function.</li><li><code>density_data::Dict{String,Any}</code>: Return value of the densityData function.</li><li><code>hsml_data::Dict{String,Any}</code>: Return value of the hsmlData function.</li><li><code>plane::String = &quot;All&quot;</code>: String indicating which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>axes_color::Symbol = :white</code>: Color of the axes passing through (0.0, 0.0), only relevant  if <code>axes = true</code>.</li><li><code>color::Symbol = :inferno</code>: Color scheme for the figure.  Any one from <a href="https://github.com/JuliaGraphics/ColorSchemes.jl">ColorSchemes.jl</a> can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn<em>rocket</em>gradient, :YlOrRd_9 and :inferno, which is the default.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L181-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.density_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.density_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a density profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1792-L1820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.density_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}" href="#GADGETPlotting.density_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}"><code>GADGETPlotting.density_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a density profile plot comparing several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Vector of return values of the positionData  function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Vector of return values of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile.</li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1920-L1951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.gas_star_evolution_plot-Tuple{Int64, Dict{String, Any}, Dict{String, Any}}" href="#GADGETPlotting.gas_star_evolution_plot-Tuple{Int64, Dict{String, Any}, Dict{String, Any}}"><code>GADGETPlotting.gas_star_evolution_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gas_star_evolution_plot(
    index::Int64,
    time_series::Dict{String, Any},
    position_data::Dict{String, Any}, 
)::Plots.Plot</code></pre><p>Makes 3 plots, the position of the particles in the XY plane, the baryonic fractional mass  and the SFR. The first two for stars and gas. All in a single figure with a 1x2 layout</p><p>The figure is created with the time running from 0 to <code>time_series[&quot;clock_time&quot;][index]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>index::Int64</code>: Index of the final time step up to which the figure will show the  evolution of the variables.</li><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.	</li><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L649-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.kennicutt_schmidt_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity}" href="#GADGETPlotting.kennicutt_schmidt_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity}"><code>GADGETPlotting.kennicutt_schmidt_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kennicutt_schmidt_plot(
    gas_mass_data::Dict{String, Any},
    temperature_data::Dict{String, Any},
    star_mass_data::Dict{String, Any},
    age_data::Dict{String, Any},
    pos_data::Dict{String, Any},
    temp_filter::Unitful.Quantity,
    age_filter::Unitful.Quantity,
    max_r::Unitful.Quantity,
    time::Unitful.Quantity;
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of the Kennicutt-Schmidt law for a given snapshot, with its fit and  the measured values superimposed for comparison. </p><p><strong>Arguments</strong></p><ul><li><code>gas_mass_data::Dict{String, Any}</code>: Return value of the massData function, for gas.</li><li><code>temperature_data::Dict{String, Any}</code>: Return value of the tempData function.</li><li><code>star_mass_data::Dict{String, Any}</code>: Return value of the massData function, for stars.</li><li><code>age_data::Dict{String, Any}</code>: Return value of the ageData function.</li><li><code>pos_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>temp_filter::Unitful.Quantity</code>: Maximum temperature allowed for the gas particles.</li><li><code>age_filter::Unitful.Quantity</code>: Maximum star age allowed for the calculation of the SFR.  It should aproximately equal to the time step of the snapshots.</li><li><code>max_r::Unitful.Quantity</code>: Maximum distance up to which the parameters will be calculated.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot. </li><li><code>bins::Int64 = 50</code>: Number of subdivisions of [0, <code>max_r</code>] to be used.  It has to be at least 5.</li><li><code>error_formating::String = &quot;std_error&quot;</code>: What to print as error values. The options are: &quot;std_error&quot;: <code>mean ± standard_error</code>. &quot;conf_interval&quot;: <code>mean ± max(upper_95% - mean, mean - lower_95%)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L3274-L3311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.mass_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.mass_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make an accumulated mass profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2401-L2429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.mass_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}" href="#GADGETPlotting.mass_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}"><code>GADGETPlotting.mass_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make an accumulated mass profile plot of several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Return values of the positionData function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>factor::Int64 = 0</code>: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2525-L2555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.metallicity_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.metallicity_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">metallicity_profile_plot(
    position_data::Dict{String, Any},
    mass_data::Dict{String, Any},
    z_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a metallicity profile plot for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String, Any}</code>: Return value of the positionData function.</li><li><code>mass_data::Dict{String, Any}</code>: Return value of the massData function.</li><li><code>z_data::Dict{String ,Any}</code>: Return value of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2112-L2140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.metallicity_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}" href="#GADGETPlotting.metallicity_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}"><code>GADGETPlotting.metallicity_profile_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">metallicity_profile_plot(
    position_data::Vector{Dict{String, Any}},
    mass_data::Vector{Dict{String, Any}},
    z_data::Vector{Dict{String, Any}},
    time::Unitful.Quantity,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a metallicity profile plot comparing several datasets, for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Vector{Dict{String, Any}}</code>: Return values of the positionData function.</li><li><code>mass_data::Vector{Dict{String, Any}}</code>: Return values of the massData function.</li><li><code>z_data::Vector{Dict{String, Any}}</code>: Return values of the zData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>scale::Symbol = :identity</code>: Scaling to be used for the y axis. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>bins::Int64 = 100</code>: Number of subdivisions of the region to be used for the profile. </li><li><code>box_factor::Float64 = 1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>position_data[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>position_data[&quot;box_size&quot;] / 2.0</code> if periodic boundary conditions were used.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2228-L2258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.redshift_series_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.redshift_series_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.redshift_series_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">redshift_series_plot(time_series::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. </p><p>All the plots show the evolution of the corresponding parameter versus the redshift.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1307-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.rho_temp_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.rho_temp_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.rho_temp_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rho_temp_plot(
    temperature_data::Dict{String, Any},
    density_data::Dict{String, Any},
    time::Unitful.Quantity,
)::Plots.Plot</code></pre><p>Make a plot of log10(ρ) vs. log10(T), for the gas particles at a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>temperature_data::Dict{String,Any}</code>: Return value of the tempData function.</li><li><code>density_data::Dict{String, Any}</code>: Return value of the densityData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L3194-L3211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.scale_factor_series_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.scale_factor_series_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.scale_factor_series_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale_factor_series_plot(time_series::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars.</p><p>All the plots show the evolution of the corresponding parameter versus the scale factor.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1170-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.scatter_grid_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.scatter_grid_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.scatter_grid_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatter_grid_plot(position_data::Dict{String, Any})::Plots.Plot</code></pre><p>Make 9 scatter plots of the positions of the gas, dark matter and stars particles in the  XY, XZ and YZ planes.</p><p>The result is a single figure in a 3x3 layout with its axes in the unit given by <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.sfr_txt_plot-Tuple{Dict{Union{Int64, String}, Any}, Int64, Vector{Int64}}" href="#GADGETPlotting.sfr_txt_plot-Tuple{Dict{Union{Int64, String}, Any}, Int64, Vector{Int64}}"><code>GADGETPlotting.sfr_txt_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sfr_txt_plot(
    data::Dict{Union{Int64, String}, Any},
    x_axis::Int64,
    y_axis::Vector{Int64}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot of columns <code>y_axis</code> vs. column <code>x_axis</code>, of the sfr.txt text file.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>data::Dict{Union{Int64, String}, Any}</code>: Return values of the <code>sfr_txt_data</code> function.</li><li><code>x_axis::Int64</code>: Column number for the x axis.</li><li><code>y_axis::Vector{Int64}</code>: Vector of columns numbers for the y axis.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is printed, which is the default.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.</li><li><code>scale::NTuple{2, Symbol} = (:identity, :identity)</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>min_filter::NTuple{2, Float64} = (-Inf, -Inf)</code>: Value filter for the x and y axes. If a value of the x data is lower than <code>min_filter[1]</code>, then it is deleted. Equivalently  with the y axis and <code>min_filter[2]</code>. The default is -Inf for both, i.e. no filtering.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2711-L2747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.sfr_txt_plot-Tuple{Vector{Dict{Union{Int64, String}, Any}}, Int64, Int64, Matrix{String}}" href="#GADGETPlotting.sfr_txt_plot-Tuple{Vector{Dict{Union{Int64, String}, Any}}, Int64, Int64, Matrix{String}}"><code>GADGETPlotting.sfr_txt_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sfr_txt_plot(
    data::Vector{Dict{Union{Int64, String}, Any}},
    x_axis::Int64,
    y_axis::Int64,
    labels::Array{String, 2}; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a plot comparing among several simulations <code>y_axis</code> vs. column <code>x_axis</code>,  of the sfr.txt text file.</p><p><strong>Warning</strong></p><p>This function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Dict{Union{Int64, String}, Any}}</code>: Vector of return values of the  <code>sfr_txt_data</code> function.</li><li><code>x_axis::Int64</code>: Column number for the x axis.</li><li><code>y_axis::Int64</code>: Column number for the y axis.</li><li><code>labels::Array{String, 2}</code>: Labels for the different simulations.</li><li><code>title::String = &quot;&quot;</code>: Title for the figure. If an empty string is given no title is printed, which is the default.</li><li><code>bins::Int64 = 0</code>: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.</li><li><code>scale::NTuple{2, Symbol} = (:identity, :identity)</code>: Scaling to be used for the x  and y axes. The two options are: :identity =&gt; no scaling. :log10 =&gt; logarithmic scaling.</li><li><code>x_factor::Int64 = 0</code>: Numerical exponent to scale the <code>x_quantity</code>, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>y_factor::Int64 = 0</code>: Numerical exponent to scale the <code>y_quantity</code>, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is 0, i.e. no scaling.</li><li><code>min_filter::NTuple{2, Float64} = (-Inf, -Inf)</code>: Value filter for the x and y axes. If a value of the x data is lower than <code>min_filter[1]</code>, then it is deleted. Equivalently  with the y axis and <code>min_filter[2]</code>. The default is -Inf for both, i.e. no filtering.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L2883-L2923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.star_map_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.star_map_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.star_map_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">star_map_plot(position_data::Dict{String,Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make a plot of the star density in the XY, XZ and/or YZ planes. </p><p>The axes are in the units <code>position_data[&quot;unit&quot;]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>position_data::Dict{String,Any}</code>: Return value of the positionData function.</li><li><code>plane::String=&quot;All&quot;</code>: String indicating which plane will be plotted.  &quot;XY&quot; -&gt; XY plane alone. &quot;XZ&quot; -&gt; XZ plane alone. &quot;YZ&quot; -&gt; YZ plane alone. &quot;All&quot; -&gt; The three planes in a single 1x3 figure.</li><li><code>box_factor::Float64=1.0</code>: Multiplicative factor for the plotting region.  It will scale <code>positions[&quot;box_size&quot;]</code> if vacuum boundary conditions were used, and it will scale <code>positions[&quot;box_size&quot;] / 2</code> if periodic boundary conditions were used.</li><li><code>axes::Bool = false</code>: If true, the axes passing through (0.0, 0.0) are drawn. If false,  no axes are drawn.</li><li><code>axes_color::Symbol = :white</code>: Color of the axes passing through (0.0, 0.0), only relevant  if <code>axes = true</code>.</li><li><code>color::Symbol = :inferno</code>: Color scheme for the figure.  Any one from <a href="https://github.com/JuliaGraphics/ColorSchemes.jl">ColorSchemes.jl</a> can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn<em>rocket</em>gradient, :YlOrRd_9 and :inferno, which is the default.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the GR backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L448-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.temperature_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}" href="#GADGETPlotting.temperature_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}"><code>GADGETPlotting.temperature_histogram_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temperature_histogram_plot(
    temperature_data::Dict{String, Any},
    time::Unitful.Quantity; 
    &lt;keyword arguments&gt;
)::Plots.Plot</code></pre><p>Make a histogram of the logarithm of the gas particles&#39; temperatures.</p><p><strong>Arguments</strong></p><ul><li><code>temperature_data::Dict{String,Any}</code>: Return value of the tempData function.</li><li><code>time::Unitful.Quantity</code>: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.</li><li><code>bins::Int64 = 20</code>: Number of bins to use in the histogram.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L3132-L3149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GADGETPlotting.time_series_plot-Tuple{Dict{String, Any}}" href="#GADGETPlotting.time_series_plot-Tuple{Dict{String, Any}}"><code>GADGETPlotting.time_series_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">time_series_plot(time_series::Dict{String, Any}; &lt;keyword arguments&gt;)::Plots.Plot</code></pre><p>Make four line plots (in a single figure with a 2x2 layout) of the number of particles,  the total mass, the baryonic fractional mass and the SFR, the first three for gas and stars. </p><p>All the plots show the evolution of the corresponding parameter versus time.</p><p><strong>Arguments</strong></p><ul><li><code>time_series::Dict{String,Any}</code>: Return value of the timeSeriesData function.</li><li><code>mass_factor::Int64=0</code>: Numerical exponent to scale the mass,  e.g. if mass_factor = 10 =&gt; the corresponding axis will be scaled by 10^10.</li><li><code>number_factor::Int64=0</code>: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 =&gt; the corresponding axis will be scaled by 10^4.</li></ul><p><strong>Returns</strong></p><ul><li>The plot generated by the PGFPlotsX backend of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GADGETPlotting/blob/0fde53fd26732819524a76031e9a05897be194dd/src/plotting.jl#L1032-L1049">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pipelines/">« Pipeline Functions</a><a class="docs-footer-nextpage" href="../data_acquisition/">Data Acquisition Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 May 2021 20:45">Wednesday 12 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
