var documenterSearchIndex = {"docs":
[{"location":"auxiliary/#Auxiliary-Functions","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"Modules = [GADGETPlotting]\nPages   = [\"auxiliary.jl\"]","category":"page"},{"location":"auxiliary/#GADGETPlotting.center_of_mass-Tuple{Matrix{var\"#s8\"} where var\"#s8\"<:Real, Vector{var\"#s7\"} where var\"#s7\"<:Real}","page":"Auxiliary Functions","title":"GADGETPlotting.center_of_mass","text":"center_of_mass(\n    position_data::Matrix{<:Real},\n    mass_data::Vector{<:Real},\n)::Union{NTuple{3, Float64}, Nothing}\n\nCompute the center of mass as\n\nR_c = frac1M sum_n m_n  r_n  \n\nwhere M = sum_n m_n and m_n and r_n are the mass and distance  from the origin of the n-th particle.\n\nIf the length of R is less than 10^-3 the length of the larger position vector in position_data, nothing is returned.\n\nArguments\n\nposition_data::Matrix{<:Real}: Positions of the particles.\nmass_data::Vector{<:Real}: Masses of the particles.\n\nReturns\n\nThe center of mass in the unis of position_data.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.comparison-Tuple{Any, Any}","page":"Auxiliary Functions","title":"GADGETPlotting.comparison","text":"comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool\n\nDetermine if two elements are equal, as per the isequal function.\n\nArguments\n\nx: First element to be compared.\ny: Second element to be compared.\natol::Float64 = 1e-5: Absolute tolerance (for compatibility).\nrtol::Float64 = 1e-5: Relative tolerance (for compatibility).\n\nReturns\n\nReturns isequal(x, y).\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.comparison-Tuple{Number, Number}","page":"Auxiliary Functions","title":"GADGETPlotting.comparison","text":"comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool\n\nDetermine if two elements are equal, as per the isequal function.\n\nArguments\n\nx: First element to be compared.\ny: Second element to be compared.\natol::Float64 = 1e-5: Absolute tolerance (for compatibility).\nrtol::Float64 = 1e-5: Relative tolerance (for compatibility).\n\nReturns\n\nReturns isequal(x, y).\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}","page":"Auxiliary Functions","title":"GADGETPlotting.comparison","text":"comparison(x, y; atol::Float64 = 1e-5, rtol::Float64 = 1e-5)::Bool\n\nDetermine if two elements are equal, as per the isequal function.\n\nArguments\n\nx: First element to be compared.\ny: Second element to be compared.\natol::Float64 = 1e-5: Absolute tolerance (for compatibility).\nrtol::Float64 = 1e-5: Relative tolerance (for compatibility).\n\nReturns\n\nReturns isequal(x, y).\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.compute_cmdf-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.compute_cmdf","text":"compute_cmdf(\n    mass_data::Vector{Float64},\n    metallicity_data::Vector{Float64},\n    max_Z::Float64,\n    bins::Int64; \n    <keyword arguments>\n)::NTuple{2, Vector{Float64}}\n\nCompute the cumulative metallicity distribution function up to a metallicity of max_Z. \n\nThe CMDF is calculated separating in bins windows the stellar metallicity, within the  range [0, max_Z]. For the n-th window the CMDF is\n\nsum_i = 1^n dfracm_iM_T quad mathrmvs quad barZ_n  \n\nor, for x_norm = true, \n\nsum_i = 1^n dfracm_iM_T quad mathrmvs quad dfracbarZ_nmathrmmax(barZ_n)  \n\nwhere M_T is the total stellar mass, m_i the stellar mass of the i-th window and barZ_n the mean stellar metallicity of the n-th window.\n\nmass_data and metallicity_data must be in the same mass units.\n\nArguments\n\nmass_data::Vector{Float64}: Masses of the particles.\nmetallicity_data::Vector{Float64}: Metallicities of the particles. \nmax_Z::Float64: Maximum metallicity up to which the CMDF will be calculated.\nbins::Int64: Number of subdivisions of [0, max_Z] to be used for the CMDF.\nx_norm::Bool = false: If the x axis will be normalized to its maximum value. \n\nReturns\n\nA Tuple of two Arrays. The first with the metallicities and the second with the accumulated masses,  of each window.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.deep_comparison-Tuple{Dict, Dict}","page":"Auxiliary Functions","title":"GADGETPlotting.deep_comparison","text":"deep_comparison(\n    x::Dict, \n    y::Dict; \n    atol::Float64 = 1e-5, \n    rtol::Float64 = 1e-5,\n)::Bool\n\nDetermine if two dictionaries are approximately equal.\n\nNumeric elements are compared with the comparison function, everything else with  the isequal function.\n\nArguments\n\nx::Dict: First dictionary to be compared.\ny::Dict: Second dictionary to be compared.\natol::Float64 = 1e-5: Absolute tolerance for numeric elements.\nrtol::Float64 = 1e-5: Relative tolerance for numeric elements.\n\nReturns\n\nReturn true if every pair of elements within the dictionaries pass the equality tests.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.deep_comparison-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}","page":"Auxiliary Functions","title":"GADGETPlotting.deep_comparison","text":"deep_comparison(\n    x::Union{AbstractArray, Tuple}, \n    y::Union{AbstractArray, Tuple}; \n    atol::Float64 = 1e-5, \n    rtol::Float64 = 1e-5,\n)::Bool\n\nDetermines if two arrays or tuples are approximately equal.\n\nNumeric elements are compared with the comparison function, everything else with  the isequal function.\n\nArguments\n\nx::Union{AbstractArray, Tuple}: First array to be compared.\ny::Union{AbstractArray, Tuple}: Second array to be compared.\natol::Float64 = 1e-5: Absolute tolerance for numeric elements.\nrtol::Float64 = 1e-5: Relative tolerance for numeric elements.\n\nReturns\n\nReturn true if every pair of elements pass the equality tests.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.density_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.density_profile","text":"density_profile(\n    mass_data::Vector{Float64},\n    distance_data::Vector{Float64},\n    max_radius::Float64,\n    bins::Int64,\n)::NTuple{2, Vector{Float64}}\n\nCompute a density profile up to a radius max_radius. \n\nIt divides a sphere of radius max_radius, centered at (0, 0, 0), in bins spherical  shells of equal width max_radius / bins. This results in a volume for the n-th shell of\n\nV_n = frac43pimathrmwidth^3(3n^2 - 3n + 1)  \n\nSo, the assigned density for that shell is rho_n = M_n  V_n where M_n is the total  mass within the shell.\n\nmax_radius and distance_data must be in the same length units.\n\nArguments\n\nmass_data::Vector{Float64}: Masses of the particles.\ndistance_data::Vector{Float64}: Radial distances of the particles. \nmax_radius::Float64: Maximum distance up to which the profile will be calculated.\nbins::Int64: Number of subdivisions of [0, max_radius] to be used for the profile.\n\nReturns\n\nA Tuple with two arrays.  The first with the radial distances and the second with the densities, of each shell.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.energy_integrand-Tuple{GadgetIO.SnapshotHeader, Float64}","page":"Auxiliary Functions","title":"GADGETPlotting.energy_integrand","text":"energy_integrand(header::GadgetIO.SnapshotHeader, a::Float64)::Float64\n\nGive the integrand of the scale factor to physical time function\n\nfrac1Hsqrtepsilon  \n\nwhere \n\nepsilon = Omega_lambda + frac1 - Omega_lambda - Omega_0a^2 + fracOmega_0a^3   \n\nH = H_0  a  \n\nArguments\n\nheader::GadgetIO.SnapshotHeader: Header of the relevant snapshot file.\na::Float64: Dimensionless scale factor.\n\nReturns\n\nThe integrand in Gyr evaluated in a .\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.format_error-Tuple{Float64, Float64}","page":"Auxiliary Functions","title":"GADGETPlotting.format_error","text":"format_error(mean::Float64, error::Float64)::String\n\nFormat the mean and error values.\n\nIt follows the traditional rules for error presentation. The error has only one significant   digit, unless such digit is a one, in which case, two significant digits are used.   The mean will have a number of digits such as to match the last significant position  of the error. \n\nArguments\n\nmean::Float64: Mean value.\nerror::Float64: Error value. It must be positive.\n\nReturns\n\nA Tuple with the formatted mean and error values.\n\nExamples\n\njulia> format_error(69.42069, 0.038796)\n(69.42, 0.04)\n\njulia> format_error(69.42069, 0.018796)\n(69.421, 0.019)\n\njulia> format_error(69.42069, 0.0)\n(69.42069, 0.0)\n\njulia> format_error(69.42069, 73.4)\n(0.0, 70.0)\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.kennicutt_schmidt_law-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64}","page":"Auxiliary Functions","title":"GADGETPlotting.kennicutt_schmidt_law","text":"kennicutt_schmidt_law(\n    gas_mass_data::Vector{Float64},\n    gas_distance_data::Vector{Float64},\n    temperature_data::Vector{Float64},\n    star_mass_data::Vector{Float64},\n    star_distance_data::Vector{Float64},\n    age_data::Vector{Float64},\n    temp_filter::Float64,\n    age_filter::Float64,\n    max_r::Float64; \n    <keyword arguments>\n)::Union{Nothing, Dict{String, Any}}\n\nCompute the mass area density and the SFR area density for the Kennicutt-Schmidt law. \n\nThe area densities are calculated by projecting the positions of the stars and of the  particles of gas to the x-y plane. Then the space is subdivided in bins concentric  rings from 0 to max_r, each of equal width max_r / bins. This results in an area  for the n-th ring of\n\nA_n = π  mathrmwidth^2  (2  n - 1)  \n\nSo, the assigned SFR for that ring is \n\nSigma_mathrmSFR^n = fracM_*^nmathrmage_filterA_n  \n\nwhere M_*^n is the total mass of stars younger than age_filter within the ring.\n\nEquivalently, the mass area density of the gas is given by\n\nSigma_rho^n = fracM_rho^nA_n  \n\nwhere M_rho^n is the total mass of gas colder than temp_filter within the ring.\n\ntemp_filter and temperature_data must be in the same temperature units,  and age_filter and age_data must be in the same time units.\n\nArguments\n\ngas_mass_data::Vector{Float64}: Masses of the gas particles.\ngas_distance_data::Vector{Float64}: 2D radial distances of the gas particles. \ntemperature_data::Vector{Float64}: Temperatures of the gas particles.\nstar_mass_data::Vector{Float64}: Masses of the stars.\nstar_distance_data::Vector{Float64}: 2D radial distances of the stars.\nage_data::Vector{Float64}: Ages of the stars.\ntemp_filter::Float64: Maximum temperature allowed for the gas particles.\nage_filter::Float64: Maximum age allowed for the stars.\nmax_r::Float64: Maximum distance up to which the parameters will be calculated.\nbins::Int64 = 50: Number of subdivisions of [0, max_r] to be used. It has to be at  least 5.\n\nReturns\n\nA dictionary with three entries.\nKey \"RHO\" => Logarithm of the area mass densities.\nKey \"SFR\" => Logarithm of the SFR area densities.\nKey \"LM\" => Linear model given by GLM.jl.\nOr nothing if there are less than 5 data points in the end result.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.make_video-Tuple{String, String, String, String, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.make_video","text":"make_video(\n    source_path::String,\n    source_format::String,\n    output_path::String,\n    output_filename::String,\n    frame_rate::Int64,\n)::Nothing\n\nMake an MP4 video from a series of images. \n\nThe H.264 codec with no compression is used and the source images can be in any format available in ImageIO.jl.\n\nArguments\n\nsource_path::String: Path to the directory containing the images.\t\nsource_format::String: File format of the source images, e.g. \".png\", \".svg\", etc.\noutput_path::String: Path to the directory where the resulting video will be saved.\noutput_filename::String: Name of the video to be generated without extension.\t\nframe_rate::Int64: Frame rate of the video to be generated.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.mass_profile-Tuple{Vector{Float64}, Vector{Float64}, Float64, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.mass_profile","text":"mass_profile(\n    mass_data::Vector{Float64},\n    distance_data::Vector{Float64},\n    max_radius::Float64,\n    bins::Int64,\n)::NTuple{2, Vector{Float64}}\n\nCompute an cumulative mass profile up to a radius max_radius. \n\nIt divides a sphere of radius max_radius, centered at (0, 0, 0), in bins spherical  shells of equal width max_radius / bins. This results in a cumulative mass for  the n-th shell of\n\nM_n = sum_i = 1^n m_i  \n\nwhere m_i is the total mass within the i-th shell.\n\nmax_radius and distance_data must be in the same length units.\n\nArguments\n\nmass_data::Vector{Float64}: Masses of the particles.\ndistance_data::Vector{Float64}: Radial distances of the particles. \nmax_radius::Float64: Maximum distance up to which the profile will be calculated.\nbins::Int64: Number of subdivisions of [0, max_radius] to be used for the profile.\n\nReturns\n\nA Tuple of two arrays. The first with the radial distances and the second with the accumulated masses,  of each shell.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.max_length-Tuple{Matrix{var\"#s11\"} where var\"#s11\"<:Real}","page":"Auxiliary Functions","title":"GADGETPlotting.max_length","text":"max_length(data::Matrix{<:Real})::Float64\n\nMaximum norm of the positions in data.\n\ndata must be a matrix with three rows (x, y, and z coordinates respectively) and where  each column is a position.\n\nArguments\n\ndata::Matrix{<:Real}: Positions of the particles.\n\nReturns\n\nThe maximum norm of the position vectors in data.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.metallicity_profile-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.metallicity_profile","text":"metallicity_profile(\n    mass_data::Vector{Float64},\n    distance_data::Vector{Float64},\n    z_data::Vector{Float64},\n    max_radius::Float64,\n    bins::Int64,\n)::NTuple{2, Vector{Float64}}\n\nCompute a metallicity profile up to a radius max_radius (normalized to solar metallicity).\n\nIt divides a sphere of radius max_radius, centered at (0, 0, 0), in bins spherical  shells of equal width max_radius / bins. This results in a relative metallicity for  the n-th shell of\n\nrho_n = dfracz_nM_nZ_odot  \n\nwhere M_n is the total mass and z_n the total content of metals, within the shell.\n\nmax_radius and distance_data must be in the same length units,  and z_data and mass_data must be in the same mass units.\n\nArguments\n\nmass_data::Vector{Float64}: Masses of the particles.\ndistance_data::Vector{Float64}: Radial distances of the particles. \nz_data::Vector{Float64}: Metal content of the particles in mass units.\nmax_radius::Float64: Maximum distance up to which the profile will be calculated.\nbins::Int64: Number of subdivisions of [0, max_radius] to be used for the profile.\n\nReturns\n\nA Tuple of two arrays. The first with the radial distances and the second with the metallicities, of each shell.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.num_integrate","page":"Auxiliary Functions","title":"GADGETPlotting.num_integrate","text":"num_integrate(\n    func::Function, \n    inf_lim::Float64, \n    sup_lim::Float64, \n    steps::Int64 = 200,\n)::Float64\n\nGive the numerical integral of func between inf_val and sup_val. \n\nThe result is given by\n\nint_mathrminf_lim^mathrmsup_lim f(x) mathrmdx approx sum_i = 1^mathrmsteps f(mathrminf_lim + mathrmwidthi )  \n\nwhere mathrmwidth = (mathrmsup_lim - mathrminf_lim)  mathrmsteps.\n\nArguments\n\nfunc::Function: 1D function to be integrated.\ninf_lim::Float64: Lower limit of the integral.\nsup_lim::Float64: Upper limit if the integral.\nsteps::Int64: Number of subdivisions to be used for the discretization of  the [inf_lim, sup_lim] region.\n\nReturns\n\nThe value of the integral.\n\nExamples\n\njulia> num_integrate(sin, 0, 3π)\n1.9996298761360816\n\njulia> num_integrate(x -> x^3 + 6 * x^2 + 9 * x + 2, 0, 4.69)\n438.9004836958452\n\njulia> num_integrate(x -> exp(x^x), 0, 1.0)\n2.1975912134624904\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#GADGETPlotting.pass_all-Tuple{String, String}","page":"Auxiliary Functions","title":"GADGETPlotting.pass_all","text":"pass_all(snap_file::String, type::String)::Vector{Int64}\n\nDefault filter function for the read_blocks_over_all_files function.\n\nIt does not filter out any particles, allowing the data acquisition functions to gather  all the data. \n\nArguments\n\nsnap_file::String: Snapshot file path.\ntype::String: Particle type.\n\"gas\" -> Gas particle. \n\"dark_matter\" -> Dark matter particle.\n\"stars\" -> Star particle.\n\nReturns\n\nA Vector with the indices of the allowed particles.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.quantities_2D-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Float64, Float64, Float64}","page":"Auxiliary Functions","title":"GADGETPlotting.quantities_2D","text":"quantities_2D(\n    gas_mass_data::Vector{Float64},\n    gas_distance_data::Vector{Float64},\n    temperature_data::Vector{Float64},\n    star_mass_data::Vector{Float64},\n    star_distance_data::Vector{Float64},\n    age_data::Vector{Float64},\n    metal_mass_data::Matrix{Float64},\n    fmol_data::Vector{Float64},\n    temp_filter::Float64,\n    age_filter::Float64,\t\n    max_r::Float64;\n    bins::Int64 = 50,\n)::Dict{String, Vector}\n\nCompute the surface density of several quantities. \n\nThe area densities are calculated by projecting the positions of the stars and the  particles of gas to the x-y plane. Then the space is subdivided in bins concentric  rings from 0 to max_r, each of equal width max_r / bins. This results in an area  for the n-th ring of\n\nA_n = π  mathrmwidth^2  (2  n - 1)  \n\nSo, the assigned SFR for that ring is \n\nSigma_mathrmSFR^n = fracM_*^nmathrmage_filterA_n  \n\nwhere M_*^n is the total mass of stars younger than age_filter within the ring.\n\nEquivalently, the mass area density of the gas and stars is given by\n\nSigma_rho^n = fracM_rho^nA_n  \n\nSigma_*^n = fracM_*^nA_n  \n\nwhere M_rho^n is the total mass of gas colder than temp_filter within the ring.\n\ntemp_filter and temperature_data must be in the same temperature units,  and age_filter and age_data must be in the same time units.\n\nThe rest of the parameters are define as follows\n\nmathrmSSFR^n = fracSigma_mathrmSFR^nSigma_*mathrm(total)^n  \n\nmathrmSFE^n = fracSigma_mathrmSFR^nSigma_rhomathrm(total)^n  \n\nmathrmP^n = Sigma_rhomathrm(total)^nleft(Sigma_rhomathrm(total)^n + Sigma_*mathrm(total)^nright)  \n\nmathrmΨH_2^n = fracSigma_mathrmSFR^n  A_nM_H_2^n  \n\nwhere Sigma_rhomathrm(total)^n is the mass density of all the gas,  Sigma_*mathrm(total)^n is the stellar density of all the stars and M_H_2^n is the total mass of molecular Hydrogen.\n\nArguments\n\ngas_mass_data::Vector{Float64}: Masses of the gas particles.\ngas_distance_data::Vector{Float64}: 2D radial distances of the gas particles. \ntemperature_data::Vector{Float64}: Temperatures of the gas particles.\nstar_mass_data::Vector{Float64}: Masses of the stars.\nstar_distance_data::Vector{Float64}: 2D radial distances of the stars.\nage_data::Vector{Float64}: Ages of the stars.\nmetal_mass_data::Matrix{Float64}: Masses of the individual elements (H, O, He, C, etc.) within the gas particles.\nfmol_data::Vector{Float64}: Fraction of molecular Hydrogen of the gas particles.\ntemp_filter::Float64: Maximum temperature allowed for the gas particles.\nage_filter::Unitful.Quantity: Maximum age allowed for the stars.\nmax_r::Float64: Maximum distance up to which the parameters will be calculated.\nbins::Int64 = 50: Number of subdivisions of [0, max_r] to be used. It has to be at  least 5.\n\nReturns\n\nA dictionary with nine entries.\nKey \"GAS\" => Surface mass density of gas\nKey \"COLD_GAS\" => Surface mass density of cold gas\nKey \"STARS\" => Surface mass density of stars\nKey \"OH\" => 12 + log10(oxygenmass / hydrogenmass)\nKey \"SFR\" => Star formation rate surface density\nKey \"SSFR\" => Specific star formation rate surface density\nKey \"SFE\" => Star formation efficiency surface density\nKey \"P\" => Proportional to the pressure\nKey \"Psi_FMOL\" => Star formation rate per unit of molecular gas\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.relative","page":"Auxiliary Functions","title":"GADGETPlotting.relative","text":"relative(\n    p::Plots.Plot,\n    rx::Float64,\n    ry::Float64,\n    rz::Union{Float64, Nothing} = nothing; \n    <keyword arguments>\n)::Union{NTuple{2, Float64}, NTuple{3, Float64}}\n\nGive the absolute coordinates within a plot, from the relative ones.\n\nIf any of the axes are in a logarithmic scale, you should set log appropriately to get  correct results.\n\nArguments\n\np::Plots.Plot: Plot for which the absolute coordinates will be calculated.\nrx::Float64: relative x coordinate, rx ∈ [0, 1].\nry::Float64: relative y coordinate, ry ∈ [0, 1].\nrz::Union{Float64,Nothing} = nothing: relative z coordinate, rz ∈ [0, 1].\nlog::Union{NTuple{2, Bool}, NTuple{3, Bool}} = (false, false, false): If the x, y or z  axes are in a logarithmic scale.\n\nReturns\n\nA Tuple with the absolute coordinates: (x, y) or (x, y, z).\n\nExamples\n\njulia> GADGETPlotting.relative(plot(rand(100)), 0.5, 0.5)\n(50.5, 0.5047114800322484)\n\njulia> GADGETPlotting.relative(surface(rand(100, 100)), 0.5, 0.5, 0.5)\n(50.5, 50.5, 0.5000284432744244)\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#GADGETPlotting.set_vertical_flags-Tuple{Union{Nothing, Tuple{Vector{var\"#s8\"} where var\"#s8\"<:Real, Vector{var\"#s7\"} where var\"#s7\"<:AbstractString}}, Plots.Plot}","page":"Auxiliary Functions","title":"GADGETPlotting.set_vertical_flags","text":"set_vertical_flags(\n    flags::Union{Tuple{Vector{<:Real}, Vector{<:AbstractString}}, Nothing}, \n    plot::Plots.Plot; \n    <keyword arguments>\n)::Plots.Plot\n\nDraw vertical lines at specified positions.\n\nIf you only want labels for the vertical lines, the original plot should have label = \"\".\n\nArguments\n\nflags::Union{Tuple{Vector{<:Real}, Vector{<:AbstractString}}, Nothing} = nothing: The first  vector in the Tuple has the positions of the vetical lines. The second has the  corresponding labels.\nplot::Plots.Plot: Plot to which the vertical lines will be added.\n\nReturns\n\nNew plot with the vertical lines added.\n\n\n\n\n\n","category":"method"},{"location":"auxiliary/#GADGETPlotting.smooth_window-Tuple{Vector{var\"#s10\"} where var\"#s10\"<:Real, Vector{var\"#s11\"} where var\"#s11\"<:Real, Int64}","page":"Auxiliary Functions","title":"GADGETPlotting.smooth_window","text":"smooth_window(\n    x_data::Vector{<:Real},\n    y_data::Vector{<:Real},\n    bins::Int64,\n)::NTuple{2, Vector{Float64}}\n\nSeparate the values in x_data in bins contiguous windows, and replaces every x and y  value within the window with the corresponding mean to smooth out the data. \n\nArguments\n\nx_data::Vector{<:Real}: x-axis data.\ny_data::Vector{<:Real}: y-axis data.\nbins::Int64: Number of windows to be used in the smoothing.\nlog::Bool = false: If the x-axis data will be separated using logarithmic bins.\n\nReturns\n\nA Tuple with two arrays containing the smoothed out x and y data.\n\n\n\n\n\n","category":"method"},{"location":"func_list/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"func_list/","page":"Index","title":"Index","text":"","category":"page"},{"location":"pipelines/#Pipeline-functions","page":"Pipeline Functions","title":"Pipeline functions","text":"","category":"section"},{"location":"pipelines/","page":"Pipeline Functions","title":"Pipeline Functions","text":"Modules = [GADGETPlotting]\nPages   = [\"pipelines.jl\"]","category":"page"},{"location":"pipelines/#GADGETPlotting.birth_histogram_pipeline-Tuple{String, String}","page":"Pipeline Functions","title":"GADGETPlotting.birth_histogram_pipeline","text":"birth_histogram_pipeline(\n    base_name::String,\n    source_path::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the birth_histogram_plot function as one image per snapshot,  if there are stars present. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\noutput_path::String = \"birth_histogram\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.cmdf_pipeline-Tuple{String, String}","page":"Pipeline Functions","title":"GADGETPlotting.cmdf_pipeline","text":"cmdf_pipeline(\n    base_name::String,\n    source_path::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the cmdf_plot function as one image per snapshot, if there are  stars present. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\noutput_path::String = \"CMDF\": Path to the output directory. The images will be stored  in output_path/images/ and will be named base_name_XXXformat where XXX is the  number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nx_norm::Bool = false: If the x axis will be normalized to its maximum value. \ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the time  stamps, all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.cmdf_pipeline-Tuple{Vector{String}, Vector{String}, Matrix{String}}","page":"Pipeline Functions","title":"GADGETPlotting.cmdf_pipeline","text":"cmdf_pipeline(\n    base_name::Vector{String},\n    source_path::Vector{String},\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the cmdf_plot function for several simulations as one image  per snapshot, if there are stars present.\n\nArguments\n\nbase_name::Vector{String}: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::Vector{String}: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nlabels::Array{String, 2}: Labels for the different simulations.\noutput_path::String = \"CMDF\": Path to the output directory. The images will be stored  in output_path/images/ and will be named base_name_XXXformat where XXX is the  ordinal of the frame. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots  will be plotted.\nx_norm::Bool = false: If the x axis will be normalized to its maximum value. \ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the time stamps, all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.compare_simulations_pipeline-Tuple{Vector{String}, Vector{String}, Matrix{String}, String, String, String}","page":"Pipeline Functions","title":"GADGETPlotting.compare_simulations_pipeline","text":"compare_simulations_pipeline(\n    base_name::Vector{String},\n    source_path::Vector{String},\n    labels::Array{String, 2},\n    fig_name::String,\n    x_quantity::String,\n    y_quantity::String; \n    <keyword arguments>\n)::Nothing\n\nMake a figure comparing y_quantity vs. x_quantity for several simulations.\n\nx_quantity and y_quantity can be any magnitude used in the get_time_evolution  function, namely:\n\n\"scale_factor\"                  \n\"redshift\"                  \n\"clock_time\" (Physical time)\n\"sfr\" (SFR) \t\t\t              \n\"sfr_prob\" (SFR probability - Not normalized) \t\t\t           \n\"gas_number\" (Gas particle number) \t            \n\"dm_number\" (Dark matter particle number)\t\t               \n\"star_number\" (Star number)         \n\"gas_mass\" (Total gas mass)               \n\"dm_mass\" (Total dark matter mass)\t            \n\"star_mass\" (Total star mass)\t\n\"gas_density\" (Total gas density)\t               \n\"gas_frac\" (Gas fraction)\t\t                \n\"dm_frac\" (Dark matter fraction)\t\t                \n\"star_frac\" (Star fraction)\t                   \n\"gas_bar_frac\" (Baryonic gas fraction)                  \n\"star_bar_frac\" (Baryonic star fraction)\n\nThe numeric values of a quantity can also be saved as a text files for the simulations.  One column per simulation, one row per sanpshot.\n\nArguments\n\nbase_name::Vector{String}: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::Vector{String}: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nlabels::Array{String, 2}: Labels for the different simulations, e.g. [label1 label2 ...].\nfig_name::String: Base name for the figure. The file will be named fig_name`yquantity_vs_x_quantityformat`.\nx_quantity::String: Physical magnitude for the x axis. \ny_quantity::String: Physical magnitude for the y axis.\noutput_path::String = \"compare_simulations\": Path to the output directory. The images  will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\ntitle::String = \"\": Title for the figure. If an empty string is given, no title is  printed.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x  and y axes. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nsmooth_data::Bool = false: If true a smoothing window with no weighs is applied to  the y data. If false (the default) no transformation occurs.\nbins::Int64 = 0: Number of subdivisions for the smoothing of the data, only relevant if smooth_data = true. \nlegend_pos::Symbol = :bottomright: Position of the legend, e.g. :topleft.\ntext_quantity::String = \"\": Name of the quantity to be saved in a text file.  Any magnitude used in the get_time_evolution function can be used. If left empty no  text file will be produced.\nfile_name::String = \"results\": Name of the .dat file that will be generated if  text_quantity is not an empty string.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used,  e.g. UnitfulAstro.Msun.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used,  e.g. UnitfulAstro.Myr.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used, e.g. UnitfulAstro.Msun/UnitfulAstro.yr.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used  in the output, all available length units in UnitfulAstro.jl and UnitfulAstro.jl  can be used.\ndensity_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3: Unit of  density to be used in the output, all available density units in UnitfulAstro.jl and  UnitfulAstro.jl can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\".  \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.cpu_txt_pipeline-Tuple{Vector{String}, String, Matrix{String}}","page":"Pipeline Functions","title":"GADGETPlotting.cpu_txt_pipeline","text":"cpu_txt_pipeline(\n    source_path::Vector{String},\n    target::String,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Nothing\n\nSave the result of the cpu_txt_plot function, comparing the CPU usage of one  process among several simulations. \n\nArguments\n\nsource_path::Vector{String}: Paths to the directories containing the cpu.txt files,  set in the GADGET variable OutputDir.\ntarget::String: Target process.\nlabels::Array{String, 2}: Labels for the different simulations.\nstep::Int64 = 1: Step used to traverse the CPU cycles, i.e. one every step cycles is  used for the output plot.\noutput_path::String = \"cpu_txt\": Path to the output directory.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.cpu_txt_pipeline-Tuple{Vector{String}, Vector{String}}","page":"Pipeline Functions","title":"GADGETPlotting.cpu_txt_pipeline","text":"cpu_txt_pipeline(\n    source_path::Vector{String},\n    targets::Vector{String}; \n    <keyword arguments>\n)::Nothing\n\nSave the result of the cpu_txt_plot function as one image per simulation.\n\nArguments\n\nsource_path::Vector{String}: Paths to the directories containing the cpu.txt files,  set in the GADGET variable OutputDir.\ntargets::Vector{String}: Target processes to be plotted for each simulation.\nstep::Int64 = 1: Step used to traverse the CPU cycles, i.e. one every step cycles is  used for the output plot.\noutput_path::String = \"cpu_txt\": Path to the output directory.\ntitle::Vector{String} = String[]: Titles for the figures. If an empty string is given  no title is printed, which is the default.\nnames::Vector{String} = String[]: Names for the files. If an empty string is given, the  images will be assigned a number, starting from 0.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.density_histogram_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.density_histogram_pipeline","text":"density_histogram_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the density_histogram_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nVertical lines with personalized positions and ticks can be added to the plot. By default none are drawn.\n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"density_histogram\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nflags::Union{Tuple{Vector{<:Real}, Vector{<:AbstractString}}, Nothing} = nothing: The first  vector in the Tuple has the positions of the vetical lines. The second has the  corresponding labels. The positions should be in the correct units of density and take  into account factor.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the x axis will be scaled by 10^10. The default is no scaling.\ny_scale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\ndensity_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3: Unit of  density to be used in the output, all available density units in Unitful and UnitfulAstro  can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.density_map_pipeline-Tuple{String, String, Union{Nothing, String}, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.density_map_pipeline","text":"density_map_pipeline(\n    base_name::String,\n    source_path::String,\n    z_quantity::Union{String, Nothing},\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the density_map_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\nz_quantity::Union{String, Nothing}: Quantity to be mapped. The options are:\n\"Z\": The metallicity (relative to solar metallicity).\n\"fmol\": The fraction of molecular gas.\n\"fatom\": The fraction of atomic gas.\nnothing: The density itself will be mapped.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"density_map\": Path to the output directory. The images will  be stored in output_path/images/ and will be named base_name_XXXformat where XXX  is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nplane::String = \"All\": Indicates which plane will be plotted. \n\"XY\" ⟶ x-y plane alone.\n\"XZ\" ⟶ x-z plane alone.\n\"YZ\" ⟶ y-z plane alone.\n\"All\" ⟶ The three planes in a single 1x3 figure.\naxes::Bool = false: If true, the axes passing through (0, 0) are drawn. If false,  no axes are drawn.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the  GR backend can be used, namely \".pdf\", \".ps\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.density_profile_pipeline-Tuple{String, String, String, Int64, String}","page":"Pipeline Functions","title":"GADGETPlotting.density_profile_pipeline","text":"density_profile_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64,\n    type::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the density_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\noutput_path::String = \"density_profile\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.density_profile_pipeline-Tuple{Vector{String}, Vector{String}, String, Int64, String, Matrix{String}}","page":"Pipeline Functions","title":"GADGETPlotting.density_profile_pipeline","text":"density_profile_pipeline(\n    base_name::Vector{String},\n    source_path::Vector{String},\n    anim_name::String,\n    frame_rate::Int64,\n    type::String,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the density_profile_plot function for several simulations as one image  per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::Vector{String}: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::Vector{String}: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\nlabels::Array{String, 2}: Labels for the different simulations.\noutput_path::String = \"density_profile\": Path to the output directory. The images will  be stored in output_path/images/ and will be named frame_XXXformat where XXX is the  ordinal of the frame. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.evolution_summary_pipeline-Tuple{String, String, String}","page":"Pipeline Functions","title":"GADGETPlotting.evolution_summary_pipeline","text":"evolution_summary_pipeline(\n    base_name::String,\n    source_path::String,\n    fig_name::String; \n    <keyword arguments>\n)::Nothing\n\nProduce up to three figures summarizing the time evolution of the simulation.\n\nThe plotted parameters are the number of particles, the total mass, the baryonic  fractional mass and the star formation rate (SFR), the first three for gas and stars. If the simulation is Newtonian, only one figure is produced (parameters vs. time), but if the simulation is cosmological, three figures are produced (parameters vs. time, parameters vs. scale factor and parameters vs. redshift).\n\nArgs:\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\nfig_name::String: Base name for the figures. The images will be named fig_name_vs_XXXformat where XXX is 'time', 'redshift' or 'scale_factor'.\noutput_path::String = \"evolution_summary\": Path to the output directory. The images  will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nmass_factor::Int64 = 0: Numerical exponent to scale the mass, e.g. if mass_factor = 10  the corresponding axis will be scaled by 10^10.\nnumber_factor::Int64 = 0: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4 the corresponding axis will be scaled by 10^4.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.fatom_rho_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.fatom_rho_pipeline","text":"fatom_rho_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the fatom_rho_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"fatom_vs_rho\"\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\".  \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.fmol_Z_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.fmol_Z_pipeline","text":"fmol_Z_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the fatom_rho_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"fmol_vs_Z\"\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\".  \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.fmol_fatom_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.fmol_fatom_pipeline","text":"fmol_fatom_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the fmol_fatom_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"fmol_vs_ftom\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.fraction_histogram_pipeline-Tuple{String, String, String, Int64, String}","page":"Pipeline Functions","title":"GADGETPlotting.fraction_histogram_pipeline","text":"fraction_histogram_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64,\n    fraction::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the fraction_histogram_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nVertical lines with personalized positions and ticks can be added to the plot. By default none are drawn.\n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\nfraction::String: Which fraction to plot against the temperature. The options are\n\"atomic\": Atomic fraction.\n\"molecular\": Molecular fraction.\noutput_path::String = \"density_histogram\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nflags::Union{Tuple{Vector{<:Real}, Vector{<:AbstractString}}, Nothing} = nothing: The first  vector in the Tuple has the positions of the vetical lines. The second has the  corresponding labels. The positions should be in the correct units of density and take  into account factor.\nbins::Int64 = 20: Number of subdivisions used for the histogram.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ny_scale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.fraction_temp_pipeline-Tuple{String, String, String, Int64, String}","page":"Pipeline Functions","title":"GADGETPlotting.fraction_temp_pipeline","text":"fraction_temp_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64,\n    fraction::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the fraction_temp_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\nfraction::String: Which fraction to plot against the temperature. The options are\n\"atomic\": Atomic fraction.\n\"molecular\": Molecular fraction.\noutput_path::String = \"rho_vs_temp\": Path to the output directory. The images will be  stored in output_path/images/ and will be named base_name_XXXformat where XXX is  the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ntemp_unit::Unitful.FreeUnits = Unitful.K: Unit of temperature to be used in the  output, all available temperature units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.gas_star_evolution_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.gas_star_evolution_pipeline","text":"gas_star_evolution_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of gas_star_evolution_plot function for the last snapshot as one image and  generate a GIF and a video animating the whole evolution for all snapshots. \n\nArguments\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"gas_star_evolution\": Path to the output directory.  The image will be stored in output_path/images/ and will be named  base_name_XXXformat where XXX is the number of the last snapshot.  The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots  will be plotted.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the  GR backend can be used, namely \".pdf\", \".ps\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.kennicutt_schmidt_pipeline-Tuple{String, String}","page":"Pipeline Functions","title":"GADGETPlotting.kennicutt_schmidt_pipeline","text":"kennicutt_schmidt_pipeline(\n    base_name::String,\n    source_path::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the kennicutt_schmidt_plot function as one image per snapshot.\n\nIt will produce output only for the snapshots that have enough young stars to produce  at least five data points for the linear fitting.\n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\noutput_path::String = \"Kennicutt_Schmidt\": Path to the output directory. The images will  be stored in output_path/images/ and will be named base_name_XXXformat where XXX  is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ntemp_filter::Unitful.Quantity = Inf * Unitful.K: Maximum temperature allowed for the  gas particles.\nage_filter::Unitful.Quantity = 20.0UnitfulAstro.Myr: Maximum star age allowed for the  calculation of the SFR.\nmax_r::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Maximum distance up to which the  parameters will be calculated, with units.\nbins::Int64 = 50: Number of subdivisions of [0, max_r] to be used.  It has to be at least 5.\nerror_formating::String = \"std_error\": What to print as error values. The options are:\n\"std_error\" ⟹ mean ± standard_error.\n\"conf_interval\" ⟹ mean ± max(upper_95% - mean, mean - lower_95%).\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.mass_profile_pipeline-Tuple{String, String, String, Int64, String}","page":"Pipeline Functions","title":"GADGETPlotting.mass_profile_pipeline","text":"mass_profile_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64,\n    type::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the mass_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\noutput_path::String = \"mass_profile\": Path to the output directory. The images will be  stored in output_path/images/ and will be named base_name_XXXformat where XXX is  the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nfactor::Int64 = 0: Numerical exponent to scale the mass, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.mass_profile_pipeline-Tuple{Vector{String}, Vector{String}, String, Int64, String, Matrix{String}}","page":"Pipeline Functions","title":"GADGETPlotting.mass_profile_pipeline","text":"mass_profile_pipeline(\n    base_name::Vector{String},\n    source_path::Vector{String},\n    anim_name::String,\n    frame_rate::Int64,\n    type::String,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the mass_profile_plot function for several simulations as one image  per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::Vector{String}: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::Vector{String}: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\nlabels::Array{String, 2}: Labels for the different simulations.\noutput_path::String = \"mass_profile\": Path to the output directory. The images will be  stored in output_path/images/ and will be named frame_XXXformat where XXX is the  ordinal of the frame. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nfactor::Int64 = 0: Numerical exponent to scale the mass, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\".  \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.metallicity_profile_pipeline-Tuple{String, String, String, Int64, String}","page":"Pipeline Functions","title":"GADGETPlotting.metallicity_profile_pipeline","text":"metallicity_profile_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64,\n    type::String; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the metallicity_profile_plot function as one image per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\noutput_path::String = \"metallicity_profile\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.metallicity_profile_pipeline-Tuple{Vector{String}, Vector{String}, String, Int64, String, Matrix{String}}","page":"Pipeline Functions","title":"GADGETPlotting.metallicity_profile_pipeline","text":"metallicity_profile_pipeline(\n    base_name::Vector{String},\n    source_path::Vector{String},\n    anim_name::String,\n    frame_rate::Int64,\n    type::String,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the metallicity_profile_plot function for several simulations as one  image per snapshot, and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::Vector{String}: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::Vector{String}: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\nlabels::Array{String,2}: Labels for the different simulations.\noutput_path::String = \"metallicity_profile\": Path to the output directory. The images  will be stored in output_path/images/ and will be named frame_XXXformat where XXX is  the ordinal of the frame. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used.  Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.quantities_2D_pipeline-Tuple{String, String}","page":"Pipeline Functions","title":"GADGETPlotting.quantities_2D_pipeline","text":"quantities_2D_pipeline(\n    base_name::String,\n    source_path::String; \n    <keyword arguments>\n)\n\nSave the results of the quantities_2D_plot function as one folder per snapshot.\n\nIt will produce output only for snapshots that have stars.\n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\noutput_path::String = \"Kennicutt_Schmidt\": Path to the output directory. The images will  be stored in output_path/images/ and will be named base_name_XXXformat where XXX  is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ntemp_filter::Unitful.Quantity = Inf * Unitful.K: Maximum temperature allowed for the  gas particles.\nage_filter::Unitful.Quantity = 20.0UnitfulAstro.Myr: Maximum star age allowed for the  calculation of the SFR.\nmax_r::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Maximum distance up to which the  parameters will be calculated, with units.\nbins::Int64 = 50: Number of subdivisions of [0, max_r] to be used.  It has to be at least 5.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x and y  axes. It will apply equally to every figure produced. The options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.rho_temp_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.rho_temp_pipeline","text":"rho_temp_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the rho_temp_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"rho_vs_temp\": Path to the output directory. The images will be  stored in output_path/images/ and will be named base_name_XXXformat where XXX is  the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ntemp_unit::Unitful.FreeUnits = Unitful.K: Unit of temperature to be used in the  output, all available temperature units in Unitful and UnitfulAstro can be used.\ndensity_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3: Unit of  density to be used in the output, all available density units in Unitful and UnitfulAstro  can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.scatter_grid_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.scatter_grid_pipeline","text":"scatter_grid_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the scatter_grid_plot function as one image per snapshot,  and then generate a GIF and video animating the images. \n\nArguments\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"scatter_grid\": Path to the output directory. The images will  be stored in output_path/images/ and will be named base_name_XXXformat where XXX  is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".ps\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.sfr_txt_pipeline-Tuple{Vector{String}, Vector{String}, Int64, Vector{Int64}}","page":"Pipeline Functions","title":"GADGETPlotting.sfr_txt_pipeline","text":"sfr_txt_pipeline(\n    snapshots::Vector{String},\n    source_path::Vector{String},\n    x_axis::Int64,\n    y_axis::Vector{Int64}; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the sfr_txt_plot function as one image per simulation or one image  per column depending on comparison_type.\n\nwarning: Warning\nThis function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.\n\nArguments\n\nsnapshots::Vector{String}: Path to the snapshot files, to get its headers.\nsource_path::Vector{String}: Paths to the directories containing the sfr.txt files,  set in the GADGET variable OutputDir.\nx_axis::Int64: Column number for the x axis.\ny_axis::Vector{Int64}: Column numbers for the y axis.\noutput_path::String = \"sfr_txt\": Path to the output directory.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\ncomparison_type::Int64 = 0: Selects which parameters (columns or simulations) will be compared:\n0 ⟶ Different columns are compared, for a single simulation (one plot per simulation).\n1 ⟶ Different simulations are compared, using the same column (one plot per column).\ntitles::Vector{String} = String[]: Titles for the figures. If an empty string is given, no title is printed.\nnames::Vector{String} = String[]: Names for the files. If an empty string is given, the  images will be assigned a number given by the order of source_path.\nlabels::Union{Nothing, Array{String, 2}} = nothing: Labels for the different  simulations. Only relevant if comparison_type = 1.\nbins::Int64 = 0: Number of subdivisions for the smoothing of the data.  The default is no smoothing. It will apply equally to every figure produced.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x and y  axes. It will apply equally to every figure produced. The options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nmin_filter::NTuple{2, Float64} = (-Inf, -Inf): Value filter for the x and y axes.  It will apply equally to every figure produced. If a value of the x data is lower  than min_filter[1], then it is deleted. Equivalently with the y axis and min_filter[2].  The default is -Inf for both, i.e. no filtering.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful and UnitfulAstro can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful and UnitfulAstro can be used.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful and UnitfulAstro  can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.star_map_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.star_map_pipeline","text":"star_map_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the star_map_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"star_map\": Path to the output directory. The images will  be stored in output_path/images/ and will be named base_name_XXXformat where XXX  is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\nplane::String = \"All\": Indicates which plane will be plotted. \n\"XY\" ⟶ x-y plane alone.\n\"XZ\" ⟶ x-z plane alone.\n\"YZ\" ⟶ y-z plane alone.\n\"All\" ⟶ The three planes in a single 1x3 figure.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region  if vacuum boundary conditions were used. Its unit doesn't have to be the same  as length_unit.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\naxes::Bool = false: If true, the axes passing through (0, 0) are drawn. If false,  no axes are drawn.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used in the  output, all available length units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the  GR backend can be used, namely \".pdf\", \".ps\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"pipelines/#GADGETPlotting.temperature_histogram_pipeline-Tuple{String, String, String, Int64}","page":"Pipeline Functions","title":"GADGETPlotting.temperature_histogram_pipeline","text":"temperature_histogram_pipeline(\n    base_name::String,\n    source_path::String,\n    anim_name::String,\n    frame_rate::Int64; \n    <keyword arguments>\n)::Nothing\n\nSave the results of the temperature_histogram_plot function as one image per snapshot,  and then generate a GIF and a video animating the images. \n\nArguments\n\nbase_name::String: Base names of the snapshot files, set in the GADGET  variable SnapshotFileBase.\nsource_path::String: Paths to the directories containing the snapshot files,  set in the GADGET variable OutputDir.\nanim_name::String: File name of the generated video and GIF, without the extension.\nframe_rate::Int64: Frame rate of the output video and GIF.\noutput_path::String = \"temperature_histogram\": Path to the output directory. The images  will be stored in output_path/images/ and will be named base_name_XXXformat where  XXX is the number of the snapshot. The GIF and the video will be stored in output_path.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nstep::Int64 = 1: Step used to traverse the list of snapshots. By default all snapshots will be plotted.\ntemp_unit::Unitful.FreeUnits = Unitful.K: Unit of temperature to be used in the  output, all available temperature units in Unitful and UnitfulAstro can be used.\nformat::String = \".png\": File format of the output figure. All formats supported by the GR backend can be used, namely \".pdf\", \".svg\" and \".png\". \n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting-Functions","page":"Plotting Functions","title":"Plotting Functions","text":"","category":"section"},{"location":"plotting/","page":"Plotting Functions","title":"Plotting Functions","text":"Modules = [GADGETPlotting]\nPages   = [\"plotting.jl\"]","category":"page"},{"location":"plotting/#GADGETPlotting.birth_histogram_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.birth_histogram_plot","text":"birth_histogram_plot(birth_data::Dict{String, Any}; <keyword arguments>)::Plots.Plot\n\nMake a histogram of the number of stars born at a certain radial distance.\n\nArguments\n\nbirth_data::Dict{String, Any}: Return value of the get_birth_place function.\nbins::Int64 = 50: Number of bins to use in the histogram.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.cmdf_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.cmdf_plot","text":"cmdf_plot(\n    m_data::Dict{String, Any}, \n    z_data::Dict{String, Any},\n    time::Unitful.Quantity;\n    <keyword arguments>\n)::Plots.Plot\n\nMake a cumulative metallicity distribution function (CMDF) plot, for a given time step.\n\nm_data and z_data must be in the same units.\n\nArguments\n\nm_data::Dict{String, Any}: Return value of the get_mass function.\nz_data::Dict{String, Any}: Return value of the get_metallicity function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nbins::Int64: Number of subdivisions of the metallicity to construct the plot.\nx_norm::Bool = false: If the x axis will be normalized to its maximum value. \n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.cmdf_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.cmdf_plot","text":"cmdf_plot(\n    m_data::Vector{Dict{String, Any}}, \n    z_data::Vector{Dict{String, Any}},\n    time::Unitful.Quantity,\n    labels::Array{String, 2};\n    <keyword arguments>\n)::Plots.Plot\n\nMake a cumulative metallicity distribution function (CMDF) plot of several datasets,  for a given time step.\n\nm_data and z_data must be in the same units.\n\nArguments\n\nm_data::Vector{Dict{String, Any}}: Return values of the get_mass function.\nz_data::Vector{Dict{String, Any}}: Return values of the get_metallicity function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nlabels::Array{String, 2}: Labels for the different simulations.\nbins::Int64: Number of subdivisions of the metallicity to construct the plot.\nx_norm::Bool = false: If the x axis will be normalized to its maximum value. \n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.compare_simulations_plot-Tuple{Vector{Dict{String, Any}}, String, String, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.compare_simulations_plot","text":"compare_simulations_plot(\n    data::Vector{Dict{String, Any}},\n    x_quantity::String,\n    y_quantity::String,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot comparing y_quantity vs. x_quantity of several simulations.\n\nThe data of each simulation must be in the same units, and x_quantity and y_quantity  can be any magnitude used in the get_time_evolution function, namely:\n\n\"scale_factor\"                  \n\"redshift\"                  \n\"clock_time\" (Physical time)\n\"sfr\" (SFR) \t\t\t              \n\"sfr_prob\" (SFR probability - Not normalized) \t\t\t           \n\"gas_number\" (Gas particle number) \t            \n\"dm_number\" (Dark matter particle number)\t\t               \n\"star_number\" (Star number)         \n\"gas_mass\" (Total gas mass)               \n\"dm_mass\" (Total dark matter mass)\t            \n\"star_mass\" (Total star mass)\t\n\"gas_density\" (Global gas density)\t               \n\"gas_frac\" (Gas fraction)\t\t                \n\"dm_frac\" (Dark matter fraction)\t\t                \n\"star_frac\" (Star fraction)\t                   \n\"gas_bar_frac\" (Baryonic gas fraction)                  \n\"star_bar_frac\" (Baryonic star fraction)\n\nArguments\n\ndata::Vector{Dict{String,Any}}: Return value of the get_time_evolution function for  every simulation in a Vector, e.g. [data_sim1, data_sim2].\nx_quantity::String: Physical magnitude for the x axis. \ny_quantity::String: Physical magnitude for the y axis.\nlabels::Array{String, 2}: Labels for the different simulations.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x  and y axes. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nsmooth_data::Bool = false: If true a smoothing window with no weighs is applied to  the y data. If false, no transformation occurs.\nbins::Int64 = 0: Number of subdivisions for the smoothing of the data, only relevant if smooth_data = true. \nlegend_pos::Symbol = :bottomright: Position of the legend, e.g. :topleft.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.cpu_txt_plot","page":"Plotting Functions","title":"GADGETPlotting.cpu_txt_plot","text":"cpu_txt_plot(\n    data::Vector{Dict{String, Matrix{Float64}}},\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot of a process' CPU usage (as percentages) for several simulations, from  the data in the cpu.txt file.\n\nIf data contains more than ones process, only the first one will be used.\n\nArguments\n\ndata::Vector{Dict{String, Matrix{Float64}}}: Vector of return values of the get_cpu_txt function.\nlabels::Array{String, 2}: Labels for the different simulations.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#GADGETPlotting.cpu_txt_plot-2","page":"Plotting Functions","title":"GADGETPlotting.cpu_txt_plot","text":"cpu_txt_plot(\n    data::Dict{String, Matrix{Float64}}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot of the CPU usage of several processes (as percentages), from the data in the  cpu.txt file.\n\nArguments\n\ndata::Dict{String, Matrix{Float64}}: Return values of the get_cpu_txt function.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#GADGETPlotting.density_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.density_histogram_plot","text":"density_histogram_plot(\n    density_data::Dict{String, Any},\n    time::Unitful.Quantity; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a histogram with the densities of the gas particles.\n\nArguments\n\ndensity_data::Dict{String,Any}: Return value of the get_density function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nbins::Int64 = 20: Number of bins to use in the histogram.\nfactor::Int64 = 0: Numerical exponent to scale density_data, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\ny_scale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.density_map_plot-Tuple{Union{Nothing, Vector{Float64}}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.density_map_plot","text":"density_map_plot(\n    z::Union{Vector{Float64}, Nothing},\n    position_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    density_data::Dict{String, Any}\n    hsml_data::Dict{String, Any}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot of the gas density in the x-y, x-z and/or y-z planes. \n\nThe axes are in the units given by position_data[\"unit\"].\n\nArguments\n\nz::Union{Vector{Float64}, Nothing}: Vector with the data to be mapped, if nothing the density will be mapped.\nposition_data::Dict{String,Any}: Return value of the get_position function.\nmass_data::Dict{String,Any}: Return value of the get_mass function.\ndensity_data::Dict{String,Any}: Return value of the get_density function.\nhsml_data::Dict{String,Any}: Return value of the get_hsml function.\nplane::String = \"All\": String indicating which plane will be plotted. \n\"XY\" ⟹ x-y plane alone.\n\"XZ\" ⟹ x-z plane alone.\n\"YZ\" ⟹ y-z plane alone.\n\"All\" ⟹ The three planes in a single 1x3 figure.\naxes::Bool = false: If true, the axes passing through (0, 0) are drawn. If false,  no axes are drawn.\naxes_color::Symbol = :white: Color of the axes passing through (0, 0), only relevant  if axes = true.\ncolor::Symbol = :inferno: Color scheme for the figure.  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.density_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.density_profile_plot","text":"density_profile_plot(\n    position_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    time::Unitful.Quantity; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a density profile plot for a given time step.\n\nArguments\n\nposition_data::Dict{String, Any}: Return value of the get_position function.\nmass_data::Dict{String, Any}: Return value of the get_mass function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile. \nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.density_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.density_profile_plot","text":"density_profile_plot(\n    position_data::Vector{Dict{String, Any}},\n    mass_data::Vector{Dict{String, Any}},\n    time::Unitful.Quantity,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a density profile plot comparing several datasets, for a given time step.\n\nArguments\n\nposition_data::Vector{Dict{String, Any}}: Vector of return values of the get_position function.\nmass_data::Vector{Dict{String, Any}}: Vector of return values of the get_mass function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nlabels::Array{String, 2}: Labels for the different simulations.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile.\nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.fatom_rho_plot-Tuple{Vector{Float64}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.fatom_rho_plot","text":"fatom_rho_plot(\n    fatom_data::Vector{Float64},\n    density_data::Dict{String, Any},\n    time::Unitful.Quantity,\n)::Plots.Plot\n\nMake a plot of atomic fraction vs. the density, for the gas particles at a given time step.\n\nArguments\n\nfatom_data::Vector{Float64}: Return value of the get_fatom function.\ndensity_data::Dict{String, Any}: Return value of the get_density function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.fmol_Z_plot-Tuple{Vector{Float64}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.fmol_Z_plot","text":"fmol_Z_plot(\n    fmol_data::Vector{Float64},\n    metallicity_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    time::Unitful.Quantity,\n)::Plots.Plot\n\nMake a plot of molecular fraction vs. the metallicity, for the gas particles at a given  time step.\n\nArguments\n\nfmol_data::Vector{Float64}: Return value of the get_fmol function.\nmetallicity_data::Dict{String, Any}: Return value of the get_metallicity  function.\nmass_data::Dict{String, Any}: Return value of the get_mass function, for gas.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.fmol_fatom_plot-Tuple{Vector{Float64}, Vector{Float64}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.fmol_fatom_plot","text":"fmol_fatom_plot(\n    fmol_data::Vector{Float64},\n    fatom_data::Vector{Float64},\n    density_data::Dict{String, Any},\n    metallicity_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    time::Unitful.Quantity,\n)::Plots.Plot\n\nMake a plot of molecular fraction vs. the metallicity, for the gas particles at a given  time step.\n\nArguments\n\nfmol_data::Vector{Float64}: Return value of the get_fmol function.\nfatom_data::Vector{Float64}: Return value of the get_fatom function.\ndensity_data::Dict{String, Any}: Return value of the get_density function.\nmetallicity_data::Dict{String, Any}: Return value of the get_metallicity  function.\nmass_data::Dict{String, Any}: Return value of the get_mass function, for gas.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.fraction_histogram_plot-Tuple{Vector{Float64}, Unitful.Quantity, String}","page":"Plotting Functions","title":"GADGETPlotting.fraction_histogram_plot","text":"fraction_histogram_plot(\n    x_data::Vector{Float64},\n    time::Unitful.Quantity,\n    x_label::String; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a histogram with the molecular or atomic fractions of the gas particles.\n\nArguments\n\nx_data::Vector{Float64}: Return value of the get_fmol or get_fatom function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nx_label::String: Label for the x axis.\nbins::Int64 = 20: Number of bins to use in the histogram.\ny_scale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟶ no scaling.\n:log10 ⟶ logarithmic scaling.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.fraction_temp_plot-Tuple{Dict{String, Any}, Vector{Float64}, Unitful.Quantity, String}","page":"Plotting Functions","title":"GADGETPlotting.fraction_temp_plot","text":"fraction_temp_plot(\n    temperature_data::Dict{String, Any},\n    y_data::Vector{Float64},\n    time::Unitful.Quantity,\n    y_label::String,\n)::Plots.Plot\n\nMake a plot of molecular or atomic fraction vs. mathrmlog_10(T),  for the gas particles at a given time step.\n\nArguments\n\ntemperature_data::Dict{String,Any}: Return value of the get_temperature function.\ny_data::Dict{String, Any}: Return value of the get_fmol or get_fatom function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\ny_label::String: Label for the y axis.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.gas_star_evolution_plot-Tuple{Int64, Dict{String, Any}, Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.gas_star_evolution_plot","text":"gas_star_evolution_plot(\n    index::Int64,\n    time_series::Dict{String, Any},\n    position_data::Dict{String, Any}, \n)::Plots.Plot\n\nMakes 3 plots, the position of the particles in the x-y plane, the baryonic fractional mass  and the SFR. The first two for stars and gas. All in a single figure with a 1x2 layout.\n\nThe figure is created with the time running from 0 to time_series[\"clock_time\"][index].\n\nArguments\n\nindex::Int64: Index of the final time step up to which the figure will show the  evolution of the variables.\ntime_series::Dict{String,Any}: Return value of the get_time_evolution function.\t\nposition_data::Dict{String,Any}: Return value of the get_position function.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.kennicutt_schmidt_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.kennicutt_schmidt_plot","text":"kennicutt_schmidt_plot(\n    gas_mass_data::Dict{String, Any},\n    temperature_data::Dict{String, Any},\n    star_mass_data::Dict{String, Any},\n    age_data::Dict{String, Any},\n    pos_data::Dict{String, Any},\n    temp_filter::Unitful.Quantity,\n    age_filter::Unitful.Quantity,\n    max_r::Unitful.Quantity,\n    time::Unitful.Quantity;\n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot of the Kennicutt-Schmidt law for a given snapshot, with the linear fit and  the measured values superimposed for comparison. \n\nArguments\n\ngas_mass_data::Dict{String, Any}: Return value of the get_mass function, for gas.\ntemperature_data::Dict{String, Any}: Return value of the get_temperature function.\nstar_mass_data::Dict{String, Any}: Return value of the get_mass function, for stars.\nage_data::Dict{String, Any}: Return value of the get_age function.\npos_data::Dict{String, Any}: Return value of the get_position function.\ntemp_filter::Unitful.Quantity: Maximum temperature allowed for the gas particles.\nage_filter::Unitful.Quantity: Maximum stellar age allowed.\nmax_r::Unitful.Quantity: Maximum distance up to which the parameters will be calculated.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot. \nbins::Int64 = 50: Number of subdivisions of [0, max_r] to be used.  It has to be at least 5.\nerror_formating::String = \"std_error\": What to print as error values. The options are:\n\"std_error\" ⟹ mean ± standard_error.\n\"conf_interval\" ⟹ mean ± max(upper_95% - mean, mean - lower_95%).\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.mass_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.mass_profile_plot","text":"mass_profile_plot(\n    position_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    time::Unitful.Quantity; \n    <keyword arguments>\n)::Plots.Plot\n\nMake an accumulated mass profile plot for a given time step.\n\nArguments\n\nposition_data::Dict{String, Any}: Return value of the get_position function.\nmass_data::Dict{String, Any}: Return value of the get_mass function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile. \nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.mass_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.mass_profile_plot","text":"mass_profile_plot(\n    position_data::Vector{Dict{String, Any}},\n    mass_data::Vector{Dict{String, Any}},\n    time::Unitful.Quantity,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake an accumulated mass profile plot of several datasets, for a given time step.\n\nArguments\n\nposition_data::Vector{Dict{String, Any}}: Return values of the get_position function.\nmass_data::Vector{Dict{String, Any}}: Return values of the get_mass function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nlabels::Array{String, 2}: Labels for the different simulations.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile. \nfactor::Int64 = 0: Numerical exponent to scale the density, e.g. if factor = 10  the y axis will be scaled by 10^10. The default is no scaling.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.metallicity_profile_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.metallicity_profile_plot","text":"metallicity_profile_plot(\n    position_data::Dict{String, Any},\n    mass_data::Dict{String, Any},\n    z_data::Dict{String, Any},\n    time::Unitful.Quantity; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a metallicity profile plot for a given time step.\n\nArguments\n\nposition_data::Dict{String, Any}: Return value of the get_position function.\nmass_data::Dict{String, Any}: Return value of the get_mass function.\nz_data::Dict{String ,Any}: Return value of the get_metallicity function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile. \nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.metallicity_profile_plot-Tuple{Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Unitful.Quantity, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.metallicity_profile_plot","text":"metallicity_profile_plot(\n    position_data::Vector{Dict{String, Any}},\n    mass_data::Vector{Dict{String, Any}},\n    z_data::Vector{Dict{String, Any}},\n    time::Unitful.Quantity,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a metallicity profile plot comparing several datasets, for a given time step.\n\nArguments\n\nposition_data::Vector{Dict{String, Any}}: Return values of the get_position function.\nmass_data::Vector{Dict{String, Any}}: Return values of the get_mass function.\nz_data::Vector{Dict{String, Any}}: Return values of the get_metallicity function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nlabels::Array{String, 2}: Labels for the different simulations.\nscale::Symbol = :identity: Scaling to be used for the y axis. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nbins::Int64 = 100: Number of subdivisions of the region to be used for the profile. \nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale position_data[\"box_size\"] if vacuum boundary conditions were used, and it will scale position_data[\"box_size\"] / 2.0 if periodic boundary conditions were used.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.quantities_2D_plot-Tuple{Dict{String, Vector{T} where T}, String, String, Dict{String, Unitful.FreeUnits{N, D, nothing} where {N, D}}}","page":"Plotting Functions","title":"GADGETPlotting.quantities_2D_plot","text":"quantities_2D_plot(\n    data::Dict{String, Vector},\n    x_quantity::String,\n    y_quantity::String,\n    units::Dict{String, Unitful.FreeUnits{N, D, nothing} where {N, D}}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot comparing y_quantity vs. x_quantity, taken from the function quantities_2D.\n\nAny of the following quantities can be use:\n\n\"GAS\" (Surface mass density of gas)\n\"COLD_GAS\" (Surface mass density of cold gas)\n\"STARS\" (Surface mass density of stars)\n\"OH\" (12 + log10(oxygenmass / hydrogenmass))\n\"SFR\" (Star formation rate surface density)\n\"SSFR\" (Specific star formation rate surface density)\n\"SFE\" (Star formation efficiency surface density)\n\"P\" (Proportional to the pressure)\n\"Psi_FMOL\" (Star formation rate per unit of molecular gas)\n\nArguments\n\ndata::Vector{Dict{String,Any}}: Return value of the quantities_2D function.\nx_quantity::String: Physical magnitude for the x axis. \ny_quantity::String: Physical magnitude for the y axis.\nunits::Dict{String, Unitful.FreeUnits{N, D, nothing} where {N, D}}: Dictionary with the  units of the quantities in data. It has to have three keys: \"mass\", \"length\" and \"time\",  each pointing to the corresponding unit.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x  and y axes. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.redshift_series_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.redshift_series_plot","text":"redshift_series_plot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot\n\nMake four line plots of the number of particles, the total mass, the baryonic fractional  mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.\n\nAll the plots show the evolution of the corresponding parameter versus the redshift.\n\nArguments\n\ntime_series::Dict{String,Any}: Return value of the get_time_evolution function.\nmass_factor::Int64 = 0: Numerical exponent to scale the mass,  e.g. if mass_factor = 10, the corresponding axis will be scaled by 10^10.\nnumber_factor::Int64 = 0: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4, the corresponding axis will be scaled by 10^4.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.rho_temp_plot-Tuple{Dict{String, Any}, Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.rho_temp_plot","text":"rho_temp_plot(\n    temperature_data::Dict{String, Any},\n    density_data::Dict{String, Any},\n    time::Unitful.Quantity,\n)::Plots.Plot\n\nMake a plot of mathrmlog_10(rho)  mathrmvs  mathrmlog_10(T),  for the gas particles at a given time step.\n\nArguments\n\ntemperature_data::Dict{String,Any}: Return value of the get_temperature function.\ndensity_data::Dict{String, Any}: Return value of the get_density function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.scale_factor_series_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.scale_factor_series_plot","text":"scale_factor_series_plot(time_series::Dict{String,Any}; <keyword arguments>)::Plots.Plot\n\nMake four line plots of the number of particles, the total mass, the baryonic fractional  mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.\n\nAll the plots show the evolution of the corresponding parameter versus the scale factor.\n\nArguments\n\ntime_series::Dict{String,Any}: Return value of the get_time_evolution function.\nmass_factor::Int64 = 0: Numerical exponent to scale the mass,  e.g. if mass_factor = 10, the corresponding axis will be scaled by 10^10.\nnumber_factor::Int64 = 0: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4, the corresponding axis will be scaled by 10^4.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.scatter_grid_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.scatter_grid_plot","text":"scatter_grid_plot(position_data::Dict{String, Any})::Plots.Plot\n\nMake 9 scatter plots showing the positions of the gas, dark matter and stellar particles  in the x-y, x-z and y-x planes.\n\nThe result is a single figure in a 3x3 layout with its axes in the unit given by position_data[\"unit\"].\n\nArguments\n\nposition_data::Dict{String,Any}: Return value of the get_position function.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.sfr_txt_plot-Tuple{Dict{Union{Int64, String}, Any}, Int64, Vector{Int64}}","page":"Plotting Functions","title":"GADGETPlotting.sfr_txt_plot","text":"sfr_txt_plot(\n    data::Dict{Union{Int64, String}, Any},\n    x_axis::Int64,\n    y_axis::Vector{Int64}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot of columns y_axis vs. column x_axis for the data in the sfr.txt file.\n\nwarning: Warning\nThis function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.\n\nArguments\n\ndata::Dict{Union{Int64, String}, Any}: Return values of the get_sfr_txt function.\nx_axis::Int64: Column number for the x axis.\ny_axis::Vector{Int64}: Vector of columns numbers for the y axis.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nbins::Int64 = 0: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x  and y axes. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nmin_filter::NTuple{2, Float64} = (-Inf, -Inf): Value filter for the x and y axes. If a value of the x data is lower than min_filter[1], then it is deleted. Equivalently  with the y axis and min_filter[2]. The default is -Inf for both, i.e. no filtering.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.sfr_txt_plot-Tuple{Vector{Dict{Union{Int64, String}, Any}}, Int64, Int64, Matrix{String}}","page":"Plotting Functions","title":"GADGETPlotting.sfr_txt_plot","text":"sfr_txt_plot(\n    data::Vector{Dict{Union{Int64, String}, Any}},\n    x_axis::Int64,\n    y_axis::Int64,\n    labels::Array{String, 2}; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a plot comparing column y_axis vs. column x_axis for the data in the sfr.txt file of several simulations.\n\nwarning: Warning\nThis function takes a modified version of sfr.txt which is produced by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.\n\nArguments\n\ndata::Vector{Dict{Union{Int64, String}, Any}}: Vector of return values of the get_sfr_txt function.\nx_axis::Int64: Column number for the x axis.\ny_axis::Int64: Column number for the y axis.\nlabels::Array{String, 2}: Labels for the different simulations.\ntitle::String = \"\": Title for the figure. If an empty string is given no title is  printed, which is the default.\nbins::Int64 = 0: Number of subdivisions for the smoothing of the data.  The default is Inf, i.e. no smoothing.\nscale::NTuple{2, Symbol} = (:identity, :identity): Scaling to be used for the x  and y axes. The two options are:\n:identity ⟹ no scaling.\n:log10 ⟹ logarithmic scaling.\nx_factor::Int64 = 0: Numerical exponent to scale the x_quantity, e.g. if x_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\ny_factor::Int64 = 0: Numerical exponent to scale the y_quantity, e.g. if y_factor = 10  the corresponding axis will be scaled by 10^10. The default is no scaling.\nmin_filter::NTuple{2, Float64} = (-Inf, -Inf): Value filter for the x and y axes. If a value of the x data is lower than min_filter[1], then it is deleted. Equivalently  with the y axis and min_filter[2]. The default is -Inf for both, i.e. no filtering.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.star_map_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.star_map_plot","text":"star_map_plot(position_data::Dict{String,Any}; <keyword arguments>)::Plots.Plot\n\nMake a plot of the stellar density in the x-y, x-z and/or y-z planes. \n\nThe axes are in the units given by position_data[\"unit\"].\n\nArguments\n\nposition_data::Dict{String,Any}: Return value of the get_position function.\nplane::String=\"All\": String indicating which plane will be plotted. \n\"XY\" ⟹ x-y plane alone.\n\"XZ\" ⟹ x-z plane alone.\n\"YZ\" ⟹ y-z plane alone.\n\"All\" ⟹ The three planes in a single 1x3 figure.\nbox_factor::Float64 = 1.0: Multiplicative factor for the plotting region.  It will scale positions[\"box_size\"] if vacuum boundary conditions were used, and it will scale positions[\"box_size\"] / 2 if periodic boundary conditions were used.\naxes::Bool = false: If true, the axes passing through (0, 0) are drawn. If false,  no axes are drawn.\naxes_color::Symbol = :white: Color of the axes passing through (0, 0), only relevant  if axes = true.\ncolor::Symbol = :inferno: Color scheme for the figure.  Any one from ColorSchemes.jl can be used. Some good ones are :batlow, :bone, :CMRmap,  :grayC, :seaborn_rocket_gradient, :YlOrRd_9 and :inferno, which is the default.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.temperature_histogram_plot-Tuple{Dict{String, Any}, Unitful.Quantity}","page":"Plotting Functions","title":"GADGETPlotting.temperature_histogram_plot","text":"temperature_histogram_plot(\n    temperature_data::Dict{String, Any},\n    time::Unitful.Quantity; \n    <keyword arguments>\n)::Plots.Plot\n\nMake a histogram of the logarithm of the gas particles' temperatures.\n\nArguments\n\ntemperature_data::Dict{String,Any}: Return value of the get_temperature function.\ntime::Unitful.Quantity: Time with units for the time stamp of the plot.  All available time units in Unitful and UnitfulAstro can be used, e.g. UnitfulAstro.Myr.\nbins::Int64 = 20: Number of bins to use in the histogram.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#GADGETPlotting.time_series_plot-Tuple{Dict{String, Any}}","page":"Plotting Functions","title":"GADGETPlotting.time_series_plot","text":"time_series_plot(time_series::Dict{String, Any}; <keyword arguments>)::Plots.Plot\n\nMake four line plots of the number of particles, the total mass, the baryonic fractional  mass and the SFR, the first three for gas and stars. All in a single figure with a 2x2 layout.\n\nAll the plots show the evolution of the corresponding parameter versus time.\n\nArguments\n\ntime_series::Dict{String,Any}: Return value of the get_time_evolution function.\nmass_factor::Int64 = 0: Numerical exponent to scale the mass,  e.g. if mass_factor = 10, the corresponding axis will be scaled by 10^10.\nnumber_factor::Int64 = 0: Numerical exponent to scale the number of particles,  e.g. if number_factor = 4, the corresponding axis will be scaled by 10^4.\n\nReturns\n\nThe plot generated by the GR backend of Plots.jl.\n\n\n\n\n\n","category":"method"},{"location":"#GADGETPlotting","page":"Introduction","title":"GADGETPlotting","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Julia module for creating plots, GIFs, and videos from GAGET2/3/4 simulations.","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"index.md\",\n    \"pipelines.md\",\n    \"plotting.md\",\n    \"data_acquisition.md\",\n    \"auxiliary.md\",\n    \"func_list.md\",\n]\nDepth = 3","category":"page"},{"location":"#Global-Constants","page":"Introduction","title":"Global Constants","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [GADGETPlotting]\nOrder   = [:constant]","category":"page"},{"location":"#GADGETPlotting.HUBBLE_CONST","page":"Introduction","title":"GADGETPlotting.HUBBLE_CONST","text":"H_0 = 100  mathrmkm  mathrms^-1  mathrmMpc^-1  mathrmin  mathrmGyr^-1\n\n\n\n\n\n","category":"constant"},{"location":"#GADGETPlotting.KENNICUTT98_INTERCEPT","page":"Introduction","title":"GADGETPlotting.KENNICUTT98_INTERCEPT","text":"Intercept for the Kennicutt-Schmidt law.\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical  Journal, 498(2), 541-552. https://doi.org/10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"#GADGETPlotting.KENNICUTT98_RHO_UNIT","page":"Introduction","title":"GADGETPlotting.KENNICUTT98_RHO_UNIT","text":"Unit of area density for the Kennicutt-Schmidt law.\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical  Journal, 498(2), 541-552. https://doi.org/10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"#GADGETPlotting.KENNICUTT98_SLOPE","page":"Introduction","title":"GADGETPlotting.KENNICUTT98_SLOPE","text":"Slope for the Kennicutt-Schmidt law.\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical  Journal, 498(2), 541-552. https://doi.org/10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"#GADGETPlotting.SOLAR_METALLICITY","page":"Introduction","title":"GADGETPlotting.SOLAR_METALLICITY","text":"Solar metallicity.\n\nM. Asplund et al. (2009). The Chemical Composition of the Sun. Annual Review of Astronomy  and Astrophysics, 47(1), 481–522. https://doi.org/10.1146/annurev.astro.46.060407.145222\n\n\n\n\n\n","category":"constant"},{"location":"data_acquisition/#Data-Acquisition-Functions","page":"Data Acquisition Functions","title":"Data Acquisition Functions","text":"","category":"section"},{"location":"data_acquisition/","page":"Data Acquisition Functions","title":"Data Acquisition Functions","text":"Modules = [GADGETPlotting]\nPages   = [\"data_acquisition.jl\"]","category":"page"},{"location":"data_acquisition/#GADGETPlotting.get_age-Tuple{String, Unitful.Quantity}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_age","text":"get_age(snapshot::String, time::Unitful.Quantity; <keyword arguments>)::Dict{String,Any}\n\nGet the ages of the stars at a specific time step.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\ntime::Unitful.Quantity: Clock time of snapshot, with units. All available time units  in Unitful.jl and UnitfulAstro.jl can be used.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nsnap_0::String = \"\": Path to the fist snapshot. Only relevant for cosmological simulations (sim_cosmo = 1).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\n\nReturns\n\nA dictionary with two entries.\n\"ages\" ⟹ The ages of the stars.  \n\"unit\" ⟹ The unit of time used. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_birth_place-Tuple{Int64, Vector{String}, Vector{Float64}, Unitful.FreeUnits}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_birth_place","text":"get_birth_place(\n    snap_index::Int64,\n    snap_files::Vector{String},\n    time_stamps::Vector{Float64},\n    stamps_unit::Unitful.FreeUnits; \n    <keyword arguments>\n)::Dict{String, Any}\n\nGet the birth location of the stars in a given snapshot.\n\nArguments\n\nsnap_index::Int64: Index in snap_files of the snapshot whose stars will be located.\nsnap_files::Vector{String}: Output of the function get_snapshot_path corresponding  to the key \"snap_files\", containing an Array with the paths to the snapshots.\ntime_stamps::Vector{Float64}: Clock time of every snapshot in snap_files.\nstamps_unit::Unitful.FreeUnits: Unit of time of the time_stamps.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.\n\nReturns\n\nA 2 dimensional arrays with the positions of the stars. Each row is a star and each column corresponds to coordinates x, y and z respectively.\n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_cpu_txt-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_cpu_txt","text":"get_cpu_txt(\n    source_path::String, \n    target::String; \n    <keyword arguments>\n)::Dict{String, Matrix{Float64}}\n\nGet the data from the cpu.txt file.\n\nFor the row in target a matrix with all the CPU usage data (as percentages of  total CPU time) is returned.\n\nArguments\n\nsource_path::String: Path to the directory containing the cpu.txt file.\ntarget::String: Target process.\nstep::Int64 = 1: Step used to traverse the CPU cycles, i.e. one every step cycles is  returned.\n\nReturns\n\nA dictionary with one entry.\nprocess ⟹ Matrix with CPU cycles as its first column, and CPU usage (in percentage) as  its second column.   \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_cpu_txt-Tuple{String, Vector{String}}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_cpu_txt","text":"get_cpu_txt(\n    source_path::String, \n    targets::Vector{String}; \n    <keyword arguments>\n)::Dict{String, Matrix{Float64}}\n\nGet the data from the cpu.txt file.\n\nFor each target row in targets a matrix with all the CPU usage data (as percentages of  total CPU time) is returned.\n\nArguments\n\nsource_path::String: Path to the directory containing the cpu.txt file.\ntargets::Vector{String}: Target processes.\nstep::Int64 = 1: Step used to traverse the CPU cycles, i.e. one every step cycles is  returned.\n\nReturns\n\nA dictionary with as many entries as strings in targets.\nprocess ⟹ Matrix with CPU cycles as its first column, and CPU usage (in percentage) as  its second column.   \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_density-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_density","text":"get_density(snapshot::String; <keyword arguments>)::Dict{String,Any}\n\nGet the densities of the gas particles at a specific time step.\n\nArguments\n\nsnapshot::String: Path to the snapshot file.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\ndensity_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3: Unit of  density to be used in the output, all available density units in Unitful.jl and  UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary with two entries.\n\"density\" ⟹ Densities of the gas particles. \n\"unit\" ⟹ The unit of density used, i.e. is a pass-through of density_unit. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_fatom-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_fatom","text":"get_fatom(snapshot::String; <keyword arguments>)::Vector{Float64}\n\nGet the fraction of atomic gas of each particle at a specific time step. \n\nArguments\n\nsnapshot::String: Path to a given snapshot.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\n\nReturns\n\nVector with fraction of atomic gas of each particle\n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_fmol-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_fmol","text":"get_fmol(snapshot::String; <keyword arguments>)::Vector{Float64}\n\nGet the fraction of molecular gas of each particle at a specific time step. \n\nArguments\n\nsnapshot::String: Path to a given snapshot.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\n\nReturns\n\nVector with fraction of molecular gas of each particle\n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_hsml-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_hsml","text":"get_hsml(snapshot::String; <keyword arguments>)::Dict{String,Any}\n\nGet the smoothing lengths of the gas particles at a specific time step.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.\n\nReturns\n\nA dictionary with two entries.\n\"hsml\" ⟹ Smoothing lengths of the gas particles. \n\"unit\" ⟹ The unit of length used, i.e. is a pass-through of length_unit. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_mass-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_mass","text":"get_mass(snapshot::String, type::String; <keyword arguments>)::Dict{String,Any}\n\nGet the mass of all the particles at a specific time step.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"dark_matter\" ⟶ Dark matter particle.\n\"stars\" ⟶ Star particle.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary with three entries.\n\"mass\" ⟹ Masses of the particles. \n\"unit\" ⟹ The unit of mass used, i.e. is a pass-through of mass_unit. \n\"type\" ⟹ Particle type, i.e. is a pass-through of type. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_metal_mass-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_metal_mass","text":"get_metal_mass(snapshot::String, type::String; <keyword arguments>)::Dict{String,Any}\n\nGet the mass of several elements within each particle at a specific time step. \n\nArguments\n\nsnapshot::String: Path to a given snapshot.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"stars\" ⟶ Star particle.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary with two entries.\n\"Z\" ⟹ Matrix where each row is an element, and each column a particle.  \n01: He (Helium)\n\n* 02: C (Carbon)\n* 03: Mg (Magnesium)\n* 04: 0 (Oxygen)\n* 05: Fe (Iron)\n* 06: Si (Silicon)\n* 07: H (Hydrogen)\n* 08: N (Nitrogen)\n* 09: Ne (Neon)\n* 10: S (Sulfur)\n* 11: Ca (Calcium)\n* 12: Zn (Zinc)\n\n\"unit\" ⟹ The unit of mass used, i.e. is a pass-through of mass_unit. \n\"type\" ⟹ Particle type, i.e. is a pass-through of type. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_metallicity-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_metallicity","text":"get_metallicity(snapshot::String, type::String; <keyword arguments>)::Dict{String,Any}\n\nGet the metallicity of the particles at a specific time step. With metallicity define as  the total mass of all elements except Hydrogen and Helium.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\ntype::String: Particle type.\n\"gas\" ⟶ Gas particle. \n\"stars\" ⟶ Star particle.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary with two entries.\n\"Z\" ⟹ Metallicities of the particles.  \n\"unit\" ⟹ The unit of mass used, i.e. is a pass-through of mass_unit. \n\"type\" ⟹ Particle type, i.e. is a pass-through of type. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_position-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_position","text":"get_position(snapshot::String; <keyword arguments>)::Dict{String, Any}\n\nGet the coordinates of all the particles at a specific time step.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\ncenter::Union{String, Nothing} = nothing: How to adjust the center of mass.\nnothing: No adjustments to the center of mass are made.\n\"local\": Each type of particle gets its center of mass to (0, 0, 0) independently.\n\"baryon\": Baryons and dark matter get their centers of mass to (0, 0, 0) independently.\n\"global\": The center of mass of the whole system gets to (0, 0, 0).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nbox_size::Unitful.Quantity = 1000.0UnitfulAstro.kpc: Size of the plotting region if  vacuum boundary conditions were used. It has to have units but they don't have to be  the same as length_unit.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.\n\nReturns\n\nA dictionary with six entries.\n\"gas\", \"dark_matter\", \"stars\" ⟹ 2 dimensional arrays with the positions of  the particles of the type given by the key. Each row is a particle and each column  correspond to coordinates x, y and z respectively.\n\"box_size\" ⟹ The range of values for the plotting of the positions, i.e. a range  of ± box_size if vacuum boundary conditions were used, or (0, header.boxsize)  if periodic boundary conditions were used. Notice how the side length of the region is 2 * box_size for vacuum boundary  conditions and header.boxsize for periodic boundary conditions.\n\"periodic\" ⟹ If the boundary condition are periodic.\n\"unit\" ⟹ The unit of length used, i.e. is a pass-through of length_unit. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_sfr_txt-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_sfr_txt","text":"get_sfr_txt(\n    source_path::String,\n    snapshot::String; \n    <keyword arguments>\n)::Dict{Union{Int64, String}, Any}\n\nGet the column data from the sfr.txt file.\n\nTransform from internal units to the ones given by mass_unit, time_unit and sfr_unit.\n\nWarning\n\nThis function takes a modified version of sfr.txt generated by a private version of  GADGET3. GADGET4 produces a sfr.txt, but it is not compatible with this function.\n\nArguments\n\nsource_path::String: Path to the directory containing the sfr.txt file.\nsnapshot::String: Path to a particular snapshot file, to use its header.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful.jl and UnitfulAstro.jl can be used.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful.jl and UnitfulAstro.jl  can be used.\n\nReturns\n\nA dictionary with seven entries.\n1 ⟹ The first column (time).  \n2 ⟹ The second column (total mass - probability).  \n3 ⟹ The third column (SFR - original GADGET).  \n4 ⟹ The fourth column (SFR - probability).  \n5 ⟹ The fifth column (real total mass).  \n6 ⟹ The sixth column (real SFR).  \n\"units\" ⟹ Units used, i.e. is a pass-through of mass_unit, time_unit and sfr_unit. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_snapshot_path-Tuple{String, String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_snapshot_path","text":"function get_snapshot_path(\n    base_name::String,\n    source_path::String,\n)::Dict{String, Vector{String}}\n\nFind the paths to the GADGET output files, grouping them by snapshot.\n\nArguments\n\nbase_name::String: Base name of the snapshot files,  set in the GADGET variable SnapshotFileBase.\nsource_path::String: Path to the directory containing the snapshot files,  set in the GADGET variable OutputDir.\n\nReturns\n\nA dictionary with two entries. \n\"numbers\" ⟹ The numbers that characterize each snapshot.\n\"snap_files\" ⟹ The paths to the snapshot files.\n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_temperature-Tuple{String}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_temperature","text":"get_temperature(snapshot::String; <keyword arguments>)::Dict{String,Any}\n\nGet the temperature of the gas particles at a specific time step.\n\nTo compute the temperature we use\n\nT = (gamma - 1)  frace  mk_B  \n\nwhere gamma is the adiabatic index, e is the internal energy per unit mass, m the mass per particle (protons and electrons) and k_B is the Boltzmann constant.  In particular, we take gamma = 53. For how we compute e and m see the  comments in the source code of this function.\n\nArguments\n\nsnapshot::String: Path to a given snapshot.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\ntemp_unit::Unitful.FreeUnits = Unitful.K: Unit of temperature to be used in the output,  all available temperature units in Unitful.jl and UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary with two entries.\n\"temperature\" ⟹ Temperatures of the particles.  \n\"unit\" ⟹ The unit of temperature used, i.e. is a pass-through of temp_unit. \n\n\n\n\n\n","category":"method"},{"location":"data_acquisition/#GADGETPlotting.get_time_evolution-Tuple{Vector{String}}","page":"Data Acquisition Functions","title":"GADGETPlotting.get_time_evolution","text":"get_time_evolution(snap_files::Vector{String}; <keyword arguments>)::Dict{String, Any}\n\nGet the time series of several parameters for the whole simulation. \n\nThe parameters are:\n\n\"scale_factor\"                  \n\"redshift\"                  \n\"clock_time\" (Physical time)\n\"sfr\" (SFR) \t\t\t              \n\"sfr_prob\" (SFR probability - Not normalized) \t\t\t           \n\"gas_number\" (Gas particle number) \t            \n\"dm_number\" (Dark matter particle number)\t\t               \n\"star_number\" (Star number)         \n\"gas_mass\" (Total gas mass)               \n\"dm_mass\" (Total dark matter mass)\t            \n\"star_mass\" (Total star mass)\t\n\"gas_density\" (Global gas density)\t               \n\"gas_frac\" (Gas fraction)\t\t                \n\"dm_frac\" (Dark matter fraction)\t\t                \n\"star_frac\" (Star fraction)\t                   \n\"gas_bar_frac\" (Baryonic gas fraction)                  \n\"star_bar_frac\" (Baryonic star fraction)\n\nArguments\n\nsnap_files::Vector{String}: Output of the function get_snapshot_path corresponding  to the key \"snap_files\", containing an Array with the paths to the snapshots.\nsim_cosmo::Int64 = 0: Value of the GADGET variable ComovingIntegrationOn: \n0 ⟶ Newtonian simulation (static universe).\n1 ⟶ Cosmological simulation (expanding universe).\nfilter_function::Function = pass_all: A function with the signature: \nfoo(snap_file::String, type::String)::Vector{Int64}\nSee the function pass_all for an example. By default, no particles are filtered.\nmass_unit::Unitful.FreeUnits = UnitfulAstro.Msun: Unit of mass to be used in the output,  all available mass units in Unitful.jl and UnitfulAstro.jl can be used.\ntime_unit::Unitful.FreeUnits = UnitfulAstro.Myr: Unit of time to be used in the output,  all available time units in Unitful.jl and UnitfulAstro.jl can be used.\nsfr_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.yr: Unit of mass/time to  be used in the output, all available time and mass units in Unitful.jl and UnitfulAstro.jl  can be used.\nlength_unit::Unitful.FreeUnits = UnitfulAstro.kpc: Unit of length to be used  in the output, all available length units in Unitful.jl and UnitfulAstro.jl  can be used.\ndensity_unit::Unitful.FreeUnits = UnitfulAstro.Msun / UnitfulAstro.kpc^3: Unit of  density to be used in the output, all available density units in Unitful.jl and  UnitfulAstro.jl can be used.\n\nReturns\n\nA dictionary.\n\"{property}\" ⟹ Numeric values of the property in the key (one value per snapshot)  for the whole simulation. \n\"units\" ⟹ Units used, for easy piping with other functions.\n\"labels\" ⟹ Labels to be used when plotting the quantities.\n\n\n\n\n\n","category":"method"}]
}
